package org.opentestsystem.ap.migration.service;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.gitlab4j.api.utils.FileUtils;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.model.ItemName;
import org.opentestsystem.ap.migration.config.AppProps;
import org.opentestsystem.ap.migration.model.BranchResult;
import org.opentestsystem.ap.migration.model.ItemInfo;
import org.opentestsystem.ap.migration.model.ItemResult;
import org.opentestsystem.ap.migration.model.MigrationError;
import org.opentestsystem.ap.migration.model.MigrationReport;
import org.opentestsystem.ap.migration.repository.ReportRepository;
import org.opentestsystem.ap.migration.util.Util;
import org.springframework.stereotype.Component;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;
import static org.apache.commons.collections4.CollectionUtils.isEmpty;
import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;
import static org.apache.commons.collections4.ListUtils.emptyIfNull;
import static org.apache.commons.lang3.StringUtils.equalsIgnoreCase;

@Slf4j
@Component
public class DeletionService {

    private final Util util;

    private final AppProps appProps;

    private final ItemBankProperties itemBankProperties;

    private final GitlabClient gitlabClient;

    private final ReportRepository reportRepository;

    private final AsyncService asyncService;

    public DeletionService(final Util util,
                           final GitlabClient gitlabClient,
                           final AsyncService asyncService,
                           final ReportRepository reportRepository) {
        this.util = util;
        this.appProps = util.getAppProps();
        this.gitlabClient = gitlabClient;
        this.itemBankProperties = util.getItemBankProperties();
        this.asyncService = asyncService;
        this.reportRepository = reportRepository;
    }

    public void deleteItems() {
        if (appProps.isDeleteItemsEnabled()) {
            log.info("item deletion is enabled");

            final MigrationReport migrationReport = new MigrationReport();
            migrationReport.startMigrationTimer();

            final List<ItemName> itemsToDelete = getItems();
            migrationReport.setItemsToProcessCount(itemsToDelete.size());

            final List<ItemResult> itemResults = deleteProjects(itemsToDelete);
            migrationReport.setItemResults(itemResults);

            migrationReport.stopMigrationTimer();

            if (appProps.isPublishReportEnabled()) {
                final Path reportFile = reportRepository.publishReport(migrationReport);
                logReport(reportFile);
                reportRepository.deleteLocalReportRepository();
            } else {
                String reportString = reportRepository.generateReport(migrationReport);
                log.info("\r\n{}", reportString);
            }

        } else {
            log.info("item deletion is disabled");
        }
    }

    private List<ItemResult> deleteProjects(final List<ItemName> projects) {
        List<ItemResult> deleteResults = new ArrayList<>();

        if (isNotEmpty(projects)) {
            for (ItemName project : projects) {
              deleteResults.add(deleteProject(project));
            }
        }

        return deleteResults;
    }

    private ItemResult deleteProject(final ItemName project) {
        ItemResult result = new ItemResult();
        String itemId = project.getName();

        result.setItemId(itemId);

        if (StringUtils.isNotEmpty(itemId)) {

            BranchResult branchResult = new BranchResult(itemId, "");
            try {
                gitlabClient.deleteProject(project.getId());
                result.addSuccessfulBranchMigration(branchResult);
            } catch (Exception e) {
                MigrationError migrationError =
                        new MigrationError(itemId, "", "", "",
                        e.getMessage());
                result.addFailedBranchMigration(migrationError);
            }
        }

//        final List<String> itemsToKeep = emptyIfNull(appProps.getDoNotDeleteItems());
//
//        final String itemId = project.getName();
//
//        // if it's not in the list then delete it
//        if (!itemsToKeep.contains(itemId) && !equalsIgnoreCase(itemBankProperties.getReportRepoName(), itemId)) {
//            log.info("deleting item {}", itemId);
//            gitlabClient.deleteProject(project.getId());
//        } else {
//            log.debug("skip deleting item {}", itemId);
//        }

        return result;
    }

//    private void logItemsToKeep() {
//        if (log.isInfoEnabled()) {
//            log.info("Items to keep: {}", String.join(",", appProps.getDoNotDeleteItems()));
//        }
//    }

    private List<ItemName> getItems() {
        log.info("getting items to delete");
        final List<ItemName> projects = util.getProjects();
        if (isNotEmpty(projects)) {
            if (appProps.getIncludedItems().size() > 0) {
                return filterProjects(projects);
            } else {
                return projects;
            }
        } else {
            return emptyList();
        }
    }

    private List<ItemName> filterProjects(List<ItemName> projects) {
        log.debug("Filtering items");
        final Predicate<ItemName> shouldIncludeItem = project -> util.includeItem(project);

        return projects.stream().filter(shouldIncludeItem).collect(toList());
    }

//    private List<ItemInfo> loadItemsAsync(final List<ItemName> projects) {
//        log.debug("Loading items async");
//
//        final Predicate<ItemName> shouldIncludeItem = project -> util.includeItem(project);
//
//        final List<CompletableFuture<ItemInfo>> futuresList = projects.stream().filter(shouldIncludeItem).map(
//                itemName -> asyncService.loadItemAsync(itemName)).collect(toList());
//
//        final List<ItemInfo> results = futuresList.stream().map(CompletableFuture::join).collect(Collectors.toList());
//        return results;
//    }

    private void logReport(final Path file) {
        try {
            final String reportString = FileUtils.readFileContents(file.toFile());
            log.info("\r\n{}", reportString);
        } catch (IOException e) {
            log.warn("unable to log report file {} - ", file, ExceptionUtils.getRootCauseMessage(e));
        }
    }

}
