package org.opentestsystem.ap.migration.service;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreItemManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.ResourceNotFoundException;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.saaif.mapper.model.ImportItem;
import org.opentestsystem.ap.common.saaif.mapper.model.SkipMigration;
import org.opentestsystem.ap.common.saaif.mapper.util.MigrationFileUtil;
import org.opentestsystem.ap.common.security.model.ItemBankSystemUser;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.migration.Migration;
import org.opentestsystem.ap.migration.model.FailedMigrationException;
import org.opentestsystem.ap.migration.model.MigrationContext;
import org.opentestsystem.ap.migration.model.MigrationItemResult;
import org.opentestsystem.ap.migration.model.MigrationResult;
import org.opentestsystem.ap.migration.util.SpringUtil;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.io.IOException;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import static java.lang.String.format;
import static org.apache.commons.collections4.ListUtils.emptyIfNull;
import static org.opentestsystem.ap.common.model.ModelConstants.BranchNames.BRANCH_MASTER;

@Slf4j
@Component
public class MigrationSetHandler {

    private final ApplicationProperties applicationProperties;

    private final DataStoreDataManager dataManager;

    private final SpringUtil springUtil;

    private final MigrationFileUtil migrationFileUtil;

    private final DataStoreUtility dataStoreUtility;

    private final DataStoreAttachmentManager attachmentManager;

    private final DataStoreItemManager dataStoreItemManager;

    public MigrationSetHandler(final ApplicationProperties applicationProperties,
                               final DataStoreDataManager dataManager,
                               final SpringUtil springUtil,
                               final MigrationFileUtil migrationFileUtil,
                               final DataStoreUtility dataStoreUtility,
                               final DataStoreAttachmentManager attachmentManager,
                               final DataStoreItemManager dataStoreItemManager) {
        this.applicationProperties = applicationProperties;
        this.dataManager = dataManager;
        this.springUtil = springUtil;
        this.migrationFileUtil = migrationFileUtil;
        this.dataStoreUtility = dataStoreUtility;
        this.attachmentManager = attachmentManager;
        this.dataStoreItemManager = dataStoreItemManager;
    }

    /**
     * This is where an item is migrated within a transaction.  If there is a failure when migrating the item for this
     * set it should halt the migrations for the item.  The item migration handler will not call any more migration sets
     * for the item and instead will move to the next item.
     * <p>
     * Completion of this method means the item migration was successfully committed to the data store and event
     * messages were fired, events like regenerating the SAAIF in the item bank.
     * </p>
     *
     * @param entity       The entity to migrate
     * @param migrationSet The migration set
     * @param result       The result of the migration
     * @return The migrated master record, it represents the final migrated state for the item.
     */
    @Transactional
    public ItemEntity migrateItem(ItemEntity entity,
                                  ApplicationProperties.MigrationSet migrationSet,
                                  MigrationItemResult result) {

        // must lock entity before updating the item,
        this.dataManager.lockMaster(entity.getItemId());

        // consider moving the transaction to the item handler and locking there
        // passing the set in means there is potential for a save by a TIMS user to the item to happen
        // before processing begins meaning we are migrating a stale item instance,
        // usually not a problem as migrations are run with no one able to access the system
        ItemEntity migratedEntity = findMaster(entity.getItemId());

        String migrationSetVersion = migrationSet.getMigrationSetKey();

        List<ApplicationProperties.MigrationDefinition> migrations = emptyIfNull(
                migrationSet.getMigrationDefinitions());

        StringBuilder commitMessage = new StringBuilder("Migrated item to ").append(migrationSet.getMigrationSetKey()).append("\n");

        boolean containsSuccessfulMigration = false;

        Optional<ImportItem> maybeImportItem = getImportItem(migratedEntity, migrations);
        try {
            // loop over the migrations defined on the set
            for (ApplicationProperties.MigrationDefinition migrationDefinition : migrations) {
                try {
                    // get migration bean
                    Migration migration = this.getDataStoreMigration(migrationDefinition.getMigrationName());

                    // run the migration on the item
                    final MigrationContext migrationContext = new MigrationContext(migrationSetVersion, migrationDefinition, maybeImportItem.orElse(null));
                    MigrationResult migrationResult = migration.migrate(migratedEntity, migrationContext, result);
                    migratedEntity = migrationResult.getMigratedEntity();

                    if (migrationResult.isItemMigrated()) {
                        // add the migration to the commit message
                        commitMessage.append(migrationDefinition.getMigrationDescription()).append("\n");

                        //If the master entity was migrated need to indicate a successful migration
                        if (!containsSuccessfulMigration) {
                            containsSuccessfulMigration = true;
                        }
                    }

                    log.info("completed | item {} | migrated master {} | set key {} | migration {} | {}",
                            migratedEntity.getItemId(),
                            migrationResult.isItemMigrated(),
                            migrationSetVersion,
                            migrationDefinition.getMigrationName(),
                            migrationDefinition.getMigrationDescription());
                } catch (SkipMigration e) {
                    // skipping the migration for the item in this set
                    log.info(e.getMessage());
                } catch (FailedMigrationException e) {
                    // failed migration exception is runtime exception causing transaction to rollback
                    // not logged as the item migration handler logs this
                    log.error("Failed Migration Exception thrown in migrationDefinition " + migrationDefinition.getMigrationName(), e);
                    throw e;
                } catch (Exception e) {
                    // throw runtime exception to cause transaction to rollback
                    // any changes are roll backed, specifically database changes
                    // not logged as the item migration handler logs this
                    log.error("Unexpected Exception thrown in migrationDefinition " + migrationDefinition.getMigrationName(), e);
                    throw new SystemException(
                            format(
                                    "unexpected (rolling back set changes) | item %s | set key %s | migration %s | %s",
                                    migratedEntity.getItemId(),
                                    migrationSetVersion,
                                    migrationDefinition.getMigrationName(),
                                    e.getMessage()
                            ), e);
                }
            }
        } finally {
            if (maybeImportItem.isPresent()) {
                try {
                    FileUtils.deleteDirectory(maybeImportItem.get().getExpandedImportItemPath().toFile());
                } catch (IOException e) {
                    log.error("Could not delete import file", e);
                }
            }
        }

        //Save the item with the updated item version
        if (!containsSuccessfulMigration) {
            ItemEntity entityClone = this.cloneEntity(migratedEntity, migrationSetVersion);

            migratedEntity = this.dataStoreItemManager.saveMigratedItem(systemUser(), entityClone, true, commitMessage.toString());

        } else {
            ItemEntity entityClone = this.cloneEntity(migratedEntity, migrationSetVersion);

            // create a new attachments zip version in S3
            String attachmentsVersionId = this.attachmentManager.commitAttachments(
                    entityClone.getItemJson(), BRANCH_MASTER);

            // set the attachments version on the item
            entityClone.getItemJson().getServerManaged().setTimsAttachmentsVersionId(attachmentsVersionId);

            // save item to the database
            migratedEntity = this.dataStoreItemManager.saveMigratedItem(systemUser(), entityClone, false, commitMessage.toString());
        }

        return migratedEntity;
    }

    private Optional<ImportItem> getImportItem(ItemEntity itemEntity, List<ApplicationProperties.MigrationDefinition> migrations) {
        boolean migrationRequiresImportData = migrations.stream().anyMatch(ApplicationProperties.MigrationDefinition::isRequiresImportFiles);

        if (!migrationRequiresImportData) {
            return Optional.empty();
        }

        Optional<ImportItem> maybeImportItem = migrationFileUtil.getImportItem(itemEntity);

        if (!maybeImportItem.isPresent() && itemEntity.getItemJson().isImported()) {
            throw new SystemException("Import files not found for item " + itemEntity.getItemId());
        }

        return maybeImportItem;
    }

    /**
     * Helper method giving a quick reference to the system user.
     *
     * @return The system user configured in application properties.
     */
    protected ItemBankSystemUser systemUser() {
        return this.applicationProperties.getSystemUser();
    }

    public Migration getDataStoreMigration(final String migrationName) {
        final Migration migration = springUtil.getDataStoreMigration(migrationName);
        if (migration == null) {
            throw new SystemException("No migration exists for data store migration " + migrationName);
        }
        return migration;
    }

    private ItemEntity findMaster(String itemId) {
        ItemEntity entityMaster = this.dataManager.findLastMasterCommit(itemId);
        if (Objects.isNull(entityMaster)) {
            entityMaster = this.dataManager.findLastMaster(itemId);
        }
        this.checkResourceNotFound(entityMaster, itemId);
        return entityMaster;
    }

    private void checkResourceNotFound(ItemEntity entity, String itemId) {
        if (Objects.isNull(entity)) {
            throw new ResourceNotFoundException("Item " + itemId + " does not exist");
        }
    }

    private ItemEntity cloneEntity(ItemEntity sourceEntity, String version) {
        ItemBankSystemUser systemUser = systemUser();

        Item itemClone = this.dataStoreUtility.cloneItemJson(sourceEntity.getItemJson());
        itemClone.setVersion(version);

        ItemEntity entityClone = sourceEntity.cloneFull(systemUser.getUserName());
        entityClone.setItemJson(itemClone);

        if (Objects.nonNull(sourceEntity.getCreatedDate())) {
            entityClone.setCreatedDate(sourceEntity.getCreatedDate().plusMillis(100L));
        }

        return entityClone;
    }
}
