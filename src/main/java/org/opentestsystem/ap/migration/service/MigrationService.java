package org.opentestsystem.ap.migration.service;

import java.io.IOException;
import java.nio.file.Path;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.gitlab4j.api.utils.FileUtils;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.model.ItemName;
import org.opentestsystem.ap.migration.config.AppProps;
import org.opentestsystem.ap.migration.config.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.handler.ItemMigrationHandler;
import org.opentestsystem.ap.migration.model.ItemInfo;
import org.opentestsystem.ap.migration.model.ItemResult;
import org.opentestsystem.ap.migration.model.MigrationReport;
import org.opentestsystem.ap.migration.repository.ReportRepository;
import org.opentestsystem.ap.migration.util.Util;
import org.springframework.stereotype.Component;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;
import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;

@Slf4j
@Component
public class MigrationService {

    private final Util util;

    private final AppProps appProps;

    private final GitlabClient gitlabClient;

    private final ItemMigrationHandler itemMigrationHandler;

    private final ReportRepository reportRepository;

    private final AsyncService asyncService;

    public MigrationService(final Util util,
                            final ApplicationDependencyProvider dependencyProvider,
                            final ItemMigrationHandler itemMigrationHandler,
                            final ReportRepository reportRepository,
                            final AsyncService asyncService) {
        this.util = util;
        this.appProps = dependencyProvider.getAppProps();
        this.gitlabClient = dependencyProvider.getGitlabClient();
        this.reportRepository = reportRepository;
        this.itemMigrationHandler = itemMigrationHandler;
        this.asyncService = asyncService;
    }

    /**
     * Executes the migration process against an itembank.
     */
    public void migrate() {
        // are migrations enabled
        if (appProps.isMigrationsEnabled()) {
            log.info("migrations are enabled");

            final MigrationReport migrationReport = new MigrationReport();
            migrationReport.startMigrationTimer();

            final List<ItemInfo> itemsToMigrate = getItems();
            migrationReport.setItemsToProcessCount(itemsToMigrate.size());

            final List<ItemResult> itemResults = migrateItems(itemsToMigrate);
            migrationReport.setItemResults(itemResults);

            migrationReport.stopMigrationTimer();

            final Path reportFile = reportRepository.publishReport(migrationReport);
            logReport(reportFile);

            reportRepository.deleteLocalReportRepository();

            log.info("migration complete");
        } else {
            log.info("migration is disabled");
        }
    }

    private void logReport(final Path file) {
        try {
            final String reportString = FileUtils.readFileContents(file.toFile());
            log.info("{}", reportString);
        } catch (IOException e) {
            log.warn("unable to log report file {} - ", file, ExceptionUtils.getRootCauseMessage(e));
        }
    }

    private List<ItemResult> migrateItems(final List<ItemInfo> items) {
        log.info("items to migrate {}", items.size());

        final List<CompletableFuture<ItemResult>> futuresList = items.stream().map(itemInfo ->
                asyncService.migrateItemsAsync(itemInfo)).collect(toList());

        final List<ItemResult> results = futuresList.stream().map(CompletableFuture::join).collect(Collectors.toList());

        return results;
    }

    /**
     * Look up items in the itembank along with their associated branches.
     *
     * @return A list of all the items in the itembank.
     */
    private List<ItemInfo> getItems() {
        log.info("getting items to migrate");
        final List<ItemName> projects = util.getProjects();
        return isNotEmpty(projects) ? loadItemsAsync(projects) : emptyList();
    }

    private List<ItemInfo> loadItemsAsync(final List<ItemName> projects) {
        log.debug("Loading items async");

        final Predicate<ItemName> shouldIncludeItem = project -> util.includeItem(project);

        final List<CompletableFuture<ItemInfo>> futuresList = projects.stream().filter(shouldIncludeItem).map(id ->
                asyncService.loadItemAsync(id)).collect(toList());

        final List<ItemInfo> results = futuresList.stream().map(CompletableFuture::join).collect(Collectors.toList());
        return results;
    }
}
