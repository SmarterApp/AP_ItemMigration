package org.opentestsystem.ap.migration.service;

import lombok.extern.slf4j.Slf4j;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.model.ItemName;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.config.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.handler.ItemMigrationHandler;
import org.opentestsystem.ap.migration.model.ItemInfo;
import org.opentestsystem.ap.migration.model.ItemResult;
import org.opentestsystem.ap.migration.model.MigrationReport;
import org.opentestsystem.ap.migration.repository.ReportRepository;
import org.opentestsystem.ap.migration.util.ApplicationUtility;
import org.springframework.stereotype.Component;

import java.nio.file.Path;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;
import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;

@Slf4j
@Component
public class MigrationService {

    private final ApplicationUtility applicationUtility;

    private final ApplicationProperties applicationProperties;

    private final GitlabClient gitlabClient;

    private final ItemMigrationHandler itemMigrationHandler;

    private final ReportRepository reportRepository;

    private final AsyncService asyncService;

    public MigrationService(final ApplicationUtility applicationUtility,
                            final ApplicationDependencyProvider dependencyProvider,
                            final ItemMigrationHandler itemMigrationHandler,
                            final ReportRepository reportRepository,
                            final AsyncService asyncService) {
        this.applicationUtility = applicationUtility;
        this.applicationProperties = dependencyProvider.getApplicationProperties();
        this.gitlabClient = dependencyProvider.getGitlabClient();
        this.reportRepository = reportRepository;
        this.itemMigrationHandler = itemMigrationHandler;
        this.asyncService = asyncService;
    }

    /**
     * Executes the migration process against an itembank.
     */
    public void migrate() {
        // are migrations enabled
        if (applicationProperties.isMigrationsEnabled()) {
            log.info("migrations are enabled");

            final MigrationReport migrationReport = new MigrationReport();
            migrationReport.startMigrationTimer();

            final List<ItemInfo> itemsToMigrate = getItems();
            migrationReport.setItemsToProcessCount(itemsToMigrate.size());

            final List<ItemResult> itemResults = migrateItems(itemsToMigrate);
            migrationReport.setItemResults(itemResults);

            migrationReport.stopMigrationTimer();

            if (applicationProperties.isPublishReportEnabled()) {
                final Path reportFile = reportRepository.publishReport(migrationReport);
//                logReport(reportFile);
                reportRepository.deleteLocalReportRepository();
            } else {
                String reportString = reportRepository.generateReport(migrationReport);
                log.info("\r\n{}", reportString);
            }

            log.info("migration complete");
        } else {
            log.info("migration is disabled");
        }
    }

    private List<ItemResult> migrateItems(final List<ItemInfo> items) {
        log.info("items to migrateAndSave {}", items.size());

        final List<CompletableFuture<ItemResult>> futuresList = items.stream().map(itemInfo ->
                asyncService.migrateItemsAsync(itemInfo)).collect(toList());

        final List<ItemResult> results = futuresList.stream().map(CompletableFuture::join).collect(Collectors.toList());

        return results;
    }

    /**
     * Look up items in the itembank along with their associated branches.
     *
     * @return A list of all the items in the itembank.
     */
    private List<ItemInfo> getItems() {
        log.info("getting items to migrateAndSave");
        final List<ItemName> projects = applicationUtility.getProjects();
        return isNotEmpty(projects) ? loadItemsAsync(projects) : emptyList();
    }

    private List<ItemInfo> loadItemsAsync(final List<ItemName> projects) {
        log.debug("Loading items async");

        final Predicate<ItemName> shouldIncludeItem = project -> applicationUtility.includeItem(project);

        final List<CompletableFuture<ItemInfo>> futuresList = projects.stream().filter(shouldIncludeItem).map(
                itemName -> asyncService.loadItemAsync(itemName)).collect(toList());

        final List<ItemInfo> results = futuresList.stream().map(CompletableFuture::join).collect(Collectors.toList());
        return results;
    }


    //    private void logReport(final Path file) {
    //        try {
    //            final String reportString = FileUtils.readFileContents(file.toFile());
    //            log.info("\r\n{}", reportString);
    //        } catch (IOException e) {
    //            log.warn("unable to log report file {} - ", file, ExceptionUtils.getRootCauseMessage(e));
    //        }
    //    }
}
