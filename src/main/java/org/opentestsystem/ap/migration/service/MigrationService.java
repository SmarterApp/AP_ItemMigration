package org.opentestsystem.ap.migration.service;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.MigrationItemResult;
import org.opentestsystem.ap.migration.repository.ItemVersionRepository;

import java.time.Duration;
import java.time.Instant;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

import static java.util.stream.Collectors.toList;

@Slf4j
public class MigrationService {

    private final ApplicationProperties applicationProperties;

    private final ApplicationProperties.DataStoreProperties dataStoreMigrations;

    private final DataStoreDataManager dataManager;

    private final AsyncService asyncService;

    private final ItemVersionRepository itemVersionRepository;

    public MigrationService(ApplicationProperties applicationProperties,
                            DataStoreDataManager dataManager,
                            AsyncService asyncService, final ItemVersionRepository itemVersionRepository) {
        this.applicationProperties = applicationProperties;
        this.dataStoreMigrations = applicationProperties.getDataStoreMigrations();
        this.dataManager = dataManager;
        this.asyncService = asyncService;
        this.itemVersionRepository = itemVersionRepository;
    }

    /**
     * Executes the migration process against an itembank.
     */
    public void migrate() {
        if (dataStoreMigrations.isEnabled()) {
            log.info("data store migrations are enabled");
            validateMigrationSets();
            List<String> itemIds = this.getItemsToMigrate();

            List<CompletableFuture<MigrationItemResult>> futuresList = itemIds.stream()
                    .map(asyncService::migrateDataStoreItemsAsync)
                    .collect(toList());

            futuresList.stream().map(CompletableFuture::join).collect(Collectors.toList());

            log.info("migration complete");
        } else {
            log.info("migration is disabled");
        }
    }

    // ------------------------------------------------------------------------

    private List<String> getItemsToMigrate() {
        List<String> itemIds = this.applicationProperties.getIncludedItems();
        return CollectionUtils.isEmpty(itemIds) ? this.dataManager.findActiveItemIds() : itemIds;
    }

    /**
     * This is a check to make sure the application.properties is configured properly.  There must be a migration set
     * defined in application.yml for every different item.version in the TIMS database.
     */
    private void validateMigrationSets() {
        log.info("Verifying the migration sets are configured properly");
        Instant start = Instant.now();
        List<String> itemVersions = itemVersionRepository.getItemVersions().stream().filter(StringUtils::isNotBlank).collect(toList());
        log.info("Finding the item versions took {} ms", Duration.between(start, Instant.now()).toMillis());

        Set<String> migrationSets = dataStoreMigrations.getMigrationSets().stream().map(ApplicationProperties.MigrationSet::getMigrationSetKey).collect(Collectors.toSet());

        Set<String> versionNotInSets = itemVersions.stream().filter(s -> !migrationSets.contains(s)).collect(Collectors.toSet());

        if (!versionNotInSets.isEmpty()) {
            throw new SystemException("Invalid configuration:  Items have versions without configured migration set " + String.join(",", versionNotInSets));
        }
    }
}
