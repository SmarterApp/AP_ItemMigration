package org.opentestsystem.ap.migration.service;

import java.io.IOException;
import java.nio.file.Path;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import java.util.function.Predicate;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.gitlab4j.api.models.Branch;
import org.gitlab4j.api.models.Project;
import org.gitlab4j.api.utils.FileUtils;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemName;
import org.opentestsystem.ap.migration.config.AppProps;
import org.opentestsystem.ap.migration.config.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.handler.ItemMigrationHandler;
import org.opentestsystem.ap.migration.model.BranchInfo;
import org.opentestsystem.ap.migration.model.ItemInfo;
import org.opentestsystem.ap.migration.model.ItemResult;
import org.opentestsystem.ap.migration.model.MigrationReport;
import org.opentestsystem.ap.migration.repository.ReportRepository;
import org.opentestsystem.ap.migration.util.Util;
import org.springframework.stereotype.Component;

import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;
import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;
import static org.apache.commons.collections4.ListUtils.emptyIfNull;
import static org.apache.commons.lang3.StringUtils.EMPTY;

@Slf4j
@Component
public class MigrationService {

    private final Util util;

    private final AppProps appProps;

    private final GitlabClient gitlabClient;

    private final ItemMigrationHandler itemMigrationHandler;

    private final ReportRepository reportRepository;

    public MigrationService(final Util util,
                            final ApplicationDependencyProvider dependencyProvider,
                            final ItemMigrationHandler itemMigrationHandler,
                            final ReportRepository reportRepository) {
        this.util = util;
        this.appProps = dependencyProvider.getAppProps();
        this.gitlabClient = dependencyProvider.getGitlabClient();
        this.reportRepository = reportRepository;
        this.itemMigrationHandler = itemMigrationHandler;
    }

    /**
     * Executes the migration process against an itembank.
     */
    public void migrate() {
        // are migrations enabled
        if (appProps.isMigrationsEnabled()) {
            log.info("migrations are enabled");

            final MigrationReport migrationReport = new MigrationReport();
            migrationReport.startMigrationTimer();

            final List<ItemInfo> itemsToMigrate = getItems();
            migrationReport.setItemsToProcessCount(itemsToMigrate.size());

            final List<ItemResult> itemResults = migrateItems(itemsToMigrate);
            migrationReport.setItemResults(itemResults);

            migrationReport.stopMigrationTimer();

            final Path reportFile = reportRepository.publishReport(migrationReport);
            logReport(reportFile);

            reportRepository.deleteLocalReportRepository();

            log.info("migration complete");
        } else {
            log.info("migration is disabled");
        }
    }

    private void logReport(final Path file) {
        try {
            final String reportString = FileUtils.readFileContents(file.toFile());
            log.info("{}", reportString);
        } catch (IOException e) {
            log.warn("unable to log report file {} - ", file, ExceptionUtils.getRootCauseMessage(e));
        }
    }

    private List<ItemResult> migrateItems(final List<ItemInfo> items) {
        log.info("items to migrate {}", items.size());
        return  items.stream().map(itemMigrationHandler::migrateItem).collect(toList());
    }

    /**
     * Look up items in the itembank along with their associated branches.
     *
     * @return A list of all the items in the itembank.
     */
    private List<ItemInfo> getItems() {
        log.info("getting items to migrate");
        final List<ItemName> projects = util.getProjects();
        return isNotEmpty(projects) ? mapToItemInfo(projects) : emptyList();
    }

    /**
     * Maps a list of {@link Project} instances to a list of {@link ItemInfo} instances.
     *
     * @param projects The projects.
     * @return A list of
     */
    private List<ItemInfo> mapToItemInfo(final List<ItemName> projects) {
        log.debug("mapping project to item info, number of items is {}", emptyIfNull(projects).size());
        final Predicate<ItemName> shouldIncludeItem = project -> util.includeItem(project);
        return emptyIfNull(projects).stream().filter(shouldIncludeItem).map(toItemInfo()).collect(toList());
    }


    private Function<ItemName, ItemInfo> toItemInfo() {
        return project -> {
            log.info("item {}", project.getName());
            final List<Branch> branches = gitlabClient.lookupAllBranches(project.getId());
            final List<BranchInfo> branchNames = branches.stream().map(toBranchInfo(project)).collect(toList());
            return new ItemInfo(project.getId(), project.getName(), branchNames);
        };
    }

    private Function<Branch, BranchInfo> toBranchInfo(final ItemName project) {
        return branch -> {
            log.info("\tbranch {}", branch.getName());
            final Item item = util.lookupItemRemotely(project.getName(), branch.getName());
            final String itemVersion = Objects.isNull(item) ? EMPTY : item.getVersion();
            final BranchInfo branchInfo = new BranchInfo(project.getName(), branch.getName(), itemVersion);
            return branchInfo;
        };
    }
}
