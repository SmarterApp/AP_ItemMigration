package org.opentestsystem.ap.migration.service;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.ToString;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.client.GitClient;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.gitlab.GitLabItemManager;
import org.opentestsystem.ap.common.gitlab.GitLabSyncManager;
import org.opentestsystem.ap.common.management.ItemManager;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemBankSystemUser;
import org.opentestsystem.ap.common.repository.ItemRepository;
import org.opentestsystem.ap.common.repository.RepositoryUtil;
import org.opentestsystem.ap.common.util.ZipUtil;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.util.GitLabApiClient;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * The copy service pulls data from a source item bank.  It pulls the latest master branch commit on the item in the
 * source repo.  The target data is deleted prior to copying the source data.  The target data is deleted from GitLab
 * and from the database.  Nothing is deleted from S3.
 */
@Slf4j
@Component
public class CopyService {

    private final ApplicationProperties applicationProperties;

    private final ItemBankProperties itemBankProperties;

    private final ItemRepository itemRepository;

    private final ItemManager itemManager;

    private final GitLabApiClient gitLabApiClient;

    private final GitLabItemManager gitLabItemManager;

    private final AppAssembler appAssembler;

    private final GitLabSyncManager gitLabSyncManager;

    private final Path localBaseDir;

    public CopyService(ApplicationDependencyProvider dependencyProvider,
                       ItemManager itemManager,
                       GitLabApiClient gitLabApiClient,
                       GitLabItemManager gitLabItemManager) {
        this.applicationProperties = dependencyProvider.getApplicationProperties();
        this.itemBankProperties = dependencyProvider.getItemBankProperties();
        this.itemRepository = dependencyProvider.getItemRepository();
        this.appAssembler = dependencyProvider.getAppAssembler();
        this.gitLabSyncManager = dependencyProvider.getItemBankSyncManager();

        this.itemManager = itemManager;
        this.gitLabApiClient = gitLabApiClient;
        this.gitLabItemManager = gitLabItemManager;

        this.localBaseDir = Paths.get(itemBankProperties.getLocalBaseDir());
    }

    /**
     * Executes the migration process against an itembank.
     */
    public void copy() {
        if (applicationProperties.isCopySourceToTargetEnabled()) {
            log.info("item copy service enabled");

            final List<String> includedItems = applicationProperties.getIncludedItems();

            final List<CopyContext> results = includedItems
                .stream()
                .map(deleteTargetItem())
                .map(downloadSourceItemArchive())
                .map(unzipSourceItemArchive())
                .map(createTargetItemInGitLab())
                .map(addSoureDataToTargetGitLab())
                .map(syncTargetGitLabToTargetDataStore())
                .map(completeCopy())
                .collect(Collectors.toList());

            log.info("Results of copying from {} to {} group {}",
                this.applicationProperties.getSourceBank().getHost(),
                this.itemBankProperties.getHost(),
                this.itemBankProperties.getGroup());
            results.forEach(r -> log.info("\t{}", r.getMessage()));
            log.info("copy complete");

        } else {
            log.info("item copy service is disabled");
        }
    }

    private Function<String, CopyContext> deleteTargetItem() {
        return itemId -> {
            CopyContext copyContext = new CopyContext(itemId);
            try {
                this.itemManager.deleteItem(itemId, Boolean.TRUE);
                TimeUnit.SECONDS.sleep(4L);
            } catch (InterruptedException e) {
                log.warn("something happened waiting for the GitLab project delete to fully resolve", e);
            } catch (Exception e) {
                log.error(e.getMessage(), e);
                copyContext.setFailedMessage(e.getMessage());
            }
            return copyContext;
        };
    }

    private Function<CopyContext, CopyContext> downloadSourceItemArchive() {
        return copyContext -> {
            if (copyContext.isNotFailed()) {
                try {
                    final Path archiveFile = this.gitLabApiClient.downloadItem(copyContext.getItemId());
                    final String legacyId = FilenameUtils.removeExtension(archiveFile.toFile().getName());
                    copyContext.setArchiveFile(archiveFile).setLegacyId(legacyId);
                } catch (Exception e) {
                    log.error(e.getMessage(), e);
                    copyContext.setFailedMessage(e.getMessage());
                }
            }
            return copyContext;
        };
    }

    private Function<CopyContext, CopyContext> unzipSourceItemArchive() {
        return copyContext -> {
            if (copyContext.isNotFailed()) {
                try {
                    copyContext.setSourceRepo(this.localBaseDir.resolve(copyContext.getLegacyId()));

                    RepositoryUtil.deleteDirectory(copyContext.getSourceRepo());

                    // the zip files contain a directory so all contents unzip into one automatically
                    // for example: //localBaseDir/item-200-123793-master-b9a0bc1890cddd14339b56f79673a6fd76e34a2e
                    ZipUtil.unzip(copyContext.getArchiveFile(), this.localBaseDir);

                    Files.list(this.localBaseDir)
                        .map(Path::toFile)
                        .filter(File::isDirectory)
                        .filter(directory -> directory.getName().startsWith(copyContext.getLegacyId()))
                        .forEach(directory -> directory.renameTo(copyContext.getSourceRepo().toFile()));
                } catch (Exception e) {
                    log.error(e.getMessage(), e);
                    copyContext.setFailedMessage(e.getMessage());
                }
            }
            return copyContext;
        };
    }

    private Function<CopyContext, CopyContext> createTargetItemInGitLab() {
        return copyContext -> {
            if (copyContext.isNotFailed()) {
                try {
                    final Item item = this.appAssembler.getJsonModelAssembler()
                        .readItem(copyContext.getSourceRepo().resolve("item.json"));
                    this.gitLabItemManager.createItem(systemUser(), item, "Creating item using copy service");
                } catch (Exception e) {
                    log.error(e.getMessage(), e);
                    copyContext.setFailedMessage(e.getMessage());
                }
            }
            return copyContext;
        };
    }

    private Function<CopyContext, CopyContext> addSoureDataToTargetGitLab() {
        return copyContext -> {
            if (copyContext.isNotFailed()) {
                try {
                    final GitClient gitClient = this.itemRepository
                        .cloneRemoteRepository(systemUser(), copyContext.getItemId(), copyContext.getLegacyId());

                    try {
                        FileUtils.copyDirectory(
                            copyContext.getSourceRepo().toFile(),
                            gitClient.getItemContext().getLocalRepositoryPath().toFile());
                    } catch (IOException e) {
                        throw new SystemException(
                            "unexpected error cloning target item " + copyContext.getItemId() + " from GitLab", e);
                    }

                    gitClient.pushAll("Adding source data to target repository");
                } catch (Exception e) {
                    log.error(e.getMessage(), e);
                    copyContext.setFailedMessage(e.getMessage());
                }
            }
            return copyContext;
        };
    }

    private Function<CopyContext, CopyContext> syncTargetGitLabToTargetDataStore() {
        return copyContext -> {
            if (copyContext.isNotFailed()) {
                try {
                    this.gitLabSyncManager
                        .syncToDataStore(systemUser(), copyContext.getItemId(), Collections.emptyList());
                } catch (Exception e) {
                    log.error(e.getMessage(), e);
                    copyContext.setFailedMessage(e.getMessage());
                }
            }
            return copyContext;
        };
    }

    private Function<CopyContext, CopyContext> completeCopy() {
        return copyContext -> {
            if (copyContext.isNotFailed()) {
                copyContext.setMessage(
                    String.format("Success: %s, %s", copyContext.getItemId(), copyContext.getLegacyId())
                );
            }
            return copyContext;
        };
    }

    private ItemBankSystemUser systemUser() {
        return this.itemBankProperties.getSystemUser();
    }

    @Getter
    @ToString
    @RequiredArgsConstructor
    public static class CopyContext {

        private final String itemId;

        private String legacyId;

        // the zip file on disk
        private Path archiveFile;

        // the path to the unzipped contents
        private Path sourceRepo;

        private String message;

        private boolean failed;

        public CopyContext setLegacyId(String legacyId) {
            this.legacyId = legacyId;
            return this;
        }

        public CopyContext setArchiveFile(Path archiveFile) {
            this.archiveFile = archiveFile;
            return this;
        }

        public CopyContext setSourceRepo(Path sourceRepo) {
            this.sourceRepo = sourceRepo;
            return this;
        }

        public CopyContext setMessage(String message) {
            this.message = message;
            return this;
        }

        public CopyContext setFailedMessage(String message) {
            this.failed = true;
            this.message = "Failed: " + message;
            return this;
        }

        public CopyContext setFailed(boolean failed) {
            this.failed = failed;
            return this;
        }

        public boolean isNotFailed() {
            return !this.failed;
        }
    }
}
