package org.opentestsystem.ap.migration.service;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.gitlab4j.api.models.Branch;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.exception.ResourceNotFoundException;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemName;
import org.opentestsystem.ap.migration.datastore.DataStoreItemMigrationHandler;
import org.opentestsystem.ap.migration.datastore.DataStoreItemResult;
import org.opentestsystem.ap.migration.handler.ItemMigrationHandler;
import org.opentestsystem.ap.migration.model.BranchInfo;
import org.opentestsystem.ap.migration.model.ItemInfo;
import org.opentestsystem.ap.migration.model.ItemResult;
import org.opentestsystem.ap.migration.util.ApplicationUtility;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;

import static java.util.stream.Collectors.toList;
import static org.opentestsystem.ap.common.itembank.ItemBankFunctions.firstOne;
import static org.opentestsystem.ap.common.repository.RepositoryUtil.branchNameToItemTransaction;

@Slf4j
@Component
public class AsyncService {

    private final ApplicationUtility applicationUtility;

    private final GitlabClient gitlabClient;

    private final ItemMigrationHandler itemMigrationHandler;

    private final DataStoreItemMigrationHandler dataStoreItemMigrationHandler;

    public AsyncService(ApplicationUtility applicationUtility,
                        GitlabClient gitlabClient,
                        ItemMigrationHandler itemMigrationHandler,
                        DataStoreItemMigrationHandler dataStoreItemMigrationHandler) {
        this.applicationUtility = applicationUtility;
        this.gitlabClient = gitlabClient;
        this.itemMigrationHandler = itemMigrationHandler;
        this.dataStoreItemMigrationHandler = dataStoreItemMigrationHandler;
    }

    @Async
    public CompletableFuture<DataStoreItemResult> migrateDataStoreItemsAsync(final String itemId) {
        return CompletableFuture.completedFuture(dataStoreItemMigrationHandler.migrate(itemId));
    }

    @Async
    public CompletableFuture<ItemResult> migrateItemsAsync(final ItemInfo itemInfo) {
        return CompletableFuture.completedFuture(itemMigrationHandler.migrateItem(itemInfo));
    }

    /**
     * Branches are ordered on the item info.  Master is first followed by edit branches unless the item is being
     * created in which case there is one branch associated with the item info and its the create branch.
     *
     * @param itemName Item data.
     * @return The item info associated with the item.
     */
    @Async
    public CompletableFuture<ItemInfo> loadItemAsync(final ItemName itemName) {
        log.info("item {}", itemName.getName());
        final List<Branch> branches = gitlabClient.lookupAllBranches(itemName.getId());

        final List<BranchInfo> branchInfoList = branches.stream().map(toBranchInfo(itemName)).collect(toList());

        final List<BranchInfo> orderedList = new ArrayList<>(branchInfoList.size());

        BranchInfo createBranch =
            branchInfoList.stream().filter(BranchInfo::isCreateBranch).collect(firstOne());

        if (Objects.nonNull(createBranch)) {
            // create implies this is the only branch and master is empty
            orderedList.add(createBranch);
        } else {
            BranchInfo masterBranch =
                branchInfoList.stream().filter(BranchInfo::isMasterBranch).collect(firstOne());

            if (Objects.nonNull(masterBranch)) {
                orderedList.add(masterBranch);
            }

            orderedList.addAll(
                branchInfoList.stream().filter(BranchInfo::isEditBranch).collect(toList())
            );
        }

        return CompletableFuture.completedFuture(new ItemInfo(itemName.getId(), itemName.getName(), orderedList));
    }

    private Function<Branch, BranchInfo> toBranchInfo(final ItemName project) {
        return branch -> {
            log.info("\tbranch {}", branch.getName());
            final BranchInfo branchInfo = new BranchInfo(project.getName(), branch.getName());
            try {
                final Item item = applicationUtility.lookupItemRemotely(project.getName(), branch.getName());
                if (Objects.isNull(item)) {
                    // master might have a null item.json if the item is being created
                    throw new ResourceNotFoundException(
                        "item.json not found, not an error if the item is being created and this is the master branch");
                }
                final String itemVersion = item.getVersion();
                // the version matches a migration key, telling us which migration last ran on the branch
                branchInfo.setItemVersion(itemVersion);
                branchInfo.setTransaction(branchNameToItemTransaction(branch.getName()));
            } catch (Exception e) {
                branchInfo.setFailedToLoad(true);
                branchInfo.setErrorMessage(ExceptionUtils.getRootCauseMessage(e));
                branchInfo.setError(e);
            }
            return branchInfo;
        };
    }
}
