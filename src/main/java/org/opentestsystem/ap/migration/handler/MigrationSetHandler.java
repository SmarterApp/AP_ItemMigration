package org.opentestsystem.ap.migration.handler;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.opentestsystem.ap.common.client.GitClient;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.migration.Migration;
import org.opentestsystem.ap.migration.migration.MigrationFactory;
import org.opentestsystem.ap.migration.model.BranchInfo;
import org.opentestsystem.ap.migration.model.ItemInfo;
import org.opentestsystem.ap.migration.model.MigrationResult;
import org.opentestsystem.ap.migration.model.MigrationSetResult;
import org.springframework.stereotype.Component;

import java.util.List;

import static org.apache.commons.collections4.ListUtils.emptyIfNull;
import static org.apache.commons.lang3.StringUtils.EMPTY;
import static org.apache.commons.lang3.StringUtils.isNotBlank;

/**
 * Migrate an item's branch against a set of migration.  Completion of the set results in a push to GitLab.  Every
 * migration in the set results in a commit.  If there are 10 migrations in the set there will be 10 commits and 1 push
 * when the set is complete.
 */
@Slf4j
@Component
public class MigrationSetHandler {

    private final MigrationFactory migrationFactory;

    public MigrationSetHandler(MigrationFactory migrationFactory) {
        this.migrationFactory = migrationFactory;
    }

    public MigrationSetResult migrateSet(final ItemInfo itemInfo,
                                         final BranchInfo branchInfo,
                                         final GitClient gitClient,
                                         final String migrationSetKey) {

        log.info("migration set {}", migrationSetKey);

        final MigrationSetResult result = new MigrationSetResult(
            itemInfo.getItemId(), branchInfo.getBranchName(), migrationSetKey);

        final List<ApplicationProperties.MigrationDefinition> migrations = emptyIfNull(migrationFactory.getMigrations(migrationSetKey));

        if (isNotBlank(migrationSetKey)) {
            for (ApplicationProperties.MigrationDefinition migrationDefinition : migrations) {
                try {
                    final Migration migration = migrationFactory.getMigration(migrationDefinition.getMigrationName());

                    final MigrationResult migrationResult = migration.migrate(
                        itemInfo, branchInfo, migrationSetKey, migrationDefinition, gitClient);

                    result.getSuccessfulMigrations().add(migrationResult);
                } catch (Exception e) {
                    result.addMigrationError(
                        migrationDefinition.getMigrationName(), ExceptionUtils.getRootCauseMessage(e));
                    // any error halts the migration process for the branch
                    break;
                }
            }
            pushMigrationSet(gitClient, result);
        }
        return result;
    }

    /**
     * All commits from the migrations run as part of this set are pushed to the remote.
     *
     * @param gitClient The git reference to the local item.
     * @param result    The result of the migration set.
     */
    private void pushMigrationSet(final GitClient gitClient, final MigrationSetResult result) {
        if (result.isSuccess()) {
            try {
                // if push fails then none of the migrations associated with the migration key succeeded
                gitClient.push();
            } catch (Exception e) {
                // committing the set of migrations failed, nothing was saved
                result.addMigrationError(EMPTY, ExceptionUtils.getRootCauseMessage(e));
            }
        }
    }
}
