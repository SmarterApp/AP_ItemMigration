package org.opentestsystem.ap.migration.datastore;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.ResourceNotFoundException;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.saaif.mapper.model.ImportItem;
import org.opentestsystem.ap.common.saaif.mapper.model.SkipMigration;
import org.opentestsystem.ap.common.saaif.mapper.util.MigrationFileUtil;
import org.opentestsystem.ap.common.security.model.ItemBankSystemUser;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.FailedMigrationException;
import org.opentestsystem.ap.migration.model.MigrationContext;
import org.opentestsystem.ap.migration.util.SpringUtil;
import org.springframework.transaction.annotation.Transactional;

import java.io.IOException;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import static java.lang.String.format;
import static org.apache.commons.collections4.ListUtils.emptyIfNull;

@Slf4j
public class DataStoreMigrationSetHandler {

    private final ApplicationProperties applicationProperties;

    private final ApplicationProperties.DataStoreProperties dataStoreMigrations;

    private final DataStoreDataManager dataManager;

    private final SpringUtil springUtil;

    private final ItemManagerEventProducer eventProducer;

    private final MigrationFileUtil migrationFileUtil;

    private final DataStoreUtility dataStoreUtility;


    public DataStoreMigrationSetHandler(ApplicationProperties applicationProperties,
                                        DataStoreDataManager dataManager,
                                        SpringUtil springUtil,
                                        ItemManagerEventProducer eventProducer,
                                        MigrationFileUtil migrationFileUtil,
                                        DataStoreUtility dataStoreUtility) {
        this.applicationProperties = applicationProperties;
        this.dataManager = dataManager;
        this.dataStoreMigrations = applicationProperties.getDataStoreMigrations();
        this.springUtil = springUtil;
        this.eventProducer = eventProducer;
        this.migrationFileUtil = migrationFileUtil;
        this.dataStoreUtility = dataStoreUtility;
    }

    /**
     * This is where an item is migrated within a transaction.  If there is a failure when migrating the item for this
     * set it should halt the migrations for the item.  The item migration handler will not call any more migration sets
     * for the item and instead will move to the next item.
     * <p>
     * Completion of this method means the item migration was successfully committed to the data store and event
     * messages were fired, events like regenerating the SAAIF in the item bank.
     * </p>
     *
     * @param entity       The entity to migrate
     * @param migrationSet The migration set
     * @param result       The result of the migration
     * @return The migrated master record, it represents the final migrated state for the item.
     */
    @Transactional
    public ItemEntity migrateItem(ItemEntity entity,
                                  ApplicationProperties.MigrationSet migrationSet,
                                  DataStoreItemResult result) {

        boolean isItemSavedToDatabase = false;

        // must lock entity before updating the item,
        this.dataManager.lockMaster(entity.getItemId());

        // consider moving the transaction to the item handler and locking there
        // passing the set in means there is potential for a save by a TIMS user to the item to happen
        // before processing begins meaning we are migrating a stale item instance,
        // usually not a problem as migrations are run with no one able to access the system
        ItemEntity migratedEntity = findMaster(entity.getItemId());

        String migrationSetVersion = migrationSet.getMigrationSetKey();

        List<ApplicationProperties.MigrationDefinition> migrations = emptyIfNull(
            migrationSet.getMigrationDefinitions());

        StringBuilder commitMessage = new StringBuilder("Migrated item to ").append(migrationSet.getMigrationSetKey()).append("\n");

        boolean containsSuccessfulMigration = false;

        Optional<ImportItem> maybeImportItem = getImportItem(migratedEntity, migrations);
        try {
            // loop over the migrations defined on the set
            for (ApplicationProperties.MigrationDefinition migrationDefinition : migrations) {
                try {
                    // get migration bean
                    DataStoreMigration migration = this.getDataStoreMigration(migrationDefinition.getMigrationName());

                    // run the migration on the item
                    final MigrationContext migrationContext = new MigrationContext(migrationSetVersion, migrationDefinition, maybeImportItem.orElse(null));
                    migratedEntity = migration.migrate(migratedEntity, migrationContext, result);

                    // once true it should stay true
                    isItemSavedToDatabase = isItemSavedToDatabase || migrationContext.isItemSavedToDatabase();

                    // add the migration to the commit message
                    commitMessage.append(migrationDefinition.getMigrationDescription()).append("\n");
                    containsSuccessfulMigration = true;

                    log.info("completed | item {} | set key {} | migration {} | {}",
                            migratedEntity.getItemId(),
                            migrationSetVersion,
                            migrationDefinition.getMigrationName(),
                            migrationDefinition.getMigrationDescription());
                } catch (SkipMigration e) {
                    // skipping the migration for the item in this set
                    log.info(e.getMessage());
                } catch (FailedMigrationException e) {
                    // failed migration exception is runtime exception causing transaction to rollback
                    // not logged as the item migration handler logs this
                    log.error("Failed Migration Exception thrown in migrationDefinition " + migrationDefinition.getMigrationName(), e);
                    throw e;
                } catch (Exception e) {
                    // throw runtime exception to cause transaction to rollback
                    // any changes are roll backed, specifically database changes
                    // not logged as the item migration handler logs this
                    log.error("Unexpected Exception thrown in migrationDefinition " + migrationDefinition.getMigrationName(), e);
                    throw new SystemException(
                            format(
                                    "unexpected (rolling back set changes) | item %s | set key %s | migration %s | %s",
                                    migratedEntity.getItemId(),
                                    migrationSetVersion,
                                    migrationDefinition.getMigrationName(),
                                    e.getMessage()
                            ), e);
                }
            }
        } finally {
            if(maybeImportItem.isPresent()) {
                try {
                    FileUtils.deleteDirectory(maybeImportItem.get().getExpandedImportItemPath().toFile());
                } catch (IOException e) {
                    log.error("Could not delete import file", e);
                }
            }
        }

        // we need to record the version on the item and save it to the database, if none of the migrations
        // in the set save the item to the database this is where we account for that
        if (!isItemSavedToDatabase) {
            ItemEntity entityClone = this.cloneEntity(migratedEntity, migrationSetVersion);
            migratedEntity = this.dataManager.insertItem(entityClone);
        }

        if (containsSuccessfulMigration) {
            this.broadcastMigration(migratedEntity, commitMessage.toString());
        }

        return migratedEntity;
    }

    private Optional<ImportItem> getImportItem(ItemEntity itemEntity, List<ApplicationProperties.MigrationDefinition> migrations) {
        boolean migrationRequiresImportData = migrations.stream().anyMatch(ApplicationProperties.MigrationDefinition::isRequiresImportFiles);

        if(!migrationRequiresImportData) {
            return Optional.empty();
        }

        Optional<ImportItem> maybeImportItem = migrationFileUtil.getImportItem(itemEntity);

        if (!maybeImportItem.isPresent() && itemEntity.getItemJson().isImported()) {
            throw new SystemException("Import files not found for item " + itemEntity.getItemId());
        }

        return maybeImportItem;
    }
                                                   /**
     * When migrating using the data store only the master branch needs pushed downstream (e.g into the item bank). If
     * the master branch needs pushed downstream this is what does it.  It puts a commit event on the sync queue.
     *
     * @param entity        The entity record to push downstream.
     * @param commitMessage Message to be used on the items commit history.
     */
    private void broadcastMigration(ItemEntity entity,
                                    String commitMessage) {
        if (entity.isMaster()) {
            this.eventProducer.
                sendCommitEvent(systemUser(), entity, entity, commitMessage);
        }
    }

    /**
     * Helper method giving a quick reference to the system user.
     *
     * @return The system user configured in application properties.
     */
    protected ItemBankSystemUser systemUser() {
        return this.applicationProperties.getSystemUser();
    }

    public DataStoreMigration getDataStoreMigration(final String migrationName) {
        final DataStoreMigration migration = springUtil.getDataStoreMigration(migrationName);
        if (migration == null) {
            throw new SystemException("No migration exists for data store migration " + migrationName);
        }
        return migration;
    }

    private ItemEntity findMaster(String itemId) {
        ItemEntity entityMaster = this.dataManager.findLastMasterCommit(itemId);
        if (Objects.isNull(entityMaster)) {
            entityMaster = this.dataManager.findLastMaster(itemId);
        }
        this.checkResourceNotFound(entityMaster, itemId);
        return entityMaster;
    }

    private void checkResourceNotFound(ItemEntity entity, String itemId) {
        if (Objects.isNull(entity)) {
            throw new ResourceNotFoundException("Item " + itemId + " does not exist");
        }
    }

    private ItemEntity cloneEntity(ItemEntity sourceEntity, String version) {
        ItemBankSystemUser systemUser = systemUser();

        Item itemClone = this.dataStoreUtility.cloneItemJson(sourceEntity.getItemJson());
        itemClone.setVersion(version);

        ItemEntity entityClone = sourceEntity.cloneFull(systemUser.getUserName());
        entityClone.setItemJson(itemClone);

        if (Objects.nonNull(sourceEntity.getCreatedDate())) {
            entityClone.setCreatedDate(sourceEntity.getCreatedDate().plusMillis(100L));
        }

        return entityClone;
    }
}
