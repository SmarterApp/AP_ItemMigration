package org.opentestsystem.ap.migration.datastore;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.gitlab.GitLabSyncManager;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemBankSystemUser;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.contentupdater.ContentUpdateCommand;
import org.opentestsystem.ap.migration.contentupdater.ContentUpdater;
import org.opentestsystem.ap.migration.contentupdater.ContentUpdaterFactory;
import org.opentestsystem.ap.migration.model.SkipMigration;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import static java.lang.String.format;
import static org.opentestsystem.ap.common.model.ItemConstants.BranchNames.BRANCH_MASTER;

@Slf4j
public abstract class AbstractDataStoreMigration implements DataStoreMigration {

    protected final ApplicationProperties applicationProperties;

    protected final DataStoreDataManager dataManager;

    protected final ItemManagerEventProducer eventProducer;

    protected final DataStoreUtility dataStoreUtility;

    protected final DataStoreAttachmentManager dataStoreAttachmentManager;

    protected final GitLabSyncManager itemBankSyncManager;

    protected final ItemBankProperties itemBankProperties;

    /**
     * This abstract class clones the entity before calling this method.  The implementing class does not need to clone
     * the entity.  The implementing class should focus on whatever changes it need to make to the entity's item json .
     * The implementing class returns the entity with the altered json and the abstract class persists the entity to the
     * database.
     *
     * @param itemEntity The entity record to migrate.
     * @return The migrated entity record.
     */
    protected abstract ItemEntity migrateEntity(ItemEntity itemEntity);

    protected AbstractDataStoreMigration(final ApplicationDependencyProvider applicationDependencyProvider,
                                         final ApplicationProperties applicationProperties,
                                         final DataStoreDataManager dataManager,
                                         final ItemManagerEventProducer eventProducer,
                                         final DataStoreUtility dataStoreUtility,
                                         final DataStoreAttachmentManager dataStoreAttachmentManager) {
        this.applicationProperties = applicationProperties;
        this.dataManager = dataManager;
        this.eventProducer = eventProducer;
        this.dataStoreUtility = dataStoreUtility;
        this.dataStoreAttachmentManager = dataStoreAttachmentManager;
        this.itemBankSyncManager = applicationDependencyProvider.getItemBankSyncManager();
        this.itemBankProperties = applicationDependencyProvider.getItemBankProperties();
    }

    @Override
    public ItemEntity migrate(ItemEntity entityToMigrate,
                              String version,
                              ApplicationProperties.MigrationDefinition migrationDefinition,
                              DataStoreItemResult result) {
        log.info("migrate item {}, branch {}, version {} - {}",
                entityToMigrate.getItemId(),
                entityToMigrate.getBranchName(),
                version,
                migrationDefinition.getMigrationDescription());

        DataStoreItemResult.MigrationResult migrationResult = new DataStoreItemResult.MigrationResult(
                version, migrationDefinition.getMigrationName());

        result.addMigrationResult(migrationResult);

        // this is intended to be the master branch, not required but intended, the idea being always migrate the
        // master branch and push it down stream, there is no need to push non-master branch entities down stream
        ItemEntity migratedEntity = this.migrate(
                entityToMigrate,
                version,
                migrationDefinition, migrationResult,
                true);

        this.migrateBranches(migratedEntity.getItemId(), version, migrationDefinition, migrationResult);

        return migratedEntity;
    }

    /**
     * Runs the migration on the item, but only for branches and not for the master branch.  The master branch is
     * handled in the public migrate as it is the always migrated where the other branches are optional and depend on
     * the migration.
     *
     * @param itemId              The item ID
     * @param version             The version the item is being migrated to
     * @param migrationDefinition The migration to apply to the item.
     * @param migrationResult     The result of the migration.
     * @return The persisted entities representing the branches migrated.
     */
    private List<ItemEntity> migrateBranches(String itemId,
                                             String version,
                                             ApplicationProperties.MigrationDefinition migrationDefinition,
                                             DataStoreItemResult.MigrationResult migrationResult) {
        if (migrationDefinition.isMigrateBranches()) {
            return this.findBranches(itemId).stream().map(entity ->
                    this.migrate(entity, version, migrationDefinition, migrationResult, false))
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());
        }
        return Collections.emptyList();
    }

    /**
     * Migrates the entity for the given migration.
     *
     * @param entity              The entity to migrate
     * @param version             The version to set the entity's item json to
     * @param migrationDefinition The migration to run
     * @param migrationResult     The result of the migration
     * @param throwError          True if errors during migration result in throwing the error and halting the migration
     *                            for the item.
     * @return The persisted instance of the migrated entity.
     */
    protected ItemEntity migrate(ItemEntity entity,
                                 String version,
                                 ApplicationProperties.MigrationDefinition migrationDefinition,
                                 DataStoreItemResult.MigrationResult migrationResult,
                                 boolean throwError) {
        ItemEntity migratedEntity = entity;
        if (this.shouldMigrateBranch(entity)) {
            try {
                migratedEntity = this.migrateAndSave(entity, version);
                String msg = format("success - branch %s for migration %s, %s - %s",
                        entity.getBranchName(),
                        version,
                        migrationDefinition.getMigrationName(),
                        migrationDefinition.getMigrationDescription());
                migrationResult.addSuccessMessage(msg);
            } catch (SkipMigration e) {
                String msg = format("skip - branch %s for migration %s, %s - %s",
                        entity.getBranchName(),
                        version,
                        migrationDefinition.getMigrationName(),
                        ExceptionUtils.getRootCauseMessage(e));
                migrationResult.addSuccessMessage(msg);
                if (throwError) {
                    throw e;
                }
            } catch (Exception e) {
                String msg = format("error - branch %s failed for migration set %s, %s - %s",
                        entity.getBranchName(),
                        version,
                        migrationDefinition.getMigrationName(),
                        ExceptionUtils.getRootCauseMessage(e));
                migrationResult.addFailedeMessage(msg);
                if (throwError) {
                    throw new SystemException("Error migrating branch", e);
                }
            }
        }
        return migratedEntity;
    }

    /**
     * Clones the entity first then calls the migrateEntity method.  Once migrated the entity is saved to the database.
     * The implementing class of this abstract class is called here.  It is the migrateEntity method.
     *
     * @param entityToMigrate The entity to clone, migrate and persist to the database.
     * @param version         The version to set on the entity's item json.
     * @return The persisted instance of the migrated entity.
     */
    protected ItemEntity migrateAndSave(ItemEntity entityToMigrate, String version) {
        ItemEntity entityClone = this.cloneEntity(entityToMigrate, version);
        entityClone = this.migrateEntity(entityClone);
        return this.dataManager.insertItem(entityClone);
    }

    protected void syncAttachments(ItemEntity itemEntity, Path itemSyncDir) {
        itemBankSyncManager.syncAttachmentsToDataStore(itemEntity.getItemId(), BRANCH_MASTER, itemSyncDir);
    }

    /**
     * Clones the entity and its item json.  The system user is set as the updatedBy on the entity.
     *
     * @param entityToClone The entity to clone.
     * @param version       The version to set on the item json.
     * @return A clone of the entity.
     */
    protected ItemEntity cloneEntity(ItemEntity entityToClone, String version) {
        ItemBankSystemUser systemUser = systemUser();

        Item itemClone = this.dataStoreUtility.cloneItemJson(entityToClone.getItemJson());
        itemClone.setVersion(version);

        ItemEntity entityClone = entityToClone.cloneFull(systemUser.getUserName());
        entityClone.setItemJson(itemClone);

        return entityClone;
    }

    /**
     * Helper method giving a quick reference to the system user.
     *
     * @return The system user configured in application properties.
     */
    protected ItemBankSystemUser systemUser() {
        return this.applicationProperties.getSystemUser();
    }

    /**
     * Finds all branches currently being edited.  Master is excluded.
     *
     * @param itemId The item id.
     * @return The current branch edits for an item.
     */
    protected List<ItemEntity> findBranches(String itemId) {
        List<ItemEntity> entities = this.dataManager.findAllCurrentBranchEdits(itemId);
        return entities.stream().filter(ItemEntity::isNotMaster).collect(Collectors.toList());
    }

    /**
     * Concrete migrations need to override this method. The master branch is always migrated.  This method is intended
     * to allow concrete migrations to check the non-master branch before migrating it.  If a concrete migration is only
     * concerned with, for example, audio then any other non-master branch can be skipped.
     *
     * @param migratedEntity The entity holding the branch name.
     * @return True if the branch should be migrated.
     */
    protected boolean shouldMigrateBranch(ItemEntity migratedEntity) {
        return true;
    }

    /**
     * Used by migrations to create a temp directory, most often used to put attachments in where all files in the temp
     * dir are copied to S3.
     *
     * @param prefix
     * @return
     */
    protected Path createTempDir(String prefix) {
        try {
            return Files.createTempDirectory(prefix);
        } catch (IOException ioex) {
            throw new SystemException(ioex);
        }
    }

    /**
     * Calls the item-specific ContentUpdater implementation.
     *
     * @param itemEntity            ItemEntity to be updated
     * @param contentUpdateCommand  ContentUpdateCommand to run
     * @return                      Updated ItemEntity
     */
    protected ItemEntity migrateEntityContent(ContentUpdaterFactory updaterFactory,
                                              ItemEntity itemEntity,
                                              ContentUpdateCommand contentUpdateCommand) {
        ContentUpdater updater = updaterFactory.getContentUpdaterForType(itemEntity.getItemJson().getType());
        updater.updateContent(itemEntity.getItemJson(), contentUpdateCommand);
        return itemEntity;

//        Reflections reflections = new Reflections("org.opentestsystem.ap.migration.contentupdater");
//        Set<Class<?>> fixerClasses = reflections.getTypesAnnotatedWith(UpdateFor.class);
//        try {
//            for (Class<?> clazz : fixerClasses) {
//                if (itemEntity.getItemJson().getType()
//                        .equals(clazz.getAnnotation(UpdateFor.class).type())) {
//                    ContentUpdater updater = (ContentUpdater) clazz.newInstance();
//                    updater.updateContent(itemEntity.getItemJson(), contentUpdateCommand);
//                    break;
//                }
//            }
//        } catch (Exception ex) {
//            throw new RuntimeException(ex);
//        }
//        return itemEntity;

    }

}
