package org.opentestsystem.ap.migration.datastore;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemBankSystemUser;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.SkipMigration;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@Slf4j
public abstract class AbstractDataStoreMigration implements DataStoreMigration {

    protected final ApplicationProperties applicationProperties;

    protected final DataStoreDataManager dataManager;

    protected final ItemManagerEventProducer eventProducer;

    protected final DataStoreUtility dataStoreUtility;

    protected final DataStoreAttachmentManager dataStoreAttachmentManager;

    /**
     * This abstract class clones the entity before calling this method.  The implementing class does not need to clone
     * the entity.  The implementing class should focus on whatever changes it need to make to the entity's item json .
     * The implementing class returns the entity with the altered json and the abstract class persists the entity to the
     * database.
     *
     * @param itemEntity The entity record to migrate.
     * @return The migrated entity record.
     */
    protected abstract ItemEntity migrateEntity(ItemEntity itemEntity);

    protected AbstractDataStoreMigration(final ApplicationProperties applicationProperties,
                                         final DataStoreDataManager dataManager,
                                         final ItemManagerEventProducer eventProducer,
                                         final DataStoreUtility dataStoreUtility,
                                         final DataStoreAttachmentManager dataStoreAttachmentManager) {
        this.applicationProperties = applicationProperties;
        this.dataManager = dataManager;
        this.eventProducer = eventProducer;
        this.dataStoreUtility = dataStoreUtility;
        this.dataStoreAttachmentManager = dataStoreAttachmentManager;
    }

    @Override
    public ItemEntity migrate(ItemEntity entityToMigrate,
                              String version,
                              ApplicationProperties.MigrationDefinition migrationDefinition,
                              DataStoreItemResult result) {
        log.info("migrate item {}, branch {}, version {} - {}",
                entityToMigrate.getItemId(),
                entityToMigrate.getBranchName(),
                version,
                migrationDefinition.getMigrationDescription());

        DataStoreItemResult.MigrationResult migrationResult = new DataStoreItemResult.MigrationResult(
                version, migrationDefinition.getMigrationName());

        result.addMigrationResult(migrationResult);

        // this is intended to be the master branch, not required but intended, the idea being always migrate the
        // master branch and push it down stream, there is no need to push non-master branch entities down stream as
        // those should
        ItemEntity migratedEntity = this.migrate(
                entityToMigrate,
                version,
                migrationDefinition, migrationResult,
                true);

        this.broadcastMigration(migratedEntity, migrationDefinition);

        this.migrateBranches(migratedEntity.getItemId(), version, migrationDefinition, migrationResult);

        return migratedEntity;
    }

    /**
     * When migrating using the data store only the master branch needs pushed downstream (e.g into the item bank). If
     * the master branch needs pushed downstream this is what does it.  It puts a commit event on the sync queue.
     *
     * @param entity              The entity record to push downstream.
     * @param migrationDefinition The migration being pushed, this is the commit message you should see in GitLab
     *                            related to this event.
     */
    protected void broadcastMigration(ItemEntity entity,
                                      ApplicationProperties.MigrationDefinition migrationDefinition) {
        if (this.shouldBroadcast(entity, migrationDefinition)) {
            this.eventProducer.
                    sendCommitEvent(systemUser(), entity, entity, migrationDefinition.getMigrationDescription());
        }
    }

    /**
     * Runs the migration on the item, but only for branches and not for the master branch.  The master branch is
     * handled in the public migrate as it is the always migrated where the other branches are optional and depend on
     * the migration.
     *
     * @param itemId              The item ID
     * @param version             The version the item is being migrated to
     * @param migrationDefinition The migration to apply to the item.
     * @param migrationResult     The result of the migration.
     * @return The persisted entities representing the branches migrated.
     */
    protected List<ItemEntity> migrateBranches(String itemId,
                                               String version,
                                               ApplicationProperties.MigrationDefinition migrationDefinition,
                                               DataStoreItemResult.MigrationResult migrationResult) {
        if (migrationDefinition.isMigrateBranches()) {
            return this.findBranches(itemId).stream().map(entity ->
                    this.migrate(entity, version, migrationDefinition, migrationResult, false))
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());
        }
        return Collections.emptyList();
    }

    /**
     * Migrates the entity for the given migration.
     *
     * @param entity              The entity to migrate
     * @param version             The version to set the entity's item json to
     * @param migrationDefinition The migration to run
     * @param migrationResult     The result of the migration
     * @param throwError          True if errors during migration result in throwing the error and halting the migration
     *                            for the item.
     * @return The persisted instance of the migrated entity.
     */
    protected ItemEntity migrate(ItemEntity entity,
                                 String version,
                                 ApplicationProperties.MigrationDefinition migrationDefinition,
                                 DataStoreItemResult.MigrationResult migrationResult,
                                 boolean throwError) {
        ItemEntity migratedEntity = null;
        try {
            migratedEntity = this.migrateAndSave(entity, version);
            String msg = String.format("success - branch %s for migration %s, %s - %s",
                    entity.getBranchName(),
                    version,
                    migrationDefinition.getMigrationName(),
                    migrationDefinition.getMigrationDescription());
            migrationResult.addSuccessMessage(msg);
        } catch (SkipMigration e) {
            String msg = String.format("skip - branch %s for migration %s, %s - %s",
                    entity.getBranchName(),
                    version,
                    migrationDefinition.getMigrationName(),
                    ExceptionUtils.getRootCauseMessage(e));
            migrationResult.addSuccessMessage(msg);
            if (throwError) {
                throw e;
            }
        } catch (Exception e) {
            String msg = String.format("error - branch %s failed for migration set %s, %s - %s",
                    entity.getBranchName(),
                    version,
                    migrationDefinition.getMigrationName(),
                    ExceptionUtils.getRootCauseMessage(e));
            migrationResult.addFailedeMessage(msg);
            if (throwError) {
                throw new SystemException("Error migrating branch", e);
            }
        }
        return migratedEntity;
    }

    /**
     * Clones the entity first then calls the migrateEntity method.  Once migrated the entity is saved to the database.
     * The implementing class of this abstract class is called here.  It is the migrateEntity method.
     *
     * @param entityToMigrate The entity to clone, migrate and persist to the database.
     * @param version         The version to set on the entity's item json.
     * @return The persisted instance of the migrated entity.
     */
    protected ItemEntity migrateAndSave(ItemEntity entityToMigrate, String version) {
        ItemEntity entityClone = this.cloneEntity(entityToMigrate, version);
        entityClone = this.migrateEntity(entityClone);
        return this.dataManager.insertItem(entityClone);
    }

    /**
     * Clones the entity and its item json.  The system user is set as the updatedBy on the entity.
     *
     * @param entityToClone The entity to clone.
     * @param version       The version to set on the item json.
     * @return A clone of the entity.
     */
    protected ItemEntity cloneEntity(ItemEntity entityToClone, String version) {
        ItemBankSystemUser systemUser = systemUser();

        Item itemClone = this.dataStoreUtility.cloneItemJson(entityToClone.getItemJson());
        itemClone.setVersion(version);

        ItemEntity entityClone = entityToClone.cloneFull(systemUser.getUserName());
        entityClone.setItemJson(itemClone);

        return entityClone;
    }

    /**
     * Helper method giving a quick reference to the system user.
     *
     * @return The system user configured in application properties.
     */
    protected ItemBankSystemUser systemUser() {
        return this.applicationProperties.getSystemUser();
    }

    /**
     * Only broadcast if the entity is the master branch and the migration definition is configured to broadcast.
     *
     * @param entity
     * @param migrationDefinition
     * @return
     */
    protected boolean shouldBroadcast(ItemEntity entity,
                                      ApplicationProperties.MigrationDefinition migrationDefinition) {
        return entity.isMaster() && migrationDefinition.isBroadcast();
    }

    /**
     * Finds all branches currently being edited.  Master is excluded.
     *
     * @param itemId The item id.
     * @return The current branch edits for an item.
     */
    protected List<ItemEntity> findBranches(String itemId) {
        List<ItemEntity> entities = this.dataManager.findAllCurrentBranchEdits(itemId);
        return entities.stream().filter(ItemEntity::isNotMaster).collect(Collectors.toList());
    }
}
