package org.opentestsystem.ap.migration.datastore;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.gitlab.GitLabSyncManager;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemBankSystemUser;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.contentupdater.ContentUpdateCommand;
import org.opentestsystem.ap.migration.contentupdater.ContentUpdater;
import org.opentestsystem.ap.migration.contentupdater.ContentUpdaterFactory;
import org.opentestsystem.ap.migration.model.BranchEditedException;
import org.opentestsystem.ap.migration.model.FailedMigrationException;
import org.opentestsystem.ap.migration.model.SkipMigration;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import static java.lang.String.format;
import static org.opentestsystem.ap.common.model.ItemConstants.BranchNames.BRANCH_MASTER;

@Slf4j
public abstract class AbstractDataStoreMigration implements DataStoreMigration {

    protected final ApplicationProperties applicationProperties;

    protected final DataStoreDataManager dataManager;

    protected final ItemManagerEventProducer eventProducer;

    protected final DataStoreUtility dataStoreUtility;

    protected final DataStoreAttachmentManager dataStoreAttachmentManager;

    protected final GitLabSyncManager itemBankSyncManager;

    protected final ItemBankProperties itemBankProperties;

    protected final ContentUpdaterFactory contentUpdaterFactory;

    /**
     * This abstract class clones the entity before calling this method.  The implementing class does not need to clone
     * the entity.  The implementing class should focus on whatever changes it need to make to the entity's item json .
     * The implementing class returns the entity with the altered json and the abstract class persists the entity to the
     * database.
     *
     * @param itemEntity The entity record to migrate.
     * @return The migrated entity record.
     */
    protected abstract ItemEntity migrateEntity(ItemEntity itemEntity);

    protected AbstractDataStoreMigration(final ApplicationDependencyProvider applicationDependencyProvider,
                                         final ApplicationProperties applicationProperties,
                                         final DataStoreDataManager dataManager,
                                         final ItemManagerEventProducer eventProducer,
                                         final DataStoreUtility dataStoreUtility,
                                         final DataStoreAttachmentManager dataStoreAttachmentManager) {
        this.applicationProperties = applicationProperties;
        this.dataManager = dataManager;
        this.eventProducer = eventProducer;
        this.dataStoreUtility = dataStoreUtility;
        this.dataStoreAttachmentManager = dataStoreAttachmentManager;
        this.itemBankSyncManager = applicationDependencyProvider.getItemBankSyncManager();
        this.itemBankProperties = applicationDependencyProvider.getItemBankProperties();
        this.contentUpdaterFactory = applicationDependencyProvider.getContentUpdaterFactory();
    }

    @Override
    public ItemEntity migrate(ItemEntity entityToMigrate,
                              String version,
                              ApplicationProperties.MigrationDefinition migrationDefinition,
                              DataStoreItemResult result) {
        log.info("migrate item {}, branch {}, version {} - {}",
            entityToMigrate.getItemId(),
            entityToMigrate.getBranchName(),
            version,
            migrationDefinition.getMigrationDescription());

        // this master, it is migrated before migrating any branches currently being edited
        ItemEntity migratedEntity = this.migrateBranch(entityToMigrate, version, migrationDefinition, result);

        // now migrate branches being edited
        this.migrateBranches(migratedEntity.getItemId(), version, migrationDefinition, result);

        return migratedEntity;
    }

    /**
     * Runs the migration on the item, but only for branches and not for the master branch.  The master branch is
     * handled in the public migrate as it is the always migrated where the other branches are optional and depend on
     * the migration.
     *
     * @param itemId              The item ID
     * @param version             The version the item is being migrated to
     * @param migrationDefinition The migration to apply to the item.
     * @param result              The result of the migration.
     * @return The persisted entities representing the branches migrated.
     */
    private List<ItemEntity> migrateBranches(String itemId,
                                             String version,
                                             ApplicationProperties.MigrationDefinition migrationDefinition,
                                             DataStoreItemResult result) {
        if (migrationDefinition.isMigrateBranches()) {
            return this.findBranches(itemId).stream().map(entity ->
                this.migrateBranch(entity, version, migrationDefinition, result))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
        }
        return Collections.emptyList();
    }

    /**
     * Migrates the entity for the given migration.
     *
     * @param entity              The entity to migrate
     * @param version             The version to set the entity's item json to
     * @param migrationDefinition The migration to run
     * @param result              The result of the migration
     * @return The persisted instance of the migrated entity.
     */
    protected ItemEntity migrateBranch(ItemEntity entity,
                                       String version,
                                       ApplicationProperties.MigrationDefinition migrationDefinition,
                                       DataStoreItemResult result) {
        ItemEntity migratedEntity = entity;
        if (this.shouldMigrateBranch(entity)) {
            try {
                migratedEntity = this.migrateAndSave(entity, version);
                String msg = format("success | item %s | set key %s | branch %s | migration %s | %s",
                    entity.getItemId(),
                    version,
                    entity.getBranchName(),
                    migrationDefinition.getMigrationName(),
                    migrationDefinition.getMigrationDescription());
                result.addSuccessMessage(msg);
                log.info(msg);
            } catch (BranchEditedException e) {
                String msg = format("branch_edited | item %s | set key %s | branch %s | migration %s | %s | %s",
                    entity.getItemId(),
                    version,
                    entity.getBranchName(),
                    migrationDefinition.getMigrationName(),
                    migrationDefinition.getMigrationDescription(),
                    ExceptionUtils.getRootCauseMessage(e));
                result.addBranchEditError(msg);
                log.info(msg);
                throw e;
            } catch (SkipMigration e) {
                String msg = format("skip | item %s | set key %s | branch %s | migration %s | %s | %s",
                    entity.getItemId(),
                    version,
                    entity.getBranchName(),
                    migrationDefinition.getMigrationName(),
                    migrationDefinition.getMigrationDescription(),
                    ExceptionUtils.getRootCauseMessage(e));
                result.addSkipMessage(msg);
                log.info(msg);
                throw e;
            } catch (Exception e) {
                String msg = format("failed | item %s | set key %s | branch %s | migration %s | %s | %s",
                    entity.getItemId(),
                    version,
                    entity.getBranchName(),
                    migrationDefinition.getMigrationName(),
                    migrationDefinition.getMigrationDescription(),
                    ExceptionUtils.getRootCauseMessage(e));
                result.addFailedMessage(msg);
                log.error(msg);
                throw new FailedMigrationException(msg, e);
            }
        }
        return migratedEntity;
    }

    /**
     * Clones the entity first then calls the migrateEntity method.  Once migrated the entity is saved to the database.
     * The implementing class of this abstract class is called here.  It is the migrateEntity method.
     *
     * @param entityToMigrate The entity to clone, migrate and persist to the database.
     * @param version         The version to set on the entity's item json.
     * @return The persisted instance of the migrated entity.
     */
    protected ItemEntity migrateAndSave(ItemEntity entityToMigrate, String version) {
        ItemEntity entityClone = this.cloneEntity(entityToMigrate, version);
        entityClone = this.migrateEntity(entityClone);
        return this.dataManager.insertItem(entityClone);
    }

    protected void syncAttachments(ItemEntity itemEntity, Path itemSyncDir) {
        itemBankSyncManager.syncAttachmentsToDataStore(itemEntity.getItemId(), BRANCH_MASTER, itemSyncDir);
    }

    /**
     * Clones the entity and its item json.  The system user is set as the updatedBy on the entity.
     *
     * @param entityToClone The entity to clone.
     * @param version       The version to set on the item json.
     * @return A clone of the entity.
     */
    protected ItemEntity cloneEntity(ItemEntity entityToClone, String version) {
        ItemBankSystemUser systemUser = systemUser();

        Item itemClone = this.dataStoreUtility.cloneItemJson(entityToClone.getItemJson());
        itemClone.setVersion(version);

        ItemEntity entityClone = entityToClone.cloneFull(systemUser.getUserName());
        entityClone.setItemJson(itemClone);
        if (Objects.nonNull(entityToClone.getCreatedDate())) {
            // not doing this results in a unique key violation in the database
            // we take the previous record which is what the entityToClone is and
            // add a few millis to it
            entityClone.setCreatedDate(entityToClone.getCreatedDate().plusMillis(250L));
        }

        return entityClone;
    }

    /**
     * Helper method giving a quick reference to the system user.
     *
     * @return The system user configured in application properties.
     */
    protected ItemBankSystemUser systemUser() {
        return this.applicationProperties.getSystemUser();
    }

    /**
     * Finds all branches currently being edited.  Master is excluded.
     *
     * @param itemId The item id.
     * @return The current branch edits for an item.
     */
    protected List<ItemEntity> findBranches(String itemId) {
        List<ItemEntity> entities = this.dataManager.findAllCurrentBranchEdits(itemId);
        return entities.stream().filter(ItemEntity::isNotMaster).collect(Collectors.toList());
    }

    /**
     * Concrete migrations need to override this method. The master branch is always migrated.  This method is intended
     * to allow concrete migrations to check the non-master branch before migrating it.  If a concrete migration is only
     * concerned with, for example, audio then any other non-master branch can be skipped.
     *
     * @param migratedEntity The entity holding the branch name.
     * @return True if the branch should be migrated.
     */
    protected boolean shouldMigrateBranch(ItemEntity migratedEntity) {
        return true;
    }

    /**
     * Used by migrations to create a temp directory, most often used to put attachments in where all files in the temp
     * dir are copied to S3.
     *
     * @param prefix
     * @return
     */
    protected Path createTempDir(String prefix) {
        try {
            return Files.createTempDirectory(prefix);
        } catch (IOException ioex) {
            throw new SystemException(ioex);
        }
    }

    /**
     * Calls the item-specific ContentUpdater implementation.
     *
     * @param itemEntity           ItemEntity to be updated
     * @param contentUpdateCommand ContentUpdateCommand to run
     * @return Updated ItemEntity
     */
    protected ItemEntity migrateEntityContent(ContentUpdaterFactory updaterFactory,
                                              ItemEntity itemEntity,
                                              ContentUpdateCommand contentUpdateCommand) {
        ContentUpdater updater = updaterFactory.getContentUpdaterForType(itemEntity.getItemJson().getType());
        updater.updateContent(itemEntity.getItemJson(), contentUpdateCommand);
        return itemEntity;
    }

}
