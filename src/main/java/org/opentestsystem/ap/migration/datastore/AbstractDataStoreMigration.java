package org.opentestsystem.ap.migration.datastore;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreEventProducer;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemBankSystemUser;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.SkipMigration;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@Slf4j
public abstract class AbstractDataStoreMigration implements DataStoreMigration {

    protected final ApplicationProperties applicationProperties;

    protected final DataStoreDataManager dataManager;

    protected final DataStoreEventProducer eventProducer;

    protected final DataStoreUtility dataStoreUtility;

    /**
     * The intention is only the entity's itemJson needs updated however, if this does not fit your migration needs you
     * could consider overriding the "migrate" method below.  You'll still need to implement this method but it could do
     * nothing.  Another consideration is not to extend your migration class from this abstract class but instead just
     * implement the {@link DataStoreMigration} directly.
     *
     * @param itemEntity The entity record to migrate.
     * @return The migrated entity record.
     */
    protected abstract ItemEntity migrateEntity(ItemEntity itemEntity);

    protected AbstractDataStoreMigration(ApplicationProperties applicationProperties,
                                         DataStoreDataManager dataManager,
                                         DataStoreEventProducer eventProducer,
                                         DataStoreUtility dataStoreUtility) {
        this.applicationProperties = applicationProperties;
        this.dataManager = dataManager;
        this.eventProducer = eventProducer;
        this.dataStoreUtility = dataStoreUtility;
    }

    @Override
    public ItemEntity migrate(ItemEntity entityToMigrate,
                              String version,
                              ApplicationProperties.MigrationDefinition migrationDefinition,
                              DataStoreItemResult result) {
        log.info("migrateAndSave item {}, branch {}, version {} - {}",
            entityToMigrate.getItemId(),
            entityToMigrate.getBranchName(),
            version,
            migrationDefinition.getMigrationDescription());

        DataStoreItemResult.MigrationResult migrationResult = new DataStoreItemResult.MigrationResult(
            version, migrationDefinition.getMigrationName());

        result.addMigrationResult(migrationResult);

        // this is intended to be the master branch, not required but intended, the idea being always migrate the
        // master branch and push it down stream, there is no need to push non-master branch entities down stream as
        // those should
        ItemEntity migratedEntity = this.migrate(
            entityToMigrate,
            version,
            migrationDefinition, migrationResult,
            true);

        this.broadcastMigration(migratedEntity, migrationDefinition);

        this.migrateBranches(migratedEntity.getItemId(), version, migrationDefinition, migrationResult);

        return migratedEntity;
    }

    /**
     * When migrating using the data store only the master branch needs pushed downstream (e.g into the item bank). If
     * the master branch needs pushed downstream this is what does it.  It puts a commit event on the sync queue.
     *
     * @param entity              The entity record to push downstream.
     * @param migrationDefinition The migration being pushed, this is the commit message you should see in GitLab
     *                            related to this event.
     */
    protected void broadcastMigration(ItemEntity entity,
                                      ApplicationProperties.MigrationDefinition migrationDefinition) {
        if (this.shouldBroadcast(entity, migrationDefinition)) {
            this.eventProducer.
                sendCommitEvent(systemUser(), entity, entity, migrationDefinition.getMigrationDescription());
        }
    }

    protected List<ItemEntity> migrateBranches(String itemId,
                                               String version,
                                               ApplicationProperties.MigrationDefinition migrationDefinition,
                                               DataStoreItemResult.MigrationResult migrationResult) {
        if (migrationDefinition.isMigrateBranches()) {
            return this.findBranches(itemId).stream().map(entity ->
                this.migrate(entity, version, migrationDefinition, migrationResult, false))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
        }
        return Collections.emptyList();
    }

    protected ItemEntity migrate(ItemEntity entity,
                                 String version,
                                 ApplicationProperties.MigrationDefinition migrationDefinition,
                                 DataStoreItemResult.MigrationResult migrationResult,
                                 boolean throwError) {
        ItemEntity migratedEntity = null;
        try {
            migratedEntity = this.migrateAndSave(entity, version);
            String msg = String.format("success - branch %s for migration set %s, migration %s",
                entity.getBranchName(),
                version,
                migrationDefinition.getMigrationName());
            migrationResult.addSuccessMessage(msg);
        } catch (SkipMigration e) {
            String msg = String.format("skip - branch %s for migration set %s, migration %s - %s",
                entity.getBranchName(),
                version,
                migrationDefinition.getMigrationName(),
                ExceptionUtils.getRootCauseMessage(e));
            migrationResult.addSuccessMessage(msg);
            if (throwError) {
                throw e;
            }
        } catch (Exception e) {
            String msg = String.format("error - branch %s failed for migration set %s, migration %s - %s",
                entity.getBranchName(),
                version,
                migrationDefinition.getMigrationName(),
                ExceptionUtils.getRootCauseMessage(e));
            migrationResult.addFailedeMessage(msg);
            if (throwError) {
                throw new SystemException("Error migrating branch", e);
            }
        }
        return migratedEntity;
    }

    protected ItemEntity migrateAndSave(ItemEntity entityToMigrate, String version) {
        ItemEntity entityClone = this.cloneEntity(entityToMigrate, version);
        this.migrateEntity(entityClone);
        return this.dataManager.insertItem(entityClone);
    }

    protected ItemEntity cloneEntity(ItemEntity entityToMigrate, String version) {
        ItemBankSystemUser systemUser = systemUser();

        Item itemClone = this.dataStoreUtility.cloneItemJson(entityToMigrate.getItemJson());
        itemClone.setVersion(version);

        ItemEntity entityClone = entityToMigrate.cloneFull(systemUser.getUserName());
        entityClone.setItemJson(itemClone);

        return entityClone;
    }

    protected ItemBankSystemUser systemUser() {
        return this.applicationProperties.getSystemUser();
    }

    /**
     * Only broadcast if the entity is the master branch and the migration definition is configured to broadcast.
     *
     * @param entity
     * @param migrationDefinition
     * @return
     */
    protected boolean shouldBroadcast(ItemEntity entity,
                                      ApplicationProperties.MigrationDefinition migrationDefinition) {
        return entity.isMaster() && migrationDefinition.isBroadcast();
    }

    /**
     * Finds all branches currently being edited.  Master is excluded.
     *
     * @param itemId The item id.
     * @return The current branch edits for an item.
     */
    protected List<ItemEntity> findBranches(String itemId) {
        List<ItemEntity> entities = this.dataManager.findAllCurrentBranchEdits(itemId);
        return entities.stream().filter(ItemEntity::isNotMaster).collect(Collectors.toList());
    }
}
