package org.opentestsystem.ap.migration.migration;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Attachment;
import org.opentestsystem.ap.common.model.Glossary;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.glossary.GlossaryDialect;
import org.opentestsystem.ap.common.model.glossary.GlossaryLanguage;
import org.opentestsystem.ap.common.model.glossary.GlossaryLanguages;
import org.opentestsystem.ap.common.model.glossary.GlossaryTerm;
import org.opentestsystem.ap.common.saaif.mapper.model.ImportItem;
import org.opentestsystem.ap.common.saaif.mapper.model.SkipMigration;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.ItemMerge;
import org.opentestsystem.ap.migration.util.ApplicationDependencyProvider;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.lang.String.format;
import static org.opentestsystem.ap.common.model.ModelConstants.ItemType.TYPE_TUT;

@Slf4j
@Component
/**
 * This migration will add an Attachment object for a .m4a file to any Glossary Term that is missing it
 * It checks the contents of the import.zip to confirm the file was provided during the initial import
 */
public class Migration3104 extends AbstractImportMigration {

    public Migration3104(ApplicationProperties applicationProperties,
                         DataStoreDataManager dataManager,
                         ItemManagerEventProducer eventProducer,
                         DataStoreUtility dataStoreUtility,
                         DataStoreAttachmentManager dataStoreAttachmentManager,
                         ApplicationDependencyProvider applicationDependencyProvider) {
        super(applicationProperties, dataManager, eventProducer,
                dataStoreUtility, dataStoreAttachmentManager, applicationDependencyProvider);
    }

    @Override
    protected void checkSkipMigration(ItemEntity itemEntity) {
        Item item = itemEntity.getItemJson();
        if (TYPE_TUT.equalsIgnoreCase(item.getType())) {
            throw new SkipMigration(format("%s Skipped: Item %s it a tutorial which does not have glossary terms",
                    getMigrationName(), item.getId()));
        }
        if (item.getGlossary().getTerms().size() == 0) {
            throw new SkipMigration(format("%s Skipped: Item %s does not have glossary terms",
                    getMigrationName(), item.getId()));
        }
    }

    @Override
    protected Collection<String> getEditedSectionsBlockingMigration() {
        return Collections.emptyList();
    }


    @Override
    protected ItemMerge mergeItem(Item dataStoreItem, Item mappedItem, Path itemSyncDir) {
        try {
            // Create temporary directory to store files
            Path attachmentSyncDir = Files.createTempDirectory("Migration3104-");
            // Create glossary directory
            attachmentSyncDir.resolve("glossary").toFile().mkdirs();
            dataStoreItem.getGlossary().getTerms().forEach(glossaryTerm -> {
                String dataStoreItemId = dataStoreItem.getId();
                String glossaryTermId = glossaryTerm.getId();

                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().arabic, "arabic",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().burmese, "burmese",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().cantonese, "cantonese",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().english, "english",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().filipino, "filipino",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().hmong, "hmong",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().korean, "korean",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().mandarin, "mandarin",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().punjabi, "punjabi",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().russian, "russian",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().somali, "somali",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().spanish, "spanish",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().ukrainian, "ukrainian",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
                updateM4aFilesOnGlossaryLanguage(glossaryTerm.getLanguages().vietnamese, "vietnamese",
                        dataStoreItemId, glossaryTermId, itemSyncDir, attachmentSyncDir);
            });

            return new ItemMerge(dataStoreItem, attachmentSyncDir, true);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Traverses all GlossaryTerms and creates an AudioFile Attachment where only an .ogg file exists.
     * The m4a file is also copied from the import.zip and synched to the item.
     * @param glossaryLanguage   The glossary language to update.
     * @param dataStoreItemId    The Item Id.
     * @param glossaryTermId     The glossary term id.
     * @param itemSyncDir        The Path containing the expanded import.zip files.
     * @param attachmentSyncDir  The Path where new files to be synched will be copied to.
     */
    private void updateM4aFilesOnGlossaryLanguage(GlossaryLanguage glossaryLanguage,
                                                  String languageName,
                                                  String dataStoreItemId,
                                                  String glossaryTermId,
                                                  Path itemSyncDir,
                                                  Path attachmentSyncDir) {
        glossaryLanguage.dialects.forEach(glossaryDialect -> {
            // Find first audio file with an .ogg extension
            Attachment oggAttachment = findFirstOggAttachment(glossaryDialect.getAudioFiles());
            if (Objects.nonNull(oggAttachment)) {
                String m4aFileName = oggAttachment.getFileName()
                        .replace(".ogg", ".m4a");
                // Add audio file if equivalent .m4a file is not found
                if (!hasFile(glossaryDialect.getAudioFiles(), m4aFileName)) {
                    String prefix = String.format("%s_%s_%s_%s_",
                            dataStoreItemId,
                            glossaryTermId,
                            languageName,
                            glossaryDialect.getId());
                    // Audio file name was named different in import.zip
                    String importM4aFileName = m4aFileName.replace(prefix, "");
                    File sourceFile = new File(itemSyncDir.resolve("glossary").toFile(), importM4aFileName);
                    File destinationFile = new File(attachmentSyncDir.resolve("glossary").toFile(), m4aFileName);
                    // Copy m4a file with new name to the attachments sync directory
                    if (sourceFile.exists()) {
                        try {
                            Files.copy(sourceFile.toPath(), destinationFile.toPath());
                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    // If copy was successful, add audio attachment to item.json
                    glossaryDialect.getAudioFiles().add(new Attachment(m4aFileName,
                            oggAttachment.getUploadedDate(), oggAttachment.getSection()));
                }
            }
        });
    }

    /**
     * Confirms if a filename exists in a List<Attachment></Attachment>
     * @param attachments   List of Attachment objects
     * @param fileName      File name to be searched
     * @return              true, false
     */
    private boolean hasFile(List<Attachment> attachments, String fileName) {
        Optional<Attachment> m4aAttachment = attachments.stream()
                .filter(attachment -> attachment.getFileName().equals(fileName))
                .findAny();
        return m4aAttachment.isPresent();
    }

    /**
     * Finds first Attachment with a filename with extension .ogg
     * @param attachments  List of Attachment objects
     * @return             Attachment object where filename was found
     */
    private Attachment findFirstOggAttachment(List<Attachment> attachments) {
        Attachment oggAttach = null;
        Optional<Attachment> oggAttachment = attachments.stream()
                .filter(attachment -> attachment.getFileName().endsWith(".ogg"))
                .findFirst();
        if (oggAttachment.isPresent()) {
            oggAttach = oggAttachment.get();
        }
        return oggAttach;
    }
}
