package org.opentestsystem.ap.migration.migration;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.gitlab.GitLabSyncManager;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.datastore.AbstractDataStoreMigration;
import org.opentestsystem.ap.migration.mapper.IatModelMapper;
import org.opentestsystem.ap.migration.mapper.IatModelMapperFactory;
import org.opentestsystem.ap.migration.model.ImportItem;
import org.opentestsystem.ap.migration.model.SkipMigration;
import org.opentestsystem.ap.migration.util.MigrationFileUtil;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.apache.commons.lang3.StringUtils.isNotBlank;
import static org.opentestsystem.ap.common.model.ItemConstants.BranchNames.BRANCH_MASTER;

public abstract class AbstractImportMigration extends AbstractDataStoreMigration {
    protected final String migrationName;
    protected final String migrationItemType;
    protected final MigrationFileUtil migrationFileUtil;
    protected final GitLabSyncManager itemBankSyncManager;

    protected Path itemSyncDir;

    public AbstractImportMigration(final ApplicationProperties applicationProperties,
                                   final DataStoreDataManager dataManager,
                                   final ItemManagerEventProducer eventProducer,
                                   final DataStoreUtility dataStoreUtility,
                                   final DataStoreAttachmentManager dataStoreAttachmentManager,
                                   final ApplicationDependencyProvider applicationDependencyProvider) {
        this(applicationProperties, dataManager, eventProducer, dataStoreUtility, dataStoreAttachmentManager,
                applicationDependencyProvider, StringUtils.EMPTY);
    }

    public AbstractImportMigration(final ApplicationProperties applicationProperties,
                                   final DataStoreDataManager dataManager,
                                   final ItemManagerEventProducer eventProducer,
                                   final DataStoreUtility dataStoreUtility,
                                   final DataStoreAttachmentManager dataStoreAttachmentManager,
                                   final ApplicationDependencyProvider applicationDependencyProvider,
                                   final String migrationItemType) {
        super(applicationDependencyProvider, applicationProperties, dataManager, eventProducer, dataStoreUtility,
                dataStoreAttachmentManager);
        this.migrationName = getClass().getSimpleName();
        this.migrationItemType = migrationItemType;
        this.migrationFileUtil = applicationDependencyProvider.getMigrationFileUtil();
        this.itemBankSyncManager = applicationDependencyProvider.getItemBankSyncManager();
    }

    @Override
    protected ItemEntity migrateEntity(final ItemEntity itemEntity) {
        this.checkSkipMigration(itemEntity);

        ImportItem importItem = migrationFileUtil.getImportItem(itemEntity).orElseThrow(() ->
                new SkipMigration(String.format("%s Skipped: Could not find import files for item %s", migrationName,
                        itemEntity.getItemId())));

        Item tiItem = itemEntity.getItemJson();

        final IatModelMapper mapper = IatModelMapperFactory.getInstance().newModelMapper(tiItem.getType());

        try {
            this.itemSyncDir = Files.createTempDirectory(itemEntity.getItemId());

            Item mappedItem = mapper.mapSaaifToIATModel(importItem.getItemProps(),
                    tiItem,
                    importItem.getItemRelease(),
                    importItem.getSmarterAppMetadata(),
                    importItem.getWordlistreleaseType().orElse(null),
                    importItem.getWordlistPathString(),
                    this.itemSyncDir,
                    importItem.getExpandedImportItemPath().toString());

            itemEntity.setItemJson(mappedItem);

            this.syncAttachmentsToDataStore(itemEntity);

        } catch (IOException e) {
            throw new RuntimeException(
                    String.format("%s: Issue migrating item %s exception: %s", migrationName, itemEntity.getItemId(),
                            e.getMessage()));
        }

        return itemEntity;
    }

    /**
     * Throws {@link SkipMigration} if the migration should be skipped for the given entity.
     *
     * @param itemEntity The entity to check if the migration should be skipped.
     */
    protected void checkSkipMigration(ItemEntity itemEntity) {
        if (isNotBlank(migrationItemType) && !migrationItemType.equals(itemEntity.getItemJson().getType())) {
            throw new SkipMigration(
                    String.format("%s Skipped: item %s is not of type %s", migrationName, itemEntity.getItemId(),
                            migrationItemType));
        }
    }

    /**
     * Technically we need to sync more than just the 'master' folder in S3.  If a user is editing braille for example
     * they may have uploaded a file(s).  Those files are uploaded to the 'braille' folder in S3.  If migration only
     * syncs to the 'master' when the user commits their braille changes it could overwrite the files on 'master'. It is
     * an edge case because it is unlikely anyone is editing imported items, and it is unlikely the migration and the
     * user are using the same file name.
     * <p>
     * One thought is check in S3 if the folder for the branch exists.  If not then there is no need to sync to the
     * branch folder in S3.  Or we check if the file exists in the branch folder and only sync if it does.
     * <p>
     * Concrete migrations can overwrite this as they see fit.
     *
     * @param itemEntity
     */
    protected void syncAttachmentsToDataStore(ItemEntity itemEntity) {
        if (this.shouldSyncAttachmentsToDataStore(itemEntity)) {
            // if we sync branches then we cannot sync everything in the itemSyncDir
            // braille should only sync braille files to the 'braille' folder in S3
            // asl should only sync asl files to the 'asl' folder in S3
            itemBankSyncManager.syncAttachmentsToDataStore(itemEntity.getItemId(), BRANCH_MASTER, this.itemSyncDir);
        }
    }

    /**
     * Bypass syncing attachments to the data store (e.g. S3) if the migration does not require it.  Also you can skip
     * sync depending on the branch the entity represents.  For example, sync for master and braille, but skip sync for
     * all other branches.
     *
     * By default we only sync if the entity branch is master.  That should be ok assuming there are no branches
     * being edited for imported items.
     *
     * @param itemEntity The entity to check if sync applies.
     * @return True if sync to the data store should be done. False if no sync is required.
     */
    protected boolean shouldSyncAttachmentsToDataStore(ItemEntity itemEntity) {
        return BRANCH_MASTER.equalsIgnoreCase(itemEntity.getBranchName());
    }
}
