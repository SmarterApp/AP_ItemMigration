package org.opentestsystem.ap.migration.migration;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.ListUtils;
import org.apache.commons.lang3.StringUtils;
import org.gitlab4j.api.models.RepositoryFile;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.gitlab.GitLabSyncManager;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Attachment;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemAudioResource;
import org.opentestsystem.ap.common.model.StimItem;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.datastore.AbstractDataStoreMigration;
import org.opentestsystem.ap.migration.mapper.IatModelMapperFactory;
import org.opentestsystem.ap.migration.model.SkipMigration;
import org.opentestsystem.ap.migration.util.MigrationFileUtil;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.StandardCopyOption;
import java.util.Base64;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static java.lang.String.format;
import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;
import static org.opentestsystem.ap.common.model.ItemConstants.BranchNames.BRANCH_MASTER;
import static org.opentestsystem.ap.common.model.ItemConstants.ItemType.TYPE_STIM;
import static org.opentestsystem.ap.common.model.ItemConstants.Section.SECTION_AUDIO;
import static org.opentestsystem.ap.migration.util.MigrationFileUtil.IMPORT_ZIP_FILENAME;

@Slf4j
@Component
public class Migration2657AudioRename extends Migration2657 {

    public Migration2657AudioRename(ApplicationDependencyProvider applicationDependencyProvider,
                                    ApplicationProperties applicationProperties,
                                    DataStoreDataManager dataManager,
                                    ItemManagerEventProducer eventProducer,
                                    DataStoreUtility dataStoreUtility,
                                    DataStoreAttachmentManager attachmentManager) {

        super(applicationDependencyProvider,
                applicationProperties,
                dataManager,
                eventProducer,
                dataStoreUtility,
                attachmentManager);
    }

    @Override
    protected boolean shouldMigrateBranch(ItemEntity migratedEntity) {
        if (Objects.isNull(migratedEntity) || Objects.isNull(migratedEntity.getBranchName())) {
            return false;
        }
        String branch = migratedEntity.getBranchName();
        if (BRANCH_MASTER.equalsIgnoreCase(branch) || SECTION_AUDIO.equalsIgnoreCase(branch)) {
            return true;
        }
        return false;
    }

    @Override
    public ItemEntity migrateEntity(ItemEntity itemEntity) {
        Item item = itemEntity.getItemJson();
        check(item);

        StimItem stim = (StimItem) item;

        renameAudioFiles(stim, itemEntity.getBranchName());

        return itemEntity;
    }

    private StimItem renameAudioFiles(StimItem stim, String branch) {
        if (StringUtils.isBlank(stim.getItsId())) {
            throw new SkipMigration(format("Stim %s has no ITS ID", stim.getId()));
        }

        Optional<RepositoryFile> importZip = gitlabClient.lookUpFileOnMaster(stim.getId(), IMPORT_ZIP_FILENAME);

        // rename the files on disk
        importZip.ifPresent(repoFile -> {
            if (StringUtils.isNotBlank(repoFile.getContent())) {
                // unzip to a random path
                Path expandedZip = migrationFileUtil.getExpandedImportZipFile(
                        stim.getId(), Base64.getDecoder().decode(repoFile.getContent()));

                // import.zip can contain multiple directories or none at all,
                // identify the imported item source directory
                Path itemSourceDir = MigrationFileUtil.getItemSourceDir(expandedZip, stim.getItsId());

                try {
                    // Create temporary directory to store attachment files that might need syncing to S3
                    Path itemSyncDir = Files.createTempDirectory(stim.getId());

                    // m4a files are not always referenced in the XML
                    // here we make sure those m4a files get in the datastore
                    this.copyAndRenameAudioFiles(stim.getId(), stim.getItsId(), itemSourceDir, itemSyncDir);

                    itemBankSyncManager
                            .syncAttachmentsToDataStore(stim.getId(), branch, itemSyncDir);

                } catch (IOException ioex) {
                    throw new SystemException(ioex);
                }
            }
        });

        // rename the files in the model
        List<ItemAudioResource> audioResources = stim.getAudio().getAudioResources();

        if (isNotEmpty(audioResources)) {
            for (ItemAudioResource resource : audioResources) {
                if (isNotEmpty(resource.getProductionFiles())) {
                    for (Attachment attachment : resource.getProductionFiles()) {
                        // make sure the file name isn't already correct
                        if (!attachment.getFileName().contains(stim.getId())) {
                            attachment.setFileName(attachment.getFileName().replace(stim.getItsId(), stim.getId()));
                        }
                    }
                }
            }
        }

        return stim;
    }

    private void copyAndRenameAudioFiles(String itemId, String itsId, Path srcFolder, Path targetFolder) {
        FileSystem fileSystem = FileSystems.getDefault();
        PathMatcher fileFilter = fileSystem.getPathMatcher("glob:**.{ogg,m4a}");
        try {
            final List<Path> audioFiles = ListUtils.emptyIfNull(Files.walk(srcFolder)
                    .filter(fileFilter::matches)
                    .collect(Collectors.toList()));

            for (Path srcFile : audioFiles) {
                // make sure the file name isn't already correct
                if (!srcFile.toFile().getName().contains(itemId)) {
                    Path targetFile = targetFolder.resolve(srcFile.toFile().getName().replace(itsId, itemId));
                    Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);
                }
            }

        } catch (IOException e) {
            throw new SkipMigration(format("Item %s - error copying audio files - %s", itemId, e.getMessage()));
        }
    }
}
