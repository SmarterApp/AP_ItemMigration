package org.opentestsystem.ap.migration.migration;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.gitlab4j.api.models.RepositoryFile;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Glossary;
import org.opentestsystem.ap.common.model.WorkflowStatusEnum;
import org.opentestsystem.ap.common.model.glossary.GlossaryDialect;
import org.opentestsystem.ap.common.model.glossary.GlossaryLanguage;
import org.opentestsystem.ap.common.model.glossary.GlossaryLanguages;
import org.opentestsystem.ap.common.model.glossary.GlossaryTerm;
import org.opentestsystem.ap.common.saaif.model.SkipMigration;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.datastore.AbstractDataStoreMigration;
import org.opentestsystem.ap.migration.model.MigrationContext;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;

import static org.apache.commons.lang3.StringUtils.isNotBlank;

@Slf4j
@Component
public class Migration2576 extends AbstractDataStoreMigration {
    private static final String IMPORT_ZIP = "import.zip";
    private static final String undetermined = "undetermined";

    private final GitlabClient gitlabClient;

    public Migration2576(final ApplicationDependencyProvider applicationDependencyProvider,
                         final ApplicationProperties applicationProperties,
                         final DataStoreDataManager dataManager,
                         final ItemManagerEventProducer eventProducer,
                         final DataStoreUtility dataStoreUtility,
                         final DataStoreAttachmentManager dataStoreAttachmentManager,
                         final GitlabClient gitlabClient) {
        super(applicationDependencyProvider, applicationProperties, dataManager, eventProducer, dataStoreUtility, dataStoreAttachmentManager);
        this.gitlabClient = gitlabClient;
    }

    @Override
    protected ItemEntity migrateEntity(final ItemEntity itemEntity, MigrationContext migrationContext) {

        Optional<RepositoryFile> maybeImportZip = gitlabClient.lookUpFileOnMaster(itemEntity.getItemId(), IMPORT_ZIP);
        if (!maybeImportZip.isPresent()) {
            throw new SkipMigration(String.format("Item %s is not imported.  No glossary updates necessary", itemEntity.getId()));
        }

        Glossary glossary = itemEntity.getItemJson().getGlossary();
        List<GlossaryTerm> terms = glossary.getTerms();

        glossary.setIllustratedGlossaryRequired(calculateIllustratedGlossaryRequired(terms));
        glossary.setTranslatedGlossaryRequired(calculatedTranslatedGlossaryRequired(terms));
        glossary.setIllustratedGlossaryProvided(Boolean.TRUE.toString().equals(glossary.getIllustratedGlossaryRequired()));
        glossary.setTranslatedGlossaryProvided(Boolean.TRUE.toString().equals(glossary.getTranslatedGlossaryRequired()));

        if (!WorkflowStatusEnum.ParkingLot.isEqual(itemEntity.getItemJson().getWorkflow().getWorkflowStatusCode())) {
            glossary.setEnglishGlossaryProvided(calculateEnglishProvided(terms));
        }

        return itemEntity;
    }

    private String calculateIllustratedGlossaryRequired(List<GlossaryTerm> terms) {
        Optional<GlossaryTerm> illustratedTerm = terms.stream()
                .filter(glossaryTerm -> isNotBlank(glossaryTerm.getIllustrationImageResourceId()))
                .findAny();

        return illustratedTerm.isPresent() ? Boolean.TRUE.toString() : undetermined;
    }

    private String calculatedTranslatedGlossaryRequired(List<GlossaryTerm> terms) {
        Optional<GlossaryTerm> illustratedTerm = terms.stream()
                .filter(glossaryTerm -> isTranslatedTerms(glossaryTerm.getLanguages()))
                .findAny();

        return illustratedTerm.isPresent() ? Boolean.TRUE.toString() : undetermined;
    }

    private boolean calculateEnglishProvided(List<GlossaryTerm> terms) {
        if (terms.isEmpty()) {
            return false;
        }

        for (GlossaryTerm term : terms) {
            if (term.getLanguages().getEnglish().getDialects().isEmpty()) {
                return false;
            }

            Optional<GlossaryDialect> dialectWithEnglish = term.getLanguages().getEnglish().getDialects()
                    .stream()
                    .filter(glossaryDialect -> isNotBlank(glossaryDialect.getDefinition()))
                    .findAny();

            if (!dialectWithEnglish.isPresent()) {
                return false;
            }
        }

        return true;
    }

    private boolean isTranslatedTerms(GlossaryLanguages glossaryLanguages) {
        return isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getArabic())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getBurmese())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getCantonese())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getFilipino())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getHmong())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getKorean())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getMandarin())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getPunjabi())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getRussian())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getSomali())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getSpanish())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getUkrainian())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getVietnamese());

    }

    private boolean isTranslatedGlossaryLanguageContainNonBlankValues(GlossaryLanguage language) {
        for (GlossaryDialect dialect : language.getDialects()) {
            if (StringUtils.isNotBlank(dialect.getDefinition())) {
                return true;
            }
        }

        return false;
    }
}
