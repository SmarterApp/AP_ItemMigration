package org.opentestsystem.ap.migration.migration;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.ArchiveInputStream;
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreItemManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.ValidationException;
import org.opentestsystem.ap.common.model.Attachment;
import org.opentestsystem.ap.common.model.GiItem;
import org.opentestsystem.ap.common.model.attachment.AttachmentSelector;
import org.opentestsystem.ap.common.model.attachment.DataStoreAttachment;
import org.opentestsystem.ap.common.model.attachment.StreamBackedResource;
import org.opentestsystem.ap.common.model.content.GiItemContent;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.FailedMigrationException;
import org.opentestsystem.ap.migration.model.MigrationContext;
import org.opentestsystem.ap.migration.util.ApplicationDependencyProvider;

import static java.lang.String.format;
import static org.apache.commons.io.FileUtils.deleteQuietly;
import static org.apache.commons.io.FilenameUtils.removeExtension;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.opentestsystem.ap.common.model.ModelConstants.BranchNames.BRANCH_MASTER;
import static org.opentestsystem.ap.common.model.ModelConstants.ItemType.TYPE_GI;
import static org.opentestsystem.ap.common.model.ModelConstants.Section.SECTION_CORE;

/**
 * This migration expands the GI archive zip and:
 * 1. Ingests the GAX contents into the item json
 * 2. Extracts and uploads GAX-referenced resources to S3
 * 3. Adds Attachment references for the GAX-referenced resources to the item json
 *
 * NOTE: This migration also touches every Item json to perform model version migration
 * via the new {@link org.opentestsystem.ap.common.model.versioning.ItemDeserializer}
 *
 * This has to handle a number of states:
 * 1. The item is not being edited (no "core" branch edits)
 * 2. The item is being edited, but a new archive has not been uploaded
 *   (In this case, the "master" archive is downloaded, expanded, and
 *    resources are uploaded into the editing branch)
 * 3. The item is being edited, and a new archive has been uploaded
 *   (In this case, the "core" archive is downloaded, expanded, and
 *    resources are uploaded into the editing branch)
 *
 * NOTE: This implementation is heavily based on the IMS ArchiveService#saveGiArchive method
 */
@Component
@Slf4j
public class MigrationQ168 extends AbstractMigration {
    private static final Pattern TRANSLATED_RESOURCE_FILENAME = Pattern.compile("^(.+)_(.+?)$");

    protected MigrationQ168(final ApplicationDependencyProvider applicationDependencyProvider, final ApplicationProperties applicationProperties, final DataStoreDataManager dataManager, final DataStoreItemManager dataStoreItemManager, final DataStoreUtility dataStoreUtility, final DataStoreAttachmentManager dataStoreAttachmentManager) {
        super(applicationDependencyProvider, applicationProperties, dataManager, dataStoreItemManager, dataStoreUtility, dataStoreAttachmentManager);
    }

    @Override
    protected ItemEntity migrateEntity(final ItemEntity itemEntity, final MigrationContext migrationContext) {
        if (!TYPE_GI.equalsIgnoreCase(itemEntity.getItemJson().getType())) {
            return itemEntity;
        }

        final String branch = itemEntity.getBranchName();
        final String itemId = itemEntity.getItemId();
        final GiItemContent content = ((GiItem) itemEntity.getItemJson()).getCore().getEn();
        final Attachment giArchiveAttachment = content.getContentZipFile();
        if (giArchiveAttachment == null || isBlank(giArchiveAttachment.getFileName())) {
            return itemEntity;
        }

        Path archiveContents = null;
        try {
            archiveContents = downloadGiArchive(itemId, branch, giArchiveAttachment);

            final Map<String, Path> archiveResources = FileUtils.listFiles(archiveContents.toFile(),null,false).stream()
                    .collect(Collectors.toMap(
                            File::getName,
                            File::toPath
                    ));

            final Path gaxFile = findGaxFile(archiveResources);

            // Save GAX / GI definition in item.json
            try (final InputStream gaxStream = Files.newInputStream(gaxFile)) {
                content.setGiDefinition(IOUtils.toString(gaxStream, StandardCharsets.UTF_8).trim());
            }

            // Validate and upload GAX-referenced resources
            final List<String> referencedFilenames = AttachmentSelector.getReferencedGaxFileNames(gaxFile.toFile());
            final List<Path> referencedResources = findGaxResources(referencedFilenames, archiveResources);

            // Include translated GAX resource overrides
            referencedResources.addAll(findGaxTranslatedResources(referencedFilenames, archiveResources));

            // Upload associated resources
            final List<Attachment> attachments = referencedResources.stream()
                    .map(resource -> uploadResource(itemId, branch, resource))
                    .map(DataStoreAttachment::getAttachment)
                    .collect(Collectors.toList());

            content.setGiResources(attachments);

        } catch (final NoSuchElementException | IOException e) {
            log.error("Item [{}] failed to expand GI archive zip contents", itemId, e);
            throw new FailedMigrationException("Failed to expand GI archive zip contents", e);
        } finally {
            if (archiveContents != null) {
                deleteQuietly(archiveContents.toFile());
            }
        }

        return itemEntity;
    }

    @Override
    protected boolean shouldMigrateBranch(final ItemEntity migratedEntity) {
        return SECTION_CORE.equals(migratedEntity.getBranchName());
    }

    private Path downloadGiArchive(final String itemId, final String branch, final Attachment giArchiveAttachment) throws IOException {
        try (final InputStream content = getGiArchive(itemId, branch, giArchiveAttachment).getInputStream();
             final ArchiveInputStream archiveStream = new ZipArchiveInputStream(content)) {
            final Path archiveDirectory = Files.createTempDirectory("gi-contents");
            ArchiveEntry entry = archiveStream.getNextEntry();
            while (entry != null) {
                if (!entry.isDirectory()) {
                    final Path output = archiveDirectory.resolve(entry.getName());
                    writeFile(output, archiveStream);
                }
                entry = archiveStream.getNextEntry();
            }
            return archiveDirectory;
        }
    }

    private StreamBackedResource getGiArchive(final String itemId, final String branch, final Attachment giArchiveAttachment) {
        final DataStoreAttachment dataStoreAttachment = DataStoreAttachment.builder()
                .attachment(giArchiveAttachment)
                .build();
        try {
            return dataStoreAttachmentManager.openAttachment(itemId, branch, dataStoreAttachment);
        } catch (final NoSuchElementException e) {
            if (SECTION_CORE.equals(branch)) {
                return dataStoreAttachmentManager.openAttachment(itemId, BRANCH_MASTER, dataStoreAttachment);
            }
            throw e;
        }
    }

    private void writeFile(final Path target, final InputStream data) throws IOException {
        try (final OutputStream output = Files.newOutputStream(target)) {
            IOUtils.copy(data, output);
        }
    }

    private Path findGaxFile(final Map<String, Path> contentsByFilename) {
        final List<Path> gaxFiles = contentsByFilename.entrySet().stream()
                .filter(entry -> FilenameUtils.isExtension(entry.getKey(), "gax"))
                .map(Map.Entry::getValue)
                .collect(Collectors.toList());
        if (gaxFiles.size() != 1) {
            throw new ValidationException("GI Archive must contain one and only one .gax GI definition XML file");
        }
        return gaxFiles.get(0);
    }

    private List<Path> findGaxResources(final Collection<String> resourceNames, final Map<String, Path> contentsByFilename) {
        return resourceNames.stream()
                .map(referencedFilename -> {
                    if (!contentsByFilename.containsKey(referencedFilename)) {
                        throw new ValidationException(format("GAX references missing resource: %s", referencedFilename));
                    }
                    return contentsByFilename.get(referencedFilename);
                })
                .collect(Collectors.toList());
    }

    private List<Path> findGaxTranslatedResources(final Collection<String> resourceNames, final Map<String, Path> contentsByFilename) {
        final Set<String> referencedFilenameBases = resourceNames.stream()
                .map(FilenameUtils::removeExtension)
                .collect(Collectors.toSet());

        return contentsByFilename.entrySet().stream()
                .filter(entry -> {
                    final String uploadedFilename = removeExtension(entry.getKey());
                    final Matcher matcher = TRANSLATED_RESOURCE_FILENAME.matcher(uploadedFilename);
                    if (!matcher.matches()) {
                        return false;
                    }

                    final String referencedFilename = matcher.group(1);
                    return referencedFilenameBases.contains(referencedFilename);
                })
                .map(Map.Entry::getValue)
                .collect(Collectors.toList());
    }

    private DataStoreAttachment uploadResource(final String itemId, final String branch, final Path resource) {
        final DataStoreAttachment sourceAttachment = DataStoreAttachment.builder()
                .attachment(Attachment.newAttachment(resource.getFileName().toString(), "core"))
                .build();
        try (final InputStream content = Files.newInputStream(resource)) {
            return dataStoreAttachmentManager.saveAttachment(itemId, branch, sourceAttachment, resource.toFile().length(), content);
        } catch (final IOException e) {
            throw new FailedMigrationException("Unable to upload GI resource: " + resource.getFileName().toFile(), e);
        }
    }
}
