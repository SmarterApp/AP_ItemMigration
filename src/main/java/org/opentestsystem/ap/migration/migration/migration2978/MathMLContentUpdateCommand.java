package org.opentestsystem.ap.migration.migration.migration2978;

import org.apache.commons.collections4.ListUtils;
import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.ap.common.model.ItemImageResource;
import org.opentestsystem.ap.common.saaif.mapper.model.IatImage;
import org.opentestsystem.ap.common.saaif.mapper.util.MigrationMapperUtil;
import org.opentestsystem.ap.migration.contentupdater.ContentUpdateCommand;
import org.opentestsystem.ap.migration.contentupdater.ContentUpdateCommandResult;

import java.nio.file.Path;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class MathMLContentUpdateCommand extends ContentUpdateCommand {

    private final Path itemSyncDir;

    private final List<IatImage> images;

    public MathMLContentUpdateCommand(List<ItemImageResource> modelImageResources, Path itemSyncDir) {
        this.images = this.mapToIatImage(modelImageResources, itemSyncDir);
        this.itemSyncDir = itemSyncDir;
    }

    @Override
    public ContentUpdateCommandResult applyEnglishContentUpdate(String englishContentHtml) {
        return new ContentUpdateCommandResult(true,
                MigrationMapperUtil.applyMathMLToModelContent(englishContentHtml, itemSyncDir, images));
    }

    @Override
    public ContentUpdateCommandResult applyTranslatedContentUpdate(String language, String translatedContent, String englishContent) {
        String mappedTranslatedContent = translatedContent;
        if (StringUtils.isNotBlank(translatedContent)) {
            ContentUpdateCommandResult commandResult = this.applyEnglishContentUpdate(translatedContent);
            mappedTranslatedContent = commandResult.getUpdatedContent();
        }
        return this.isMathMLMatch(mappedTranslatedContent, englishContent)
            ? new ContentUpdateCommandResult(false, StringUtils.EMPTY)
            : new ContentUpdateCommandResult(true, mappedTranslatedContent);
    }

    boolean isMathMLMatch(String translatedContent, String englishContent) {
        translatedContent = StringUtils.trimToEmpty(translatedContent);
        englishContent = StringUtils.trimToEmpty(englishContent);

        // assume if the translated content starts and ends with MathML then it is just MathML.
        return StringUtils.startsWith(translatedContent, "<math")
            && StringUtils.endsWith(translatedContent, "</math>")
            && StringUtils.contains(englishContent, translatedContent);
    }

    private List<IatImage> mapToIatImage(List<ItemImageResource> imageResources, Path itemSyncDir) {

        Predicate<ItemImageResource> hasProductionFile = i -> Objects.nonNull(i.getProductionFile());

        Function<ItemImageResource, IatImage> toIatImage = i -> {
            String xmlFile = MigrationMapperUtil.findMatchingXmlFile(i.getProductionFile().getFileName(), itemSyncDir);
            return new IatImage(Integer.valueOf(i.getId()), i.getProductionFile().getFileName(), xmlFile);
        };

        // map only the resources with production files
        List<IatImage> images = ListUtils.emptyIfNull(imageResources)
            .stream()
            .filter(hasProductionFile)
            .map(toIatImage)
            .collect(Collectors.toList());

        return images;
    }
}
