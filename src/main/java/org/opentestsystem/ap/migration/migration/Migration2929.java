package org.opentestsystem.ap.migration.migration;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.ListUtils;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreItemManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.model.Glossary;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.glossary.GlossaryDialect;
import org.opentestsystem.ap.common.model.glossary.GlossaryLanguages;
import org.opentestsystem.ap.common.model.glossary.GlossaryTerm;
import org.opentestsystem.ap.common.saaif.mapper.model.SkipMigration;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.MigrationContext;
import org.opentestsystem.ap.migration.util.ApplicationDependencyProvider;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Predicate;

import static org.opentestsystem.ap.common.model.ModelConstants.BranchNames.BRANCH_MASTER;
import static org.opentestsystem.ap.common.model.ModelConstants.Section.SECTION_GLOSSARY;

/**
 * IAT-2929:  After bulk glossary upload containing multiple Filipino and Punjabi defs for a single term, manual edits
 * to that same term result in lost Filipino and Punjabi defs.
 * <p>
 * The key is finding an item with a glossary having terms with more than one dialect associated with it from the same
 * language.  If this is the case the migration re-indexes the dialects.  The dialect's ID does not have a function in
 * TIMS so re-indexing is a safe operation.
 * <p>
 * Only Filipino and Punjabi dialects are affected.  And this only happens if the dialects list has more than one.
 */
@Component
public class Migration2929 extends AbstractMigration {

    public Migration2929(ApplicationDependencyProvider applicationDependencyProvider,
                         ApplicationProperties applicationProperties,
                         DataStoreDataManager dataManager,
                         final DataStoreItemManager dataStoreItemManager,
                         DataStoreUtility dataStoreUtility,
                         DataStoreAttachmentManager attachmentManager) {
        super(applicationDependencyProvider, applicationProperties, dataManager, dataStoreItemManager, dataStoreUtility,
            attachmentManager);
    }

    @Override
    protected boolean shouldMigrateBranch(ItemEntity migratedEntity) {
        return BRANCH_MASTER.equalsIgnoreCase(migratedEntity.getBranchName())
            || SECTION_GLOSSARY.equalsIgnoreCase(migratedEntity.getBranchName());
    }

    @Override
    public ItemEntity migrateEntity(ItemEntity itemEntity, MigrationContext migrationContext) {
        Item item = itemEntity.getItemJson();
        this.checkSkip(item);
        this.reIndexGlossary(item.getGlossary());
        return itemEntity;
    }

    void checkSkip(Item item) {
        if (item.isTutorial()) {
            throw new SkipMigration("item is a tutorial, tutorials don't have glossary");
        }

        boolean dialectMatchFound = false;

        Glossary glossary = item.getGlossary();
        if (Objects.nonNull(glossary)) {
            dialectMatchFound = ListUtils.emptyIfNull(glossary.getTerms())
                .stream()
                .map(GlossaryTerm::getLanguages)
                .anyMatch(t ->
                    CollectionUtils.size(t.filipino.dialects) > 1 || CollectionUtils.size(t.punjabi.dialects) > 1);
        }

        if (!dialectMatchFound) {
            throw new SkipMigration(
                "item glossary has no term languages for Filipino or Punjabi with dialect sizes greater than 1");
        }
    }

    void reIndexGlossary(Glossary glossary) {
        // only want Filipino and Punjabi if they have a dialect list with more than one record
        Predicate<GlossaryLanguages> hasDialectCount = languages ->
            CollectionUtils.size(languages.filipino.dialects) > 1
                || CollectionUtils.size(languages.punjabi.dialects) > 1;

        // re-index Filipino and Punjabi
        Consumer<GlossaryLanguages> reIndexLanguage = languages -> {
            this.reIndexDialects(languages.filipino.dialects);
            this.reIndexDialects(languages.punjabi.dialects);
        };

        // re-index each term
        ListUtils.emptyIfNull(glossary.getTerms()).stream()
            .map(GlossaryTerm::getLanguages)
            .filter(hasDialectCount)
            .forEach(reIndexLanguage);
    }

    private void reIndexDialects(List<GlossaryDialect> dialects) {
        if (CollectionUtils.size(dialects) > 1) {
            for (int i = 0; i < dialects.size(); ++i) {
                dialects.get(i).setId(String.valueOf(i + 1));
            }
        }
    }
}
