package org.opentestsystem.ap.migration.migration;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.ListUtils;
import org.apache.commons.lang3.StringUtils;
import org.gitlab4j.api.models.RepositoryFile;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.gitlab.GitLabSyncManager;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Attachment;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemAudioResource;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.datastore.AbstractDataStoreMigration;
import org.opentestsystem.ap.migration.mapper.IatModelMapperFactory;
import org.opentestsystem.ap.migration.model.SkipMigration;
import org.opentestsystem.ap.migration.util.MigrationFileUtil;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.StandardCopyOption;
import java.util.Base64;
import java.util.List;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static java.lang.String.format;
import static java.util.stream.Collectors.toList;
import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;
import static org.opentestsystem.ap.common.model.ItemConstants.BranchNames.BRANCH_MASTER;
import static org.opentestsystem.ap.common.model.ItemConstants.Section.SECTION_BRAILLE;
import static org.opentestsystem.ap.migration.util.MigrationFileUtil.IMPORT_ZIP_FILENAME;

@Slf4j
@Component
public class Migration2571 extends AbstractDataStoreMigration {

    private static final String BRAILLE_NAMING_PATTERN = "^(stim|item|passage)_(\\d+)_enu_([ue][xc][ntl])" +
            "(_transcript)?\\.(brf|prn)$";

    private static final String BRAILLE_NAMING_PATTERN_INVALID = "^(stim|item|passage)_(\\d+)_enu_(\\w+)_([ue][xc][ntl])" +
            "(_transcript)?\\.(brf|prn)$";

    private static final Pattern BRAILLE_PATTERN = Pattern.compile(BRAILLE_NAMING_PATTERN, Pattern.CASE_INSENSITIVE);

    private static final Pattern BRAILLE_PATTERN_INVALID = Pattern
            .compile(BRAILLE_NAMING_PATTERN_INVALID, Pattern.CASE_INSENSITIVE);


    protected final GitlabClient gitlabClient;
    protected final AppAssembler appAssembler;
    protected final GitLabSyncManager itemBankSyncManager;
    protected final MigrationFileUtil migrationFileUtil;
    protected final IatModelMapperFactory iatModelMapperFactory;

    public Migration2571(ApplicationDependencyProvider applicationDependencyProvider,
                         ApplicationProperties applicationProperties,
                         DataStoreDataManager dataManager,
                         ItemManagerEventProducer eventProducer,
                         DataStoreUtility dataStoreUtility,
                         DataStoreAttachmentManager attachmentManager) {

        super(applicationProperties, dataManager, eventProducer, dataStoreUtility, attachmentManager);

        this.gitlabClient = applicationDependencyProvider.getGitlabClient();
        this.appAssembler = applicationDependencyProvider.getAppAssembler();
        this.itemBankSyncManager = applicationDependencyProvider.getItemBankSyncManager();
        this.migrationFileUtil = applicationDependencyProvider.getMigrationFileUtil();
        this.iatModelMapperFactory = applicationDependencyProvider.getIatModelMapperFactory();
    }

    @Override
    protected boolean shouldMigrateBranch(ItemEntity migratedEntity) {
        String branch = migratedEntity.getBranchName();
        if (BRANCH_MASTER.equalsIgnoreCase(branch) || SECTION_BRAILLE.equalsIgnoreCase(branch)) {
            return true;
        }
        return false;
    }

    @Override
    public ItemEntity migrateEntity(ItemEntity itemEntity) {
        Item item = itemEntity.getItemJson();

        this.check(item);

        Path unzipPath = this.unzipImportZip(item);

        this.makeFilenamesValid(item, unzipPath);

        this.replaceItsId(item, itemEntity.getBranchName(), unzipPath);

        return itemEntity;
    }

    // ------------------------------------------------------------------------
    // Replace ITS ID with new current item ID
    // ------------------------------------------------------------------------

    private void replaceItsId(Item item, String branch, Path srcFolder) {
        List<Path> brailleFiles = this.findBrailleFiles(item.getId(), srcFolder);
        this.replaceItsId(item.getId(), item.getItsId(), branch, brailleFiles);
        this.replaceItsId(item);
    }

    private void replaceItsId(String itemId, String itsId, String branch, List<Path> files) {
        try {
            Path targetFolder = Files.createTempDirectory(itemId);
            for (Path srcFile : files) {
                // assume the file does not need renamed
                Path targetFile = targetFolder.resolve(srcFile.toFile().getName());
                // check if it needs renamed
                if (!srcFile.toFile().getName().contains(itemId)) {
                    // rename the file replacing ITS id with item ID
                    targetFile = targetFolder.resolve(srcFile.toFile().getName().replace(itsId, itemId));
                }
                Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);
            }
            itemBankSyncManager.syncAttachmentsToDataStore(itemId, branch, targetFolder);
            if (!SECTION_BRAILLE.equalsIgnoreCase(branch)) {
                itemBankSyncManager.syncAttachmentsToDataStore(itemId, SECTION_BRAILLE, targetFolder);
            }
        } catch (IOException e) {
            throw new SkipMigration(
                    format("Item %s - error setting item ID for ITS ID on braille file - %s", itemId, e.getMessage()));
        }
    }

    private void replaceItsId(Item item) {
        List<Attachment> brailleFiles = item.getBraille().getAttachments();
        if (isNotEmpty(brailleFiles)) {
            for (Attachment attachment : brailleFiles) {
                // make sure the file name isn't already correct
                if (!attachment.getFileName().contains(item.getId())) {
                    attachment.setFileName(attachment.getFileName().replace(item.getItsId(), item.getId()));
                }
            }
        }
    }

    // ------------------------------------------------------------------------
    // Correct invalid file names
    // ------------------------------------------------------------------------

    private void makeFilenamesValid(Item item, Path srcFolder) {
        List<Path> brailleFiles = this.findBrailleFiles(item.getId(), srcFolder);
        this.makeFilenamesValid(item, brailleFiles);
    }

    private void makeFilenamesValid(Item item, List<Path> files) {
        this.makeFilenamesValid(item);
        this.makeFilenamesValid(item.getId(), files);
    }

    private void makeFilenamesValid(Item item) {
        List<Attachment> brailleFiles = item.getBraille().getAttachments();
        if (isNotEmpty(brailleFiles)) {
            for (Attachment attachment : brailleFiles) {
                if (this.isInvalid(attachment.getFileName())) {
                    attachment.setFileName(this.makeValid(attachment.getFileName()));
                }
            }
        }
    }

    private void makeFilenamesValid(String itemId, List<Path> files) {
        for (Path file : files) {
            Path parent = file.getParent();
            String filename = file.toFile().getName();
            if (this.isInvalid(filename)) {
                Path correctedFile = parent.resolve(this.makeValid(filename));
                try {
                    Files.copy(file, correctedFile, StandardCopyOption.REPLACE_EXISTING);
                } catch (IOException e) {
                    log.warn(format("Item %s - error correcting invalid braille file %s - %s",
                            itemId, filename, e.getMessage()));
                }
            } else if (!this.isValid(filename)) {
                log.warn(format(
                        "Item %s - encountered braille file that does not match a known naming pattern",
                        itemId, filename));
            }
        }
    }

    private String makeValid(String filename) {
        Matcher matcher = BRAILLE_PATTERN_INVALID.matcher(filename);
        if (matcher.find()) {
            if (StringUtils.isNotBlank(matcher.group(5))) {
                return String.format("%s_%s_enu_%s%s.%s",
                        matcher.group(1), matcher.group(2), matcher.group(4), matcher.group(5), matcher.group(6));
            } else {
                return String.format("%s_%s_enu_%s.%s",
                        matcher.group(1), matcher.group(2), matcher.group(4), matcher.group(6));
            }
        }
        return filename;
    }

    // ------------------------------------------------------------------------
    // Private helpers
    // ------------------------------------------------------------------------

    private List<Path> findBrailleFiles(String itemId, Path srcFolder) {
        FileSystem fileSystem = FileSystems.getDefault();
        PathMatcher fileFilter = fileSystem.getPathMatcher("glob:**.{brf,prn}");
        try {
            return ListUtils.emptyIfNull(Files.walk(srcFolder).filter(fileFilter::matches).collect(toList()));
        } catch (IOException e) {
            throw new SkipMigration(format("Item %s - error finding braille files - %s", itemId, e.getMessage()));
        }
    }

    private Path unzipImportZip(Item item) {
        Optional<RepositoryFile> importZip = gitlabClient.lookUpFileOnMaster(item.getId(), IMPORT_ZIP_FILENAME);

        Path unzipPath = null;

        // rename the files on disk
        if (importZip.isPresent()) {
            RepositoryFile repoFile = importZip.get();
            if (StringUtils.isNotBlank(repoFile.getContent())) {
                // unzip to a random path
                Path expandedZip = migrationFileUtil.getExpandedImportZipFile(
                        item.getId(), Base64.getDecoder().decode(repoFile.getContent()));

                // import.zip can contain multiple directories or none at all,
                // identify the imported item source directory
                unzipPath = MigrationFileUtil.getItemSourceDir(expandedZip, item.getItsId());
            }
        }
        return unzipPath;
    }

    private boolean isInvalid(String filename) {
        return BRAILLE_PATTERN_INVALID.matcher(filename).matches();
    }

    private boolean isValid(String filename) {
        return BRAILLE_PATTERN.matcher(filename).matches();
    }

    private void check(Item item) {
        if (StringUtils.isBlank(item.getItsId())) {
            throw new SkipMigration(format("Item %s has no ITS ID", item.getId()));
        }
    }
}
