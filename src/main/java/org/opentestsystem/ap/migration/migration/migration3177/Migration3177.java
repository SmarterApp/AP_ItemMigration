package org.opentestsystem.ap.migration.migration.migration3177;

import lombok.extern.slf4j.Slf4j;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ModelConstants;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.common.saaif.mapper.model.ImportItem;
import org.opentestsystem.ap.common.saaif.mapper.model.SkipMigration;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.contentupdater.ContentUpdater;
import org.opentestsystem.ap.migration.migration.AbstractImportMigration;
import org.opentestsystem.ap.migration.model.ItemMerge;
import org.opentestsystem.ap.migration.util.ApplicationDependencyProvider;
import org.springframework.stereotype.Component;

import java.nio.file.Path;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import static org.opentestsystem.ap.common.model.ModelConstants.ItemType.TYPE_STIM;
import static org.opentestsystem.ap.common.model.ModelConstants.ItemType.TYPE_TUT;

@Slf4j
@Component
public class Migration3177 extends AbstractImportMigration {

    public Migration3177(ApplicationProperties applicationProperties,
                         DataStoreDataManager dataManager,
                         ItemManagerEventProducer eventProducer,
                         DataStoreUtility dataStoreUtility,
                         DataStoreAttachmentManager dataStoreAttachmentManager,
                         ApplicationDependencyProvider applicationDependencyProvider) {
        super(applicationProperties, dataManager, eventProducer, dataStoreUtility,
                dataStoreAttachmentManager, applicationDependencyProvider);
    }

    @Override
    protected ItemMerge mergeItem(Item dataStoreItem, Item mappedItem, Path itemSyncDir) {
        // Do nothing with the dataStoreItem. Merge work occurs in mergeItemFromImportData
        return new ItemMerge(dataStoreItem, itemSyncDir, DO_NOT_SYNC_ATTACHMENTS);
    }

    @Override
    protected ItemMerge mergeItemFromImportData(ItemMerge itemMerge, ImportItem importItem, Path itemSyncDir) {
        TtsContentUpdateCommand updateCommand = new TtsContentUpdateCommand(importItem.getItemRelease());
        ContentUpdater contentUpdater = this.contentUpdaterFactory.getContentUpdaterForType(itemMerge.getMergedItem().getType());
        contentUpdater.updateContent(itemMerge.getMergedItem(), updateCommand);
        return new ItemMerge(itemMerge.getMergedItem(), itemSyncDir, false);
    }

    @Override
    protected void checkSkipMigration(ItemEntity itemEntity) {
        if (TYPE_TUT.equals(
                itemEntity.getItemJson().getType())) {
            throw new SkipMigration(String.format("Item %s is a Tutorial. No updates necessary", itemEntity.getItemId()));
        }
    }

    @Override
    protected void checkSkipMigration(ImportItem importItem) {
        boolean ttsExists = false;
        if (isStim(importItem.getItemRelease())) {
            ttsExists = doPassageTTSElementsExist(importItem.getItemRelease().getPassage().getContent());
        } else if (isItem(importItem.getItemRelease())) {
            ttsExists = doItemTTSElementsExist(importItem.getItemRelease().getItem().getContent());
        }
        if (!ttsExists) {
            throw new SkipMigration(
                    String.format("Item %s has no TTS <accessElement> . No updates necessary", importItem.getItemProps().getItemId()));
        }
    }

    @Override
    protected Collection<String> getEditedSectionsBlockingMigration() {
        return Collections.emptyList();
    }

    /**
     * Checks if the import ItemRelease.Passage contains <accessElement></accessElement> elements
     *
     * @param contentList    List of ItemRelease.Passage.Content
     * @return               when true, the ItemRelease.Passage.Content contains <accessElement></accessElement>
     */
    private boolean doPassageTTSElementsExist(List<ItemRelease.Passage.Content> contentList) {
        Optional<ItemRelease.Passage.Content> englishContent =
                contentList
                        .stream()
                        .filter(content -> content.getLanguage().equals(ModelConstants.ItemLanguage.LANG_ENU))
                        .findFirst();
        return englishContent.filter(saaifContent -> Objects.nonNull(saaifContent.getApipAccessibility()
                .getAccessibilityInfo().getAccessElement())).isPresent();
    }

    /**
     * Checks if the import ItemRelease.Item contains <accessElement></accessElement> elements
     *
     * @param contentList    List of ItemRelease.Item.Content
     * @return               when true, the ItemRelease.Item.Content contains <accessElement></accessElement>
     */
    private boolean doItemTTSElementsExist(List<ItemRelease.Item.Content> contentList) {
        Optional<ItemRelease.Item.Content> englishContent =
                contentList
                        .stream()
                        .filter(content -> content.getLanguage().equals(ModelConstants.ItemLanguage.LANG_ENU))
                        .findFirst();
        return englishContent.filter(saaifContent -> Objects.nonNull(saaifContent.getApipAccessibility()
                .getAccessibilityInfo().getAccessElement())).isPresent();
    }

    private boolean isStim(ItemRelease release) {
        return Objects.nonNull(release.getPassage());
    }

    private boolean isItem(ItemRelease release) {
        return Objects.nonNull(release.getItem());
    }

}
