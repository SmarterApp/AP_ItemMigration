package org.opentestsystem.ap.migration.migration;

import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemConstants;
import org.opentestsystem.ap.common.model.MiItem;
import org.opentestsystem.ap.common.model.Table;
import org.opentestsystem.ap.common.saaif.model.SkipMigration;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.ItemMerge;
import org.springframework.stereotype.Component;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Component
public class Migration2799 extends AbstractImportMigration {
    public Migration2799(final ApplicationProperties applicationProperties, final DataStoreDataManager dataManager, final ItemManagerEventProducer eventProducer, final DataStoreUtility dataStoreUtility, final DataStoreAttachmentManager dataStoreAttachmentManager, final ApplicationDependencyProvider applicationDependencyProvider) {
        super(applicationProperties, dataManager, eventProducer, dataStoreUtility, dataStoreAttachmentManager, applicationDependencyProvider, ItemConstants.ItemType.TYPE_MI);
    }

    @Override
    protected ItemMerge mergeItem(final Item dataStoreItem, final Item mappedItem, final Path itemSyncDir) {
        final String itemId = dataStoreItem.getId();
        MiItem miItem = (MiItem) dataStoreItem;
        MiItem miMappedItem = (MiItem) mappedItem;

        Table mappedTable = miMappedItem.getCore().getEn().getTable();
        Table entityTable = miItem.getCore().getEn().getTable();

        if(mappedTable == null || entityTable == null) {
            throw new SkipMigration("Migration 2799: Tables don't match for item id %s", dataStoreItem.getId());
        }

        Map<Integer, List<Integer>> correctAnswers = new HashMap<>();
        for (int rowNumber = 0; rowNumber < mappedTable.getRows().size(); rowNumber++) {
            Table.Row row = mappedTable.getRows().get(rowNumber);
            for (int cellNumber = 0; cellNumber < row.getCells().size(); cellNumber++) {
                Table.Cell cell = row.getCells().get(cellNumber);

                if(cell.isCorrectAnswer()) {
                    if(!correctAnswers.containsKey(rowNumber)) {
                        correctAnswers.put(rowNumber, new ArrayList<>());
                    }

                    correctAnswers.get(rowNumber).add(cellNumber);
                }
            }
        }

        for (Map.Entry<Integer, List<Integer>> entry: correctAnswers.entrySet()) {
            if(entityTable.getRows().size() - 1 < entry.getKey()) {
                throw new SkipMigration("Migration2799: Number of rows don't match between mapped table and entity table for item %s", itemId);
            }

            Table.Row entityTableRow = entityTable.getRows().get(entry.getKey());

            for(Integer cellNumber : entry.getValue()) {
                if(entityTableRow.getCells().size() - 1 < cellNumber) {
                    throw new SkipMigration("Migration2799: Number of cells don't match between mapped table and entity table for item %s", itemId);
                }

                entityTableRow.getCells().get(cellNumber).setValue(true);
            }
        }

        return new ItemMerge(dataStoreItem, itemSyncDir, false);
    }

    @Override
    protected Collection<String> getEditedSectionsBlockingMigration() {
        return Collections.singleton(ItemConstants.Section.SECTION_CORE);
    }
}
