package org.opentestsystem.ap.migration.migration;

import org.gitlab4j.api.models.Project;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.gitlab.GitLabSyncManager;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.*;
import org.opentestsystem.ap.common.model.content.McItemContent;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.datastore.AbstractDataStoreMigration;
import org.opentestsystem.ap.migration.mapper.IatModelMapper;
import org.opentestsystem.ap.migration.mapper.IatModelMapperFactory;
import org.opentestsystem.ap.migration.model.ItemMappingProperties;
import org.opentestsystem.ap.migration.model.ItemMappingResult;
import org.opentestsystem.ap.migration.model.SkipMigration;
import org.opentestsystem.ap.migration.util.MigrationFileUtil;
import org.opentestsystem.ap.migration.util.MigrationMapperUtil;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.concurrent.atomic.AtomicInteger;

import static org.opentestsystem.ap.common.model.ItemConstants.BranchNames.BRANCH_MASTER;

@Component
public class Migration2619 extends AbstractDataStoreMigration {

    private final GitlabClient gitlabClient;
    private final AppAssembler appAssembler;
    private final GitLabSyncManager itemBankSyncManager;
    private final MigrationFileUtil migrationFileUtil;
    private final IatModelMapperFactory iatModelMapperFactory;

    public Migration2619(final ApplicationDependencyProvider applicationDependencyProvider,
                         final ApplicationProperties applicationProperties,
                         final DataStoreDataManager dataManager,
                         final ItemManagerEventProducer eventProducer,
                         final DataStoreUtility dataStoreUtility,
                         final DataStoreAttachmentManager dataStoreAttachmentManager,
                         final MigrationFileUtil migrationFileUtil,
                         final IatModelMapperFactory iatModelMapperFactory) {
        super(applicationProperties, dataManager, eventProducer, dataStoreUtility, dataStoreAttachmentManager);
        this.gitlabClient = applicationDependencyProvider.getGitlabClient();
        this.appAssembler = applicationDependencyProvider.getAppAssembler();
        this.itemBankSyncManager = applicationDependencyProvider.getItemBankSyncManager();
        this.migrationFileUtil = migrationFileUtil;
        this.iatModelMapperFactory = iatModelMapperFactory;
    }

    @Override
    protected ItemEntity migrateEntity(ItemEntity itemEntity) {
        //Only apply to imported Mc and Ms items
        try {
            if (Integer.parseInt(itemEntity.getItemId()) < 200000 &&
                    (itemEntity.getItemJson().getType().equals(ItemConstants.ItemType.TYPE_MC))) {
                Project project = gitlabClient.lookupProjectByName(itemEntity.getItemId());
                applyMcMsOptionMigration(project, itemEntity);
            } else {
                throw new SkipMigration(String.format("Item %s is not imported.  No updates necessary", itemEntity.getItemId()));
            }
        } catch (Exception ex) {
            throw new SkipMigration(String.format("Unable to migrate item %s. %s", itemEntity.getItemId(), ex.getMessage()));
        }
        return itemEntity;
    }

    private void applyMcMsOptionMigration(Project project, ItemEntity itemEntity) throws Exception {
        // Pull import.zip from the items master branch. Expand import.zip to a temporary directory
        Path expandedZip = migrationFileUtil.getExpandedImportZipFile(itemEntity.getItemId(),
                gitlabClient.getFile(project.getId(), MigrationFileUtil.IMPORT_ZIP_FILENAME, BRANCH_MASTER));

        if (expandedZip.toFile().exists()) {
            // import.zip can contain multiple directories or none at all. Identify the imported item source directory
            Path itemSourceDir = MigrationFileUtil.getItemSourceDir(expandedZip, itemEntity.getItemJson().getItsId());
            // Find the main item file in the source location
            File itemFile = MigrationFileUtil.getItemFileInDirectory(itemSourceDir, itemEntity.getItemJson().getItsId());

            if (itemFile != null) {
                // Load imported item xml data
                final ItemRelease itemRelease = this.appAssembler.getSaaifAssembler()
                        .readXmlFromFile(itemFile.toPath());

                String answerValue = MigrationMapperUtil.getAttributeValue(itemRelease, "itm_att_Answer Key");

                // Create temporary directory to store attachment files that might need synching to S3
                Path itemSyncDir = Files.createTempDirectory(itemEntity.getItemId());

                itemRelease.getItem().getContent().forEach(content -> {
                    String language = content.getLanguage();

                    // Check if <rationaleoptlist /> is empty
                    if (content.getRationaleoptlist().getRationale().size() == 0) {

                        // Create item-specific mapper
                        final IatModelMapper mapper = iatModelMapperFactory.newModelMapper(itemEntity.getItemJson().getType());

                        McItem mcItem = (McItem) itemEntity.getItemJson();
                        McItemContent itemContent;
                        if (language.equals(ItemConstants.ItemLanguage.LANG_ENU)) {
                            itemContent = mcItem.getCore().getEn();
                        } else {
                            itemContent = mcItem.getTranslations().getEsp();
                        }

                        AtomicInteger index = new AtomicInteger(0);

                        ItemMappingProperties mappingProperties = new ItemMappingProperties(
                                mcItem.getAudio().getAudioResources().size(),
                                mcItem.getImages().getImageResources().size());

                        for (ItemRelease.Item.Content.Optionlist.Option option : content.getOptionlist().getOption()) {
                            mapper.mapSingleRichTextContent(option.getVal(),
                                    content.getApipAccessibility(),
                                    mappingProperties);

                            itemContent.getOptions().add(
                                    ItemOption.newItemOption(mappingProperties.getContent(),
                                            "",
                                            answerValue.equals(MigrationMapperUtil.getCapitalLetterFromInt(index.get())),
                                            ""));

                            index.getAndIncrement();
                        }

                        //Process Image Resources
                        mapper.processImageResources(mappingProperties,
                                mcItem,
                                itemSourceDir.toString(),
                                itemSyncDir.toString(),
                                null);

                        itemBankSyncManager.syncAttachmentsToDataStore(itemEntity.getItemId(), BRANCH_MASTER, itemSyncDir);
                    }
                });

            } else {
                throw new Exception(String.format("Unable to find item file in %s for item %s", itemSourceDir, itemEntity.getItemId()));
            }
        }
    }
}