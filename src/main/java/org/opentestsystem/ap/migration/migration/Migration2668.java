package org.opentestsystem.ap.migration.migration;

import com.google.common.collect.Sets;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.ListUtils;
import org.apache.commons.lang3.StringUtils;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.HasOptions;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemImageResource;
import org.opentestsystem.ap.common.model.ItemOption;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.ItemMerge;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

import static org.opentestsystem.ap.common.model.ItemConstants.ItemType.TYPE_MC;
import static org.opentestsystem.ap.common.model.ItemConstants.ItemType.TYPE_MS;
import static org.opentestsystem.ap.common.model.ItemConstants.Section.SECTION_TRANSLATIONS;

/**
 * IAT-2668: Imported items have duplicated images in English and Spanish options MC, MS.
 */
@Slf4j
@Component
public class Migration2668 extends AbstractImportMigration {

    public Migration2668(final ApplicationProperties applicationProperties,
                         final DataStoreDataManager dataManager,
                         final ItemManagerEventProducer eventProducer,
                         final DataStoreUtility dataStoreUtility,
                         final DataStoreAttachmentManager dataStoreAttachmentManager,
                         final ApplicationDependencyProvider applicationDependencyProvider) {
        super(applicationProperties, dataManager, eventProducer, dataStoreUtility, dataStoreAttachmentManager,
            applicationDependencyProvider, TYPE_MC, TYPE_MS);
    }

    @Override
    protected ItemMerge mergeItem(final Item dataStoreItem, final Item mappedItem, final Path itemSyncDir) {
        // MC and MS implement this interface
        HasOptions englishContent = (HasOptions) dataStoreItem.getCore().getEn();
        HasOptions spanishContent = (HasOptions) dataStoreItem.getTranslations().getEsp();

        Map<Integer, List<String>> parsedEnglish = this.parseItemOptions(
            englishContent.getOptions(), dataStoreItem.getImages().getImageResources(), itemSyncDir);

        Map<Integer, List<String>> parsedSpanish = this.parseItemOptions(
            spanishContent.getOptions(), dataStoreItem.getImages().getImageResources(), itemSyncDir);

        this.removeDuplicateItemOptions(spanishContent.getOptions(), parsedEnglish, parsedSpanish);

        return new ItemMerge(dataStoreItem, itemSyncDir, DO_NOT_SYNC_ATTACHMENTS);
    }

    @Override
    protected Collection<String> getEditedSectionsBlockingMigration() {
        return Sets.newHashSet(SECTION_TRANSLATIONS);
    }

    /**
     * The spanish options are adjusted if they match the english options.  The match is finding the file checksums in
     * both the english and spanish options.  Every file referenced in the options is given a check sum.  Each option in
     * the english list is compared to its equivalent in the spanish list, so english option 2 is compared to spanish
     * option 2.  If both options have an equal checksum list then the spanish item option's text is set to empty
     * string.
     *
     * @param spanishOptions
     * @param english
     * @param spanish
     */
    protected void removeDuplicateItemOptions(List<ItemOption> spanishOptions,
                                              Map<Integer, List<String>> english,
                                              Map<Integer, List<String>> spanish) {
        spanishOptions = ListUtils.emptyIfNull(spanishOptions);

        for (int i = 0; i < spanishOptions.size(); ++i) {
            List<String> englishList = english.get(Integer.valueOf(i));
            List<String> spanishList = spanish.get(Integer.valueOf(i));
            if (CollectionUtils.isNotEmpty(englishList) && CollectionUtils.isNotEmpty(spanishList)) {
                if (ListUtils.isEqualList(englishList, spanishList)) {
                    log.info("duplicate spanish image content found in the MC/MS options");
                    spanishOptions.get(i).setText(StringUtils.EMPTY);
                }
            }
        }
    }

    /**
     * For every option an entry is put in the map.  The key of the map is the index the option is in its list.  The
     * value is a list of checksums for all the files referenced in the options.
     *
     * @param itemOptions    The options to get a list of checksums for.
     * @param imageResources The reference to the image file names.
     * @param fileSyncDir    The folder to find the files in.
     * @return A map of file check sums associated with the item options.
     */
    protected Map<Integer, List<String>> parseItemOptions(List<ItemOption> itemOptions,
                                                          List<ItemImageResource> imageResources,
                                                          Path fileSyncDir) {
        Map<Integer, List<String>> map = new HashMap<>();
        for (int i = 0; i < itemOptions.size(); ++i) {
            List<String> fileChecksums = this.getItemOptionImageFileChecksums(
                itemOptions.get(i), imageResources, fileSyncDir);
            // every option should be keyed in the map
            map.put(Integer.valueOf(i), fileChecksums);
        }
        return map;
    }

    /**
     * Returns a list of checksums run against the files referenced in the item option.  The files are expected to be in
     * the sync dir.
     *
     * @param itemOption     The option to parse for files.
     * @param imageResources A list of file names.
     * @param fileSyncDir    The folder to find the files in.
     * @return A list of checksums.
     */
    protected List<String> getItemOptionImageFileChecksums(ItemOption itemOption,
                                                           List<ItemImageResource> imageResources,
                                                           Path fileSyncDir) {
        return this.findItemOptionImageFilenames(itemOption, imageResources)
            .stream()
            .map(file -> this.getFileCheckSum(fileSyncDir, file))
            .collect(Collectors.toList());
    }

    /**
     * Given a file run an MD5 checksum on it.
     *
     * @param fileSyncDir The folder the file is located in.
     * @param filename    The name of the file.
     * @return An MD5 checksum of the file.
     */
    protected String getFileCheckSum(Path fileSyncDir, String filename) {
        String md5 = StringUtils.EMPTY;
        try (InputStream is = Files.newInputStream(fileSyncDir.resolve(filename))) {
            md5 = org.apache.commons.codec.digest.DigestUtils.md5Hex(is);
        } catch (IOException e) {
            log.warn("Error getting checksum for file " + filename, e);
        }
        return md5;
    }

    /**
     * Find the file names referenced in the item option.
     *
     * @param itemOption
     * @param imageResources
     * @return
     */
    protected List<String> findItemOptionImageFilenames(ItemOption itemOption, List<ItemImageResource> imageResources) {
        List<String> fileNames = new ArrayList<>();

        this.parseImageResourceIds(itemOption).stream().forEach(id -> {
            imageResources.stream()
                .filter(resource -> resource.getId().equalsIgnoreCase(id))
                .findFirst()
                .ifPresent(resource -> fileNames.add(resource.getProductionFile().getFileName()));
        });

        return fileNames;
    }

    /**
     * Find the image resource IDs referenced in the item option.  If there is text in the item option an empty list is
     * returned.
     *
     * @param optionText
     * @return
     */
    protected List<String> parseImageResourceIds(ItemOption optionText) {
        List<String> parsedOption = new ArrayList<>();
        if (Objects.nonNull(optionText) && StringUtils.isNotBlank(optionText.getText())) {
            Document document = Jsoup.parse(optionText.getText());
            String text = document.body().text();
            Elements allElements = document.getElementsByTag("img");
            if (StringUtils.isBlank(text)) {
                for (Element element : allElements) {
                    parsedOption.add(element.attr("data-iat-image-resource-id"));
                }
            }
        }
        return parsedOption;
    }

}
