package org.opentestsystem.ap.migration.migration;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.ListUtils;
import org.apache.commons.lang3.StringUtils;
import org.gitlab4j.api.models.RepositoryFile;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.gitlab.GitLabSyncManager;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.StimItem;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.datastore.AbstractDataStoreMigration;
import org.opentestsystem.ap.migration.mapper.IatModelMapperFactory;
import org.opentestsystem.ap.migration.mapper.StimModelMapper;
import org.opentestsystem.ap.migration.model.ItemMappingProperties;
import org.opentestsystem.ap.migration.model.SkipMigration;
import org.opentestsystem.ap.migration.util.MigrationFileUtil;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.StandardCopyOption;
import java.util.Base64;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static java.lang.String.format;
import static org.opentestsystem.ap.common.model.ItemConstants.BranchNames.BRANCH_MASTER;
import static org.opentestsystem.ap.common.model.ItemConstants.ItemType.TYPE_STIM;
import static org.opentestsystem.ap.common.model.ItemConstants.Section.SECTION_AUDIO;
import static org.opentestsystem.ap.common.model.ItemConstants.Section.SECTION_CORE;
import static org.opentestsystem.ap.migration.util.MigrationFileUtil.IMPORT_ZIP_FILENAME;

@Slf4j
@Component
public class Migration2657 extends AbstractDataStoreMigration {

    private static final String AUDIO_NAMING_PATTERN = "^(stim|item|passage)_(\\w+).*\\.(m4a|ogg)$";

    private static final Pattern AUDIO_PATTERN = Pattern.compile(AUDIO_NAMING_PATTERN, Pattern.CASE_INSENSITIVE);

    protected final GitlabClient gitlabClient;
    protected final AppAssembler appAssembler;
    protected final GitLabSyncManager itemBankSyncManager;
    protected final MigrationFileUtil migrationFileUtil;
    protected final IatModelMapperFactory iatModelMapperFactory;

    public Migration2657(ApplicationDependencyProvider applicationDependencyProvider,
                         ApplicationProperties applicationProperties,
                         DataStoreDataManager dataManager,
                         ItemManagerEventProducer eventProducer,
                         DataStoreUtility dataStoreUtility,
                         DataStoreAttachmentManager attachmentManager) {

        super(applicationProperties, dataManager, eventProducer, dataStoreUtility, attachmentManager);

        this.gitlabClient = applicationDependencyProvider.getGitlabClient();
        this.appAssembler = applicationDependencyProvider.getAppAssembler();
        this.itemBankSyncManager = applicationDependencyProvider.getItemBankSyncManager();
        this.migrationFileUtil = applicationDependencyProvider.getMigrationFileUtil();
        this.iatModelMapperFactory = applicationDependencyProvider.getIatModelMapperFactory();
    }

    @Override
    protected boolean shouldMigrateBranch(ItemEntity migratedEntity) {
        if (Objects.isNull(migratedEntity) || Objects.isNull(migratedEntity.getBranchName())) {
            return false;
        }
        String branch = migratedEntity.getBranchName();
        if (BRANCH_MASTER.equalsIgnoreCase(branch)
                || SECTION_AUDIO.equalsIgnoreCase(branch)
                || SECTION_CORE.equalsIgnoreCase(branch)) {
            return true;
        }
        return false;
    }

    @Override
    public ItemEntity migrateEntity(ItemEntity itemEntity) {
        Item item = itemEntity.getItemJson();
        check(item);

        StimItem stim = (StimItem) item;
        checkAudio(stim);

        remapStimPrompt(stim, itemEntity.getBranchName());

        return itemEntity;
    }

    private StimItem remapStimPrompt(StimItem stim, String branch) {
        if (StringUtils.isBlank(stim.getItsId())) {
            throw new SkipMigration(format("Stim %s has no ITS ID", stim.getId()));
        }

        Optional<RepositoryFile> importZip = gitlabClient.lookUpFileOnMaster(stim.getId(), IMPORT_ZIP_FILENAME);

        importZip.ifPresent(repoFile -> {
            if (StringUtils.isNotBlank(repoFile.getContent())) {

                Path expandedZip = migrationFileUtil.getExpandedImportZipFile(
                        stim.getId(), Base64.getDecoder().decode(repoFile.getContent()));


                // import.zip can contain multiple directories or none at all,
                // identify the imported item source directory
                Path itemSourceDir = MigrationFileUtil.getItemSourceDir(expandedZip, stim.getItsId());

                // Find the main item file in the source location
                File itemFile = MigrationFileUtil.getItemFileInDirectory(itemSourceDir, stim.getItsId());

                if (itemFile != null) {
                    try {
                        // Create temporary directory to store attachment files that might need syncing to S3
                        Path itemSyncDir = Files.createTempDirectory(stim.getId());

                        // Load imported item xml data
                        final ItemRelease itemRelease = this.appAssembler.getSaaifAssembler()
                                .readXmlFromFile(itemFile.toPath());

                        StimModelMapper mapper = (StimModelMapper) this.iatModelMapperFactory.newModelMapper(TYPE_STIM);

                        ItemMappingProperties mappingProperties = new ItemMappingProperties(
                                stim.getAudio().getAudioResources().size(),
                                stim.getImages().getImageResources().size());

                        mapper.mapSingleRichTextContent(
                                itemRelease.getPassage().getContent().get(0).getStem(),
                                itemRelease.getPassage().getContent().get(0).getApipAccessibility(),
                                mappingProperties);

                        stim.getCore().getEn().setContent(mappingProperties.getContent());

                        // m4a files are not always referenced in the XML
                        // here we make sure those m4a files get in the datastore
                        this.copyAudioFiles(stim.getId(), itemSourceDir, itemSyncDir);

                        //Process Image Resources
                        mapper.processImageResources(mappingProperties,
                                stim,
                                itemSourceDir.toString(),
                                itemSyncDir.toString());

                        //Process Audio Resources
                        mapper.processAudioResources(mappingProperties,
                                stim,
                                itemSourceDir.toString(),
                                itemSyncDir.toString());

                        if (this.shouldSyncAudioFilesToS3(branch)) {
                            itemBankSyncManager
                                    .syncAttachmentsToDataStore(stim.getId(), branch, itemSyncDir);
                        }
                    } catch (IOException ioex) {
                        throw new SystemException(ioex);
                    }
                } else {
                    throw new SystemException(
                            format("Unable to find item file in %s for item %s", itemSourceDir, stim.getId()));
                }

            }
        });

        return stim;
    }

    protected void check(Item item) {
        if (!this.isImportedItem(item.getId())) {
            throw new SkipMigration(format("Item %s is not an imported item", item.getId()));
        }
        if (!StringUtils.equalsIgnoreCase(item.getType(), TYPE_STIM)) {
            throw new SkipMigration(format("Item %s is not a stim", item.getId()));
        }
    }

    void checkAudio(StimItem stim) {
        List<String> audioFileNames = this.getAudioFileNames(stim.getCore().getEn().getContent());

        if (CollectionUtils.isEmpty(audioFileNames)) {
            throw new SkipMigration(format("Stim %s does not have any anchor tag audio references", stim.getId()));
        }

        List<Boolean> validNamesCheck = audioFileNames.stream().map(this::isValidAudioFileName)
                .collect(Collectors.toList());

        if (validNamesCheck.contains(Boolean.TRUE)) {
            // there is at least one anchor tag referencing a valid audio file name
            return;
        } else {
            throw new SkipMigration(
                    format(
                            "Stim %s has anchor tags but none have a valid audio file name %s",
                            stim.getId(),
                            audioFileNames));
        }
    }

    List<String> getAudioFileNames(String content) {
        Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        List<String> audioFileNames = doc.getElementsByTag("a").stream()
                .map(anchor -> StringUtils.lowerCase(anchor.attr("href")))
                .collect(Collectors.toList());

        return audioFileNames;
    }

    private void copyAudioFiles(String itemId, Path srcFolder, Path targetFolder) {
        FileSystem fileSystem = FileSystems.getDefault();
        PathMatcher fileFilter = fileSystem.getPathMatcher("glob:**.{ogg,m4a}");
        try {
            final List<Path> audioFiles = ListUtils.emptyIfNull(Files.walk(srcFolder)
                    .filter(fileFilter::matches)
                    .collect(Collectors.toList()));

            for (Path srcFile : audioFiles) {
                Path targetFile = targetFolder.resolve(srcFile.toFile().getName().toLowerCase());
                Files.copy(srcFile, targetFile, StandardCopyOption.REPLACE_EXISTING);
            }

        } catch (IOException e) {
            throw new SkipMigration(format("Item %s - error copying audio files - %s", itemId, e.getMessage()));
        }
    }

    private boolean isValidAudioFileName(String fileName) {
        Matcher matcher = AUDIO_PATTERN.matcher(fileName);
        return matcher.matches();
    }

    private boolean shouldSyncAudioFilesToS3(String branch) {
        return (BRANCH_MASTER.equalsIgnoreCase(branch) || SECTION_AUDIO.equalsIgnoreCase(branch)) ? true : false;
    }
}
