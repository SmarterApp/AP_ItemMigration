package org.opentestsystem.ap.migration.migration;

import org.apache.commons.collections4.MapUtils;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreItemManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.model.ModelConstants;
import org.opentestsystem.ap.common.saaif.mapper.model.SkipMigration;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.MigrationContext;
import org.opentestsystem.ap.migration.util.ApplicationDependencyProvider;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

import static org.apache.commons.lang3.StringUtils.defaultString;
import static org.apache.commons.lang3.StringUtils.isBlank;

@Component
public class Migration2360 extends AbstractMigration {
    private static final Map<String, String> invalidScoringEngineMap = new HashMap<>();


    public Migration2360(final ApplicationDependencyProvider applicationDependencyProvider,
                         final ApplicationProperties applicationProperties,
                         final DataStoreDataManager dataManager,
                         final DataStoreUtility dataStoreUtility,
                         final DataStoreAttachmentManager dataStoreAttachmentManager,
                         final DataStoreItemManager dataStoreItemManager) {
        super(applicationDependencyProvider, applicationProperties, dataManager, dataStoreItemManager, dataStoreUtility, dataStoreAttachmentManager);

        // Map invalid to correct values
        invalidScoringEngineMap.put("Automatic with Key", "AutomaticWithKey");
        invalidScoringEngineMap.put("Automatic with Key(s)", "AutomaticWithKeys");
        invalidScoringEngineMap.put("Automatic with Machine Rubric", "AutomaticWithRubric");
    }

    @Override
    protected ItemEntity migrateEntity(ItemEntity itemEntity, MigrationContext migrationContext) {
        if (ModelConstants.ItemType.TYPE_TUT.equalsIgnoreCase(itemEntity.getItemJson().getType())) {
            throw new SkipMigration("item is type TUT, metadata does not apply");
        }

        String scoringEngine = itemEntity.getItemJson().getCore().getMetadata().getScoringEngine();

        if (isBlank(scoringEngine) || !isInvalidScoringEngine(scoringEngine)) {
            throw new SkipMigration("Migration2360: scoring engine set to a valid value so no need to run migration");
        }

        itemEntity.getItemJson().getCore().getMetadata()
                .setScoringEngine(
                        MapUtils.getString(invalidScoringEngineMap, scoringEngine, defaultString(scoringEngine)));

        return itemEntity;
    }

    private boolean isInvalidScoringEngine(String scoringEngine) {
        return invalidScoringEngineMap.containsKey(scoringEngine);
    }
}
