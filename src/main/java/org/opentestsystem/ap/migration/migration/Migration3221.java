package org.opentestsystem.ap.migration.migration;

import lombok.extern.slf4j.Slf4j;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemImageResource;
import org.opentestsystem.ap.common.model.glossary.GlossaryTerm;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.MigrationContext;
import org.opentestsystem.ap.migration.util.ApplicationDependencyProvider;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Component
public class Migration3221 extends AbstractMigration {
    private final AppAssembler appAssembler;

    public Migration3221(final ApplicationDependencyProvider applicationDependencyProvider,
                         final ApplicationProperties applicationProperties,
                         final DataStoreDataManager dataManager,
                         final ItemManagerEventProducer eventProducer,
                         final DataStoreUtility dataStoreUtility,
                         final DataStoreAttachmentManager dataStoreAttachmentManager,
                         final AppAssembler appAssembler) {
        super(applicationDependencyProvider, applicationProperties, dataManager, eventProducer, dataStoreUtility, dataStoreAttachmentManager);
        this.appAssembler = applicationDependencyProvider.getAppAssembler();
    }

    @Override
    protected ItemEntity migrateEntity(ItemEntity itemEntity, MigrationContext migrationContext) {
        return removeDuplicateImageResources(itemEntity);
    }

    @Override
    protected boolean shouldMigrateBranch(ItemEntity migratedEntity) {
        return migratedEntity.getItemJson().getImages().getImageResources().size() > 0;
    }

    private ItemEntity removeDuplicateImageResources(ItemEntity itemEntity) {
        Item item = itemEntity.getItemJson();
        int initialResourceCount = item.getImages().getImageResources().size();
        log.info(String.format("Migration3221: Item %s initial image resource count: %s", item.getId(), initialResourceCount));
        List<ItemImageResource> uniqueImageResources = filterUniqueImageResources(item);
        if (uniqueImageResources.size() != initialResourceCount) {
            log.info(String.format("Migration3221: Updated image resources on Item: %s", item.getId()));
            item.getImages().setImageResources(uniqueImageResources);
        }
        log.info(String.format("Migration3221: Item %s final image resource count: %s", item.getId(), uniqueImageResources.size()));
        return itemEntity;
    }

    private List<ItemImageResource> filterUniqueImageResources(Item item) {
        // List of unique image resources
        List<ItemImageResource> uniqueImageResources = new ArrayList<>();
        // List of unique processed production file names
        List<String> processedFilenames = new ArrayList<>();
        // String version of item.json
        String itemJson = this.appAssembler.getJsonModelAssembler().toStringItem(item);
        for (ItemImageResource imageResource : item.getImages().getImageResources()) {
            String prodFileName = imageResource.getProductionFile().getFileName();
            if (prodFileName == null) {
                // Do not look for duplicates when the production file name is null.
                // This is a valid state of the image resource.
                // The defect that caused IAT-3221 populated this value with a file name.
                uniqueImageResources.add(imageResource);
            } else if (!processedFilenames.contains(prodFileName)) {
                List<ItemImageResource> resourcesWithSameProdFilename = item.getImages().getImageResources().stream()
                        .filter(resource -> resource.getProductionFile().getFileName() != null)
                        .filter(resource -> resource.getProductionFile().getFileName().equals(prodFileName))
                        .collect(Collectors.toList());
                if (resourcesWithSameProdFilename.size() == 1) {
                    // Keep image resource if there's only one with the production file name
                    processedFilenames.add(resourcesWithSameProdFilename.get(0).getProductionFile().getFileName());
                    uniqueImageResources.add(resourcesWithSameProdFilename.get(0));
                } else {
                    boolean imageIsReferenced = false;
                    for (ItemImageResource resource : resourcesWithSameProdFilename) {
                        // Try to find image resources in item content
                        if (itemJson.contains(String.format("data-iat-image-resource-id=\"%s\"", resource.getId()))) {
                            // Keep image resource if it is referenced in content
                            processedFilenames.add(resource.getProductionFile().getFileName());
                            uniqueImageResources.add(resource);
                            imageIsReferenced = true;
                            break;
                        } else {
                            //  Try to find image resource as a glossary illustration
                            List<GlossaryTerm> referencedTerms = item.getGlossary().getTerms().stream()
                                    .filter(glossaryTerm -> glossaryTerm.getIllustrationImageResourceId().equals(resource.getId()))
                                    .collect(Collectors.toList());
                            if (referencedTerms.size() > 0) {
                                // Keep image resource if it is referenced as a glossary illustration
                                processedFilenames.add(resource.getProductionFile().getFileName());
                                uniqueImageResources.add(resource);
                                imageIsReferenced = true;
                                break;
                            }
                        }
                    }
                    if (!imageIsReferenced) {
                        // Keep first image resource if it is not referenced in content
                        processedFilenames.add(resourcesWithSameProdFilename.get(0).getProductionFile().getFileName());
                        uniqueImageResources.add(resourcesWithSameProdFilename.get(0));
                    }
                }
            }
        }
        return uniqueImageResources;
    }

}
