package org.opentestsystem.ap.migration.migration;

import com.fasterxml.jackson.core.JsonProcessingException;
import lombok.extern.slf4j.Slf4j;
import org.opentestsystem.ap.common.client.GitClient;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.repository.ItemRepository;
import org.opentestsystem.ap.migration.config.AppProps;
import org.opentestsystem.ap.migration.model.BranchInfo;
import org.opentestsystem.ap.migration.model.ItemInfo;
import org.opentestsystem.ap.migration.model.MigrationDefinition;
import org.opentestsystem.ap.migration.model.MigrationResult;
import org.opentestsystem.ap.migration.util.Util;

import static org.opentestsystem.ap.common.repository.RepositoryUtil.getModelFileName;

@Slf4j
public abstract class AbstractMigration implements Migration {

    protected final Util util;

    protected final AppProps appProps;

    protected final GitlabClient gitlabClient;

    protected final ItemRepository itemRepository;

    protected abstract void runMigration(final ItemInfo itemInfo,
                                         final BranchInfo branchInfo,
                                         final MigrationDefinition migration,
                                         final GitClient gitClient);

    protected AbstractMigration(final Util util) {
        this.util = util;
        this.appProps = util.getAppProps();
        this.gitlabClient = util.getGitlabClient();
        this.itemRepository = util.getItemRepository();
    }

    @Override
    public MigrationResult migrate(final ItemInfo itemInfo,
                                   final BranchInfo branchInfo,
                                   final String migrationKey,
                                   final MigrationDefinition migration,
                                   final GitClient gitClient) {

        log.info("running {}", migration.getMigrationName());

        final MigrationResult migrationResult = new MigrationResult(migration.getMigrationName());

        gitClient.checkoutBranch(branchInfo.getBranchName());
        gitClient.pullLatest();

        // not the master branch OR the item is public, meaning we should run the migration
        if (!branchInfo.isMasterBranch() || itemInfo.isItemPublic()) {
            runMigration(itemInfo, branchInfo, migration, gitClient);
            updateItemVersion(migrationKey, gitClient);
            // commit only if the migration was run
            gitClient.commit(migration.getMigrationDescription());
        }

        return migrationResult;
    }

    protected void updateItemVersion(final String migrationKey, final GitClient gitClient) {
        final Item item = gitClient.readModelFile();
        // ensure the item version is up to date
        item.setVersion(migrationKey);

        // write new model file
        gitClient.writeModelFile(item);

        // stage model file
        gitClient.stageFiles(getModelFileName());
    }
}
