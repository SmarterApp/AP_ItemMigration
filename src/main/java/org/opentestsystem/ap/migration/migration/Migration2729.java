package org.opentestsystem.ap.migration.migration;

import lombok.extern.slf4j.Slf4j;
import org.gitlab4j.api.models.Project;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.ResourceNotFoundException;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.repository.RepositoryUtil;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.datastore.AbstractDataStoreMigration;
import org.opentestsystem.ap.migration.gitlab.GitLabRepositoryRenameRequest;
import org.opentestsystem.ap.migration.gitlab.GitLabRepositoryRenameResponse;
import org.opentestsystem.ap.migration.model.MigrationContext;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.*;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.util.Objects;

import static java.lang.String.format;

@Slf4j
@Component
public class Migration2729 extends AbstractDataStoreMigration {

    private static final boolean THROW_RESOURCE_NOT_FOUND_WHEN_PROJECT_NOT_FOUND = false;

    private static final boolean RETURN_NULL_WHEN_PROJECT_NOT_FOUND = true;

    private final GitlabClient gitlabClient;

    private final HttpHeaders headers;

    private final RestTemplate restTemplate;

    protected Migration2729(ApplicationDependencyProvider applicationDependencyProvider,
                            RestTemplateBuilder restTemplateBuilder,
                            ApplicationProperties applicationProperties,
                            DataStoreDataManager dataManager,
                            ItemManagerEventProducer eventProducer,
                            DataStoreUtility dataStoreUtility,
                            DataStoreAttachmentManager dataStoreAttachmentManager) {
        super(applicationDependencyProvider, applicationProperties, dataManager, eventProducer, dataStoreUtility,
            dataStoreAttachmentManager);
        this.gitlabClient = applicationDependencyProvider.getGitlabClient();


        this.headers = new HttpHeaders();
        this.headers.add("PRIVATE-TOKEN", this.itemBankProperties.getAccessToken());
        this.headers.setContentType(MediaType.APPLICATION_JSON_UTF8);

        this.restTemplate = restTemplateBuilder
            .rootUri(format("%s%s", itemBankProperties.getHost(), itemBankProperties.getApiVersion()))
            .build();
    }

    @Override
    protected ItemEntity migrateEntity(ItemEntity itemEntity, MigrationContext migrationContext) {
        Item item = itemEntity.getItemJson();

        String legacyId = item.getLegacyId(this.itemBankProperties.getBankKey());
        this.renameProject(item.getId(), legacyId, item.getType());

        return itemEntity;
    }

    private void renameProject(String itemId, String legacyId, String type) {
        Project project = this.getProject(itemId, legacyId);
        if (Objects.nonNull(project)) {
            log.info("renaming {} to {}", itemId, legacyId);
            this.executeRename(project.getId(), legacyId);
        } else {
            log.info("{} already renamed to {}", itemId, legacyId);
        }
        this.renameGlossary(itemId);
    }

    /**
     * Given an item ID its glossary ID is inferred.  The glossary is renamed in GitLab.
     *
     * @param itemId The item ID to determine the glossary ID from.
     */
    private void renameGlossary(String itemId) {
        String glossaryId = RepositoryUtil.getGlossaryId(itemId);
        String glossaryLegacyId = RepositoryUtil.getLegacyItemId(glossaryId, this.itemBankProperties.getBankKey());
        Project project = this.gitlabClient.lookupProjectByName(glossaryLegacyId, RETURN_NULL_WHEN_PROJECT_NOT_FOUND);
        if (Objects.isNull(project)) {
            project = this.gitlabClient.lookupProjectByName(glossaryId, RETURN_NULL_WHEN_PROJECT_NOT_FOUND);
            if (Objects.nonNull(project)) {
                log.info("renaming glossary for item {} to {}", itemId, glossaryLegacyId);
                this.executeRename(project.getId(), glossaryLegacyId);
            } else {
                log.info("glossary for item {} not found", itemId);
            }
        } else {
            log.info("glossary {} for item {} already exists, renamed already", glossaryLegacyId, itemId);
        }
    }

    /**
     * Renames the project and its associated repository in GitLab with the legacy ID.
     *
     * @param projectId The GitLab project identifier.
     * @param legacyId  The value the project and repo are renamed to.
     * @return
     */
    private GitLabRepositoryRenameResponse executeRename(Integer projectId, String legacyId) {
        String resourceUrl = format("/projects/%d", projectId);

        GitLabRepositoryRenameRequest request = new GitLabRepositoryRenameRequest(legacyId, legacyId);

        HttpEntity<GitLabRepositoryRenameRequest> requestUpdate = new HttpEntity<>(request, this.headers);

        ResponseEntity<GitLabRepositoryRenameResponse> response = restTemplate
            .exchange(resourceUrl, HttpMethod.PUT, requestUpdate, GitLabRepositoryRenameResponse.class);

        return response.getBody();
    }

    /**
     * We are accounting for the case when an item gets migrated but its glossary does not. We need the migration to be
     * re-runnable.  We handle re-runs by first looking up the project using the item ID then looking it up by legacy
     * ID. If neither are found we throw {@link ResourceNotFoundException}.  If the item has already been renamed null
     * is returned.
     *
     * @param itemId   The item ID that will be renamed.
     * @param legacyId The ID the item will be renamed to.
     * @return The GitLab project representing the item.
     */
    private Project getProject(String itemId, String legacyId) {
        try {
            return this.gitlabClient.lookupProjectByName(itemId, THROW_RESOURCE_NOT_FOUND_WHEN_PROJECT_NOT_FOUND);
        } catch (ResourceNotFoundException e) {
            final Project project = this.gitlabClient
                .lookupProjectByName(legacyId, THROW_RESOURCE_NOT_FOUND_WHEN_PROJECT_NOT_FOUND);

            if (Objects.nonNull(project)) {
                // the rename has already occurred so return null which allows us to move on to the glossary
                return null;
            }
            // neither the item ID or legacy ID exist so we throw, no point in trying the glossary as it is assumed
            // to not exist either
            throw e;

        }
    }
}
