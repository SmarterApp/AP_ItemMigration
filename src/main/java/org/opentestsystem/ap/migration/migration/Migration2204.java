package org.opentestsystem.ap.migration.migration;

import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.TiItem;
import org.opentestsystem.ap.common.saaif.mapper.model.SkipMigration;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.MigrationContext;
import org.opentestsystem.ap.migration.util.ApplicationDependencyProvider;
import org.springframework.stereotype.Component;

import static org.opentestsystem.ap.common.model.ModelConstants.ItemType.TYPE_TI;

/**
 * We want to migrate only the MASTER branch.  The application.yml has a configuration setting 'migrateBranches'
 * which when true will migrate non-MASTER branches.  We are setting this to false. What this migration does is make
 * sure the item is a TI item and its scoring section is managed by IAT.  If that is not true then the migration is
 * skipped.  If that is true then the item is synced to the item bank.  There are no data changes to the item.  We just
 * need the QRX regenerated.
 */
@Component
public class Migration2204 extends AbstractMigration {
    public Migration2204(final ApplicationDependencyProvider applicationDependencyProvider,
                         final ApplicationProperties applicationProperties,
                         final DataStoreDataManager dataManager,
                         final ItemManagerEventProducer eventProducer,
                         final DataStoreUtility dataStoreUtility,
                         final DataStoreAttachmentManager dataStoreAttachmentManager) {
        super(applicationDependencyProvider, applicationProperties, dataManager, eventProducer, dataStoreUtility,
            dataStoreAttachmentManager);
    }

    @Override
    protected ItemEntity migrateEntity(final ItemEntity itemEntity, final MigrationContext migrationContext) {
        this.checkSkip(itemEntity.getItemJson());
        return itemEntity;
    }

    @Override
    protected boolean shouldMigrateBranch(ItemEntity migratedEntity) {
        try {
            this.checkSkip(migratedEntity.getItemJson());
            return true;
        } catch (SkipMigration e) {
            return false;
        }
    }

    void checkSkip(Item item) {
        if (!TYPE_TI.equalsIgnoreCase(item.getType())) {
            throw new SkipMigration("Item is not a TI");
        }
        TiItem tiItem = (TiItem) item;
        if (!tiItem.getCore().getScoring().isMachineScoringManagedByIat()) {
            throw new SkipMigration("TI item scoring is not managed by TIMS");
        }
    }
}
