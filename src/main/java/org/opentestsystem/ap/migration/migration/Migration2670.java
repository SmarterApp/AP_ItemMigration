package org.opentestsystem.ap.migration.migration;

import org.gitlab4j.api.models.Project;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.parser.Parser;
import org.jsoup.select.Elements;
import org.opentestsystem.ap.common.assembler.AppAssembler;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.AbstractAssessmentItem;
import org.opentestsystem.ap.common.model.AbstractAssessmentItemCore;
import org.opentestsystem.ap.common.model.ItemConstants;
import org.opentestsystem.ap.common.model.SaItem;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.datastore.AbstractDataStoreMigration;
import org.opentestsystem.ap.migration.model.SkipMigration;
import org.opentestsystem.ap.migration.util.MigrationFileUtil;
import org.springframework.stereotype.Component;

import java.io.File;
import java.nio.file.Path;

import static org.opentestsystem.ap.common.model.ItemConstants.BranchNames.BRANCH_MASTER;

@Component
public class Migration2670 extends AbstractDataStoreMigration {
    private final String CONTENT_LINK_INFO_GRAPHIC_TYPE = "Graphic";
    private final GitlabClient gitlabClient;
    private final AppAssembler appAssembler;
    private final MigrationFileUtil migrationFileUtil;

    public Migration2670(final ApplicationDependencyProvider applicationDependencyProvider,
                         final ApplicationProperties applicationProperties,
                         final DataStoreDataManager dataManager,
                         final ItemManagerEventProducer eventProducer,
                         final DataStoreUtility dataStoreUtility,
                         final DataStoreAttachmentManager dataStoreAttachmentManager,
                         final MigrationFileUtil migrationFileUtil) {
        super(applicationProperties, dataManager, eventProducer, dataStoreUtility, dataStoreAttachmentManager);
        this.gitlabClient = applicationDependencyProvider.getGitlabClient();
        this.appAssembler = applicationDependencyProvider.getAppAssembler();
        this.migrationFileUtil = migrationFileUtil;
    }

    @Override
    protected ItemEntity migrateEntity(ItemEntity itemEntity) {
        //Only apply to imported items
        try {
            if (Integer.parseInt(itemEntity.getItemId()) < 200000) {
                Project project = gitlabClient.lookupProjectByName(itemEntity.getItemId());
                applyImageTTSMigration(project, itemEntity);
            } else {
                throw new SkipMigration(String.format("Item %s is not imported.  No updates necessary", itemEntity.getItemId()));
            }
        } catch (Exception ex) {
            throw new SkipMigration(String.format("Unable to migrate item %s. %s", itemEntity.getItemId(), ex.getMessage()));
        }
        return itemEntity;
    }

    private void applyImageTTSMigration(Project project, ItemEntity itemEntity) throws Exception {
        Path expandedZip = migrationFileUtil.getExpandedImportZipFile(itemEntity.getItemId(),
                gitlabClient.getFile(project.getId(), MigrationFileUtil.IMPORT_ZIP_FILENAME, BRANCH_MASTER));

        if (expandedZip.toFile().exists()) {
            // import.zip can contain multiple directories or none at all. Identify the imported item source directory
            Path itemSourceDir = MigrationFileUtil.getItemSourceDir(expandedZip, itemEntity.getItemJson().getItsId());
            // Find the main item file in the source location
            File itemFile = MigrationFileUtil.getItemFileInDirectory(itemSourceDir, itemEntity.getItemJson().getItsId());

            if (itemFile != null) {
                // Load imported item xml data
                final ItemRelease itemRelease = this.appAssembler.getSaaifAssembler()
                        .readXmlFromFile(itemFile.toPath());

                if (itemEntity.getItemJson().getImages().getImageResources().size() > 0) {
                    if (!itemEntity.getItemJson().getType().equals(ItemConstants.ItemType.TYPE_STIM)) {
                        itemRelease.getItem().getContent().forEach(content -> {
                            String language = content.getLanguage();
                            content.getApipAccessibility().getAccessibilityInfo()
                                    .getAccessElement().forEach(accessElement -> {
                                if (accessElement.getContentLinkInfo().getType().equals(CONTENT_LINK_INFO_GRAPHIC_TYPE)) {
                                    String contentLinkIdentifierRef = accessElement.getContentLinkInfo().getItsLinkIdentifierRef();
                                    String audioText = accessElement.getRelatedElementInfo().getReadAloud().getAudioText();
                                    String fileName = getFileNameFromContent(content, contentLinkIdentifierRef);

                                    addTTSToImage(itemEntity, language, fileName, audioText);
                                }
                            });
                        });
                    }
                } else {
                    throw new SkipMigration(String.format("Item %s contains no image resources.  No updates necessary", itemEntity.getItemId()));
                }
            } else {
                throw new Exception(String.format("Unable to find item file in %s for item %s", itemSourceDir, itemEntity.getItemId()));
            }
        }
    }

    private String getFileNameFromContent(ItemRelease.Item.Content content, String identifierRef) {
        String filename = "";
        final Document doc = Jsoup.parse(content.getStem(), "", Parser.xmlParser());
        Elements ttsImages = doc.select("img.id='" + identifierRef + '"');
        for (Element element : ttsImages) {
            filename = element.attr("src");
        }
        return filename;
    }

    private void addTTSToImage(ItemEntity itemEntity, String language, String identifierRef, String ttsText) {
        //TODO: Cast to specific implementation based on item type
        SaItem item = (SaItem) itemEntity.getItemJson();

        String prompt;
        String filename;

        if (ItemConstants.ItemLanguage.LANG_ENU.equals(language)) {
            prompt = item.getCore().getEn().getPrompt();

        } else {
            prompt = item.getTranslations().getEsp().getPrompt();
        }

        final Document doc = Jsoup.parse(prompt, "", Parser.xmlParser());



    }
}
