package org.opentestsystem.ap.migration.migration;

import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ModelConstants;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.common.saaif.item.SaaifContent;
import org.opentestsystem.ap.common.saaif.mapper.model.ImportItem;
import org.opentestsystem.ap.common.saaif.mapper.model.SkipMigration;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.ItemMerge;
import org.opentestsystem.ap.migration.ttsmapper.StimTtsMapper;
import org.opentestsystem.ap.migration.ttsmapper.TtsElementInfo;
import org.opentestsystem.ap.migration.ttsmapper.TtsMapperFactory;
import org.opentestsystem.ap.migration.util.ApplicationDependencyProvider;
import org.springframework.stereotype.Component;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import static org.opentestsystem.ap.common.model.ModelConstants.ItemType.TYPE_STIM;

@Component
public class Migration2957 extends AbstractImportMigration {

    private static String CONTENTLINKINFO_TYPE_EQUATION = "Equation";

    private final TtsMapperFactory ttsMapperFactory;

    public Migration2957(ApplicationProperties applicationProperties,
                         DataStoreDataManager dataManager,
                         ItemManagerEventProducer eventProducer,
                         DataStoreUtility dataStoreUtility,
                         DataStoreAttachmentManager dataStoreAttachmentManager,
                         ApplicationDependencyProvider applicationDependencyProvider,
                         TtsMapperFactory ttsMapperFactory) {
        super(applicationProperties, dataManager, eventProducer, dataStoreUtility,
                dataStoreAttachmentManager, applicationDependencyProvider);
        this.ttsMapperFactory = ttsMapperFactory;
    }

    @Override
    protected ItemMerge mergeItem(Item dataStoreItem, Item mappedItem, Path itemSyncDir) {
        // Do nothing with the dataStoreItem. Merge work occurs in mergeItemFromImportData
        return new ItemMerge(dataStoreItem, itemSyncDir, DO_NOT_SYNC_ATTACHMENTS);
    }

    @Override
    protected ItemMerge mergeItemFromImportData(ItemMerge itemMerge, ImportItem importItem, Path itemSyncDir) {
        // Set Equation TTS on image resources within the rich text of each item
        mergeEquationTTS(itemMerge.getMergedItem(), getTtsElementInfoList(itemMerge.getMergedItem(), importItem.getItemRelease()));

        return new ItemMerge(itemMerge.getMergedItem(), itemSyncDir, DO_NOT_SYNC_ATTACHMENTS);
    }

    @Override
    protected void checkSkipMigration(ImportItem importItem) {
        if (!importItem.getItemProps().getItemType()
                .equalsIgnoreCase(ModelConstants.ItemType.TYPE_TUT)) {
            if (!hasEquationTTS(importItem)) {
                throw new SkipMigration(String
                        .format("Item %s does not contain any Equation TTS to apply", importItem.getItemProps().getItemId()));
            }
        } else {
            throw new SkipMigration(String
                    .format("Item %s is a Tutorial. No migration is necessary.", importItem.getItemProps().getItemId()));
        }
    }

    @Override
    protected Collection<String> getEditedSectionsBlockingMigration() {
        return Collections.emptyList();
    }


    private void mergeEquationTTS(Item item, List<TtsElementInfo> ttsElementInfoList) {
        // Calls item-specific TtsMapper to update TTS on Equation images
        ttsMapperFactory.getTtsMapper(item.getType())
                .mergeEquationTTS(item, ttsElementInfoList);
    }

    /**
     * Populates a List of TtsElementInfo objects which contain
     * the necessary information to set the TTS on Equation images
     *
     * @param release the ItemRelease used during the initial import
     * @return a List of TtsElementInfo objects
     */
    private List<TtsElementInfo> getTtsElementInfoList(Item timsItem, ItemRelease release) {
        if (Objects.nonNull(release.getPassage())) {
            return loadPassageTtsElementInfoList(release.getPassage());
        } else {
            return loadItemTtsElementInfoList(timsItem, release.getItem());
        }
    }

    /**
     * Returns a List of TtsElementInfo contained on an ItemRelease.Passage
     *
     * @param passage the ItemRelease.Pasage
     * @return a List of TtsElementInfo objects
     */
    private List<TtsElementInfo> loadPassageTtsElementInfoList(ItemRelease.Passage passage) {
        List<TtsElementInfo> ttsElementInfoList = new ArrayList<>();
        passage.getContent().forEach(content -> {
            if (Objects.nonNull(content.getApipAccessibility())) {
                content.getApipAccessibility().getAccessibilityInfo()
                        .getAccessElement().forEach(accessElement -> {
                    if (accessElement.getContentLinkInfo().getType().equalsIgnoreCase(CONTENTLINKINFO_TYPE_EQUATION)) {
                        ttsElementInfoList.add(new TtsElementInfo(
                                passage.getId(), TYPE_STIM, passage.getBankkey(), content.getLanguage(),
                                accessElement.getContentLinkInfo().getItsLinkIdentifierRef(),
                                accessElement.getRelatedElementInfo().getReadAloud().getAudioShortDesc()));
                    }
                });
            }
        });
        // Set filenames on information collected previously (item type specific)
        updateFileNamesOnTtsElementInfoList(passage, ttsElementInfoList);
        return ttsElementInfoList;
    }

    /**
     * Returns a List of TtsElementInfo contained on an ItemRelease.Item
     *
     * @param item the ItemRelease.Item
     * @return a List of TtsElementInfo objects
     */
    private List<TtsElementInfo> loadItemTtsElementInfoList(Item timsItem, ItemRelease.Item item) {
        List<TtsElementInfo> ttsElementInfoList = new ArrayList<>();
        // Collect information from ItemRelease accessibilityInfo elements
        item.getContent().forEach(content -> {
            if (Objects.nonNull(content.getApipAccessibility())) {
                content.getApipAccessibility().getAccessibilityInfo()
                        .getAccessElement().forEach(accessElement -> {
                    if (accessElement.getContentLinkInfo().getType().equalsIgnoreCase(CONTENTLINKINFO_TYPE_EQUATION)) {
                        ttsElementInfoList.add(new TtsElementInfo(
                                item.getId(), item.getFormat(), item.getBankkey(), content.getLanguage(),
                                accessElement.getContentLinkInfo().getItsLinkIdentifierRef(),
                                accessElement.getRelatedElementInfo().getReadAloud().getAudioShortDesc()));
                    }
                });
            }
        });
        // Set filenames on information collected previously (item type specific)
        updateFileNamesOnTtsElementInfoList(timsItem, item, ttsElementInfoList);
        return ttsElementInfoList;
    }

    /**
     * Calls the item-specific updateFileNamesFromItem to set the image filenames on the ttsElementInfo objects
     *
     * @param item               the ItemRelease.Item
     * @param ttsElementInfoList the List of ttsElementInfo
     */
    private void updateFileNamesOnTtsElementInfoList(Item timsItem, ItemRelease.Item item, List<TtsElementInfo> ttsElementInfoList) {
        String itemType = timsItem.getType();
        ttsMapperFactory.getTtsMapper(itemType)
                .updateFileNamesFromItem(item, itemType, ttsElementInfoList);
    }

    /**
     * Calls the item-specific updateFileNamesFromItem to set the image filenames on the ttsElementInfo objects
     *
     * @param passage            the ItemRelease.Item
     * @param ttsElementInfoList the List of ttsElementInfo
     */
    private void updateFileNamesOnTtsElementInfoList(ItemRelease.Passage passage, List<TtsElementInfo> ttsElementInfoList) {
        StimTtsMapper stimTtsMapper = new StimTtsMapper();
        stimTtsMapper.updateFileNamesFromPassage(passage, ttsElementInfoList);
    }

    /**
     * Used in checkSkipMigration. Determine is item has Equation accessibilityInfo.accessElement (TTS)
     *
     * @param importItem ImportItem that contains the ItemRelease used during the initial item import
     * @return boolean
     */
    private boolean hasEquationTTS(ImportItem importItem) {
        if (importItem.getItemProps().getItemType().equals(ModelConstants.ItemType.TYPE_STIM)) {
            return passageContentHasEquationTTS(importItem.getItemRelease().getPassage(), ModelConstants.ItemLanguage.LANG_ENU) ||
                    passageContentHasEquationTTS(importItem.getItemRelease().getPassage(), ModelConstants.ItemLanguage.LANG_ESN);
        } else {
            return itemContentHasEquationTTS(importItem.getItemRelease().getItem(), ModelConstants.ItemLanguage.LANG_ENU) ||
                    itemContentHasEquationTTS(importItem.getItemRelease().getItem(), ModelConstants.ItemLanguage.LANG_ESN);
        }
    }

    /**
     * Returns true is the ItemRelease.Passage contains Equation accessibilityInfo elements
     *
     * @param passage  the Passage object
     * @param language the language
     * @return boolean
     */
    private boolean passageContentHasEquationTTS(ItemRelease.Passage passage, String language) {
        boolean hasEquationTTS = false;
        Optional<ItemRelease.Passage.Content> passageContent =
                passage.getContent().stream()
                        .filter(content -> language.equalsIgnoreCase(content.getLanguage())).findAny();
        if (passageContent.isPresent()) {
            ItemRelease.Passage.Content content = passageContent.get();
            hasEquationTTS = contentHasEquationTTS(content);
        }
        return hasEquationTTS;
    }

    /**
     * Returns true is the ItemRelease.Item contains Equation accessibilityInfo elements
     *
     * @param item     the Item object
     * @param language the language
     * @return boolean
     */
    private boolean itemContentHasEquationTTS(ItemRelease.Item item, String language) {
        boolean hasEquationTTS = false;
        Optional<ItemRelease.Item.Content> itemContent =
                item.getContent().stream()
                        .filter(content -> language.equalsIgnoreCase(content.getLanguage())).findAny();
        if (itemContent.isPresent()) {
            ItemRelease.Item.Content content = itemContent.get();
            hasEquationTTS = contentHasEquationTTS(content);
        }
        return hasEquationTTS;
    }

    /**
     * Checks SaaifContent object for Equation accessibilityInfo elements
     *
     * @param content the content object
     * @return boolean
     */
    private boolean contentHasEquationTTS(SaaifContent content) {
        boolean hasEquation = false;
        if (content.getApipAccessibility() != null) {
            hasEquation = content.getApipAccessibility().getAccessibilityInfo().getAccessElement()
                    .stream()
                    .anyMatch(accessElement -> accessElement.getContentLinkInfo()
                            .getType().equalsIgnoreCase(CONTENTLINKINFO_TYPE_EQUATION));
        }
        return hasEquation;
    }
}
