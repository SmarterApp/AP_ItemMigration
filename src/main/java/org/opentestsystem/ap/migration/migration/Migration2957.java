package org.opentestsystem.ap.migration.migration;

import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.management.ItemManagerEventProducer;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemConstants;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.common.saaif.item.SaaifContent;
import org.opentestsystem.ap.common.saaif.model.ImportItem;
import org.opentestsystem.ap.common.saaif.model.SkipMigration;
import org.opentestsystem.ap.migration.ApplicationDependencyProvider;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.ItemMerge;
import org.opentestsystem.ap.migration.ttsmapper.StimTtsMapper;
import org.opentestsystem.ap.migration.ttsmapper.TtsMapperFactory;
import org.opentestsystem.ap.migration.ttsmapper.ttsElementInfo;
import org.springframework.stereotype.Component;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

@Component
public class Migration2957 extends AbstractImportMigration {

    private static String CONTENTLINKINFO_TYPE_EQUATION = "Equation";

    private final TtsMapperFactory ttsMapperFactory;

    public Migration2957(ApplicationProperties applicationProperties,
                         DataStoreDataManager dataManager,
                         ItemManagerEventProducer eventProducer,
                         DataStoreUtility dataStoreUtility,
                         DataStoreAttachmentManager dataStoreAttachmentManager,
                         ApplicationDependencyProvider applicationDependencyProvider,
                         TtsMapperFactory ttsMapperFactory) {
        super(applicationProperties, dataManager, eventProducer, dataStoreUtility,
                dataStoreAttachmentManager, applicationDependencyProvider);
        this.ttsMapperFactory = ttsMapperFactory;
    }

    @Override
    protected ItemMerge mergeItem(Item dataStoreItem, Item mappedItem, Path itemSyncDir) {
        return new ItemMerge(dataStoreItem, itemSyncDir, DO_NOT_SYNC_ATTACHMENTS);
    }

    @Override
    protected ItemMerge mergeItemFromImportData(ItemMerge itemMerge, ImportItem importItem, Path itemSyncDir) {
        // Set Equation TTS on image resources within the rich text of each item
        mergeEquationTTS(itemMerge.getMergedItem(), getTtsElementInfoList(importItem.getItemRelease()));

        return new ItemMerge(itemMerge.getMergedItem(), itemSyncDir, DO_NOT_SYNC_ATTACHMENTS);
    }

    @Override
    protected void checkSkipMigration(ImportItem importItem) {
        if (!importItem.getItemProps().getItemType().equalsIgnoreCase(ItemConstants.ItemType.TYPE_TUT)) {
            if (!hasEquationTTS(importItem)) {
                throw new SkipMigration(String
                        .format("Item %s does not contain any Equation TTS to apply", importItem.getItemProps().getItemId()));
            }
        } else {
            throw new SkipMigration(String
                    .format("Item %s is a Tutorial. No migration is necessary.", importItem.getItemProps().getItemId()));
        }
    }

    @Override
    protected Collection<String> getEditedSectionsBlockingMigration() {
        return Collections.emptyList();
    }


    private void mergeEquationTTS(Item item, List<ttsElementInfo> ttsElementInfoList) {
        ttsMapperFactory.getTtsMapper(item.getType())
                .mergeEquationTTS(item, ttsElementInfoList);
    }

    // ------------------------------------------------------------------------
    // Methods used to load a list of ttsElementInfo objects which contain
    // the information necessary to set the TSS value on images

    private List<ttsElementInfo> getTtsElementInfoList(ItemRelease release) {
        if (release.getItem().getFormat().equalsIgnoreCase(ItemConstants.ItemType.TYPE_STIM)) {
            return loadPassageTtsElementInfoList(release.getPassage());
        } else {
            return loadItemTtsElementInfoList(release.getItem());
        }
    }

    private List<ttsElementInfo> loadPassageTtsElementInfoList(ItemRelease.Passage passage) {
        List<ttsElementInfo> ttsElementInfoList = new ArrayList<>();
        passage.getContent().forEach(content -> content.getApipAccessibility().getAccessibilityInfo()
                .getAccessElement().forEach(accessElement -> {
                    if (accessElement.getContentLinkInfo().getType().equalsIgnoreCase(CONTENTLINKINFO_TYPE_EQUATION)) {
                        ttsElementInfoList.add(new ttsElementInfo(content.getLanguage(),
                                accessElement.getContentLinkInfo().getItsLinkIdentifierRef(),
                                accessElement.getRelatedElementInfo().getReadAloud().getAudioShortDesc()));
                    }
                }));
        // Set filenames on information collected previously (item type specific)
        updateFileNamesOnTtsElementInfoList(passage, ttsElementInfoList);
        return ttsElementInfoList;
    }

    private List<ttsElementInfo> loadItemTtsElementInfoList(ItemRelease.Item item) {
        List<ttsElementInfo> ttsElementInfoList = new ArrayList<>();
        // Collect information from ItemRelease accessibilityInfo elements
        item.getContent().forEach(content -> content.getApipAccessibility().getAccessibilityInfo()
                .getAccessElement().forEach(accessElement -> {
                    if (accessElement.getContentLinkInfo().getType().equalsIgnoreCase(CONTENTLINKINFO_TYPE_EQUATION)) {
                        ttsElementInfoList.add(new ttsElementInfo(content.getLanguage(),
                                accessElement.getContentLinkInfo().getItsLinkIdentifierRef(),
                                accessElement.getRelatedElementInfo().getReadAloud().getAudioShortDesc()));
                    }
                }));
        // Set filenames on information collected previously (item type specific)
        updateFileNamesOnTtsElementInfoList(item, ttsElementInfoList);
        return ttsElementInfoList;
    }

    private void updateFileNamesOnTtsElementInfoList(ItemRelease.Item item, List<ttsElementInfo> ttsElementInfoList) {
        ttsMapperFactory.getTtsMapper(item.getFormat())
                .updateFileNamesFromItem(item, ttsElementInfoList);
    }

    private void updateFileNamesOnTtsElementInfoList(ItemRelease.Passage passage, List<ttsElementInfo> ttsElementInfoList) {
        StimTtsMapper stimTtsMapper = new StimTtsMapper();
        stimTtsMapper.updateFileNamesFromPassage(passage, ttsElementInfoList);
    }

    // ------------------------------------------------------------------------
    // Used in checkSkipMigration. Determine is item has Equation accessibilityInfo.accessElement (TTS)
    private boolean hasEquationTTS(ImportItem importItem) {
        if (importItem.getItemProps().getItemType().equals(ItemConstants.ItemType.TYPE_STIM)) {
            return passageContentHasEquationTTS(importItem.getItemRelease().getPassage(), ItemConstants.ItemLanguage.LANG_ENU) ||
                    passageContentHasEquationTTS(importItem.getItemRelease().getPassage(), ItemConstants.ItemLanguage.LANG_ESN);
        } else {
            return itemContentHasEquationTTS(importItem.getItemRelease().getItem(), ItemConstants.ItemLanguage.LANG_ENU) ||
                    itemContentHasEquationTTS(importItem.getItemRelease().getItem(), ItemConstants.ItemLanguage.LANG_ESN);
        }
    }

    private boolean passageContentHasEquationTTS(ItemRelease.Passage passage, String language) {
        boolean hasEquationTTS = false;
        Optional<ItemRelease.Passage.Content> passageContent =
                passage.getContent().stream()
                        .filter(content -> language.equalsIgnoreCase(content.getLanguage())).findAny();
        if (passageContent.isPresent()) {
            ItemRelease.Passage.Content content = passageContent.get();
            hasEquationTTS = contentHasEquationTTS(content);
        }
        return hasEquationTTS;
    }

    private boolean itemContentHasEquationTTS(ItemRelease.Item item, String language) {
        boolean hasEquationTTS = false;
        Optional<ItemRelease.Item.Content> itemContent =
                item.getContent().stream()
                        .filter(content -> language.equalsIgnoreCase(content.getLanguage())).findAny();
        if (itemContent.isPresent()) {
            ItemRelease.Item.Content content = itemContent.get();
            hasEquationTTS = contentHasEquationTTS(content);
        }
        return hasEquationTTS;
    }

    private boolean contentHasEquationTTS(SaaifContent content) {
        boolean hasEquation = false;
        if (content.getApipAccessibility() != null) {
            hasEquation = content.getApipAccessibility().getAccessibilityInfo().getAccessElement()
                    .stream()
                    .anyMatch(accessElement -> accessElement.getContentLinkInfo()
                            .getType().equalsIgnoreCase(CONTENTLINKINFO_TYPE_EQUATION));
        }
        return hasEquation;
    }
}
