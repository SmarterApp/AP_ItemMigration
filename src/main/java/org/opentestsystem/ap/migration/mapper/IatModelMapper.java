package org.opentestsystem.ap.migration.mapper;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.MapUtils;
import org.apache.commons.lang3.StringUtils;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.parser.Parser;
import org.jsoup.select.Elements;
import org.opentestsystem.ap.common.model.AbstractAssessmentItem;
import org.opentestsystem.ap.common.model.AbstractItem;
import org.opentestsystem.ap.common.model.AssessmentItem;
import org.opentestsystem.ap.common.model.Attachment;
import org.opentestsystem.ap.common.model.EqItem;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemConstants;
import org.opentestsystem.ap.common.model.ItemFactory;
import org.opentestsystem.ap.common.model.ItemImageResource;
import org.opentestsystem.ap.common.model.ItemMetadata;
import org.opentestsystem.ap.common.model.WorkflowStatusEnum;
import org.opentestsystem.ap.common.model.glossary.GlossaryConstants;
import org.opentestsystem.ap.common.model.glossary.GlossaryDialect;
import org.opentestsystem.ap.common.model.glossary.GlossaryLanguage;
import org.opentestsystem.ap.common.model.glossary.GlossaryLanguages;
import org.opentestsystem.ap.common.model.glossary.GlossaryTerm;
import org.opentestsystem.ap.common.repository.RepositoryUtil;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.common.saaif.item.SaaifAccessibilityInfo;
import org.opentestsystem.ap.common.saaif.item.SaaifApipAccessibility;
import org.opentestsystem.ap.common.saaif.item.SaaifAttachment;
import org.opentestsystem.ap.common.saaif.item.SaaifAttachmentSource;
import org.opentestsystem.ap.common.saaif.item.SaaifAttachmentlist;
import org.opentestsystem.ap.common.saaif.item.SaaifContent;
import org.opentestsystem.ap.common.saaif.metadata.SmarterAppMetadata;
import org.opentestsystem.ap.common.saaif.wordlist.HtmlType;
import org.opentestsystem.ap.common.saaif.wordlist.KeywordType;
import org.opentestsystem.ap.common.saaif.wordlist.WordlistreleaseType;
import org.opentestsystem.ap.migration.model.GlossaryFileProps;
import org.opentestsystem.ap.migration.model.IatImage;
import org.opentestsystem.ap.migration.model.IatImportConstants;
import org.opentestsystem.ap.migration.model.ItemMappingProperties;
import org.opentestsystem.ap.migration.model.ItemMappingResult;
import org.opentestsystem.ap.migration.model.ItemProps;
import org.opentestsystem.ap.migration.model.StandardIdProps;
import org.opentestsystem.ap.migration.util.BrailleUtil;
import org.opentestsystem.ap.migration.util.MigrationFileUtil;
import org.opentestsystem.ap.migration.util.MigrationMapperUtil;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;

import static java.lang.String.format;
import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;
import static org.apache.commons.lang3.StringUtils.isNotBlank;
import static org.opentestsystem.ap.common.model.ItemConstants.ItemVersion.ITEM_VERSION;
import static org.opentestsystem.ap.common.repository.RepositoryUtil.getQrxFileName;


@Slf4j
public abstract class IatModelMapper {

    static final String EMPTY_PARAGRAPH_TAG = "<p style=\"\">&#xA0;</p>";

    private static final String undetermined = "undetermined";

    private static final Map<String, String> scoreEngineMap = new HashMap<>();

    private final int PIXEL_TO_EM_CONVERSION_RATE = 16;

    private final String LANGUAGE_DIVIDER_TAG = "<p class=\"languagedivider\">";

    static {
        scoreEngineMap.put("Automatic with Machine Rubric", "AutomaticWithRubric");
    }

    /**
     * Maps the content from SAAIF to the TIMS Item
     *
     * @param item               the existing {@link Item}
     * @param release            the {@link ItemRelease} SAAIF format
     * @param itemLocalPath      directory to place any files which need to be ingested into TIMS
     * @param itemSourceFullPath expanded import.zip file path location
     * @param itemMappingResult  {@link ItemMappingResult} to contain status of mapping
     * @return a new mapped item from the SAAIF files
     */
    abstract Item mapContent(Item item,
                             ItemRelease release,
                             Path itemLocalPath,
                             String itemSourceFullPath,
                             ItemMappingResult itemMappingResult);

    /**
     * Hydrates an {@link Item} from the SAAIF files
     *
     * @param itemProps        {@link ItemProps} with information for import/migration
     * @param existingItem     the {@link Item} which will be hydrated
     * @param release          {@link ItemRelease} the item XML for the item
     * @param metadata         {@link SmarterAppMetadata} for the item (metadata.xml)
     * @param wordListRelease  {@link WordlistreleaseType} if the item contains the wordlist (nullable)
     * @param wordlistFullPath Path to the wordlist directory for the wordlist type (nullable)
     * @param itemLocalPath    directory to place any files which need to be ingested into TIMS
     * @param itemDirFullPath  expanded import.zip file path location
     * @return a new mapped item from the SAAIF files
     */
    public final Item mapSaaifToIATModel(ItemProps itemProps,
                                         Item existingItem,
                                         ItemRelease release,
                                         SmarterAppMetadata metadata,
                                         WordlistreleaseType wordListRelease,
                                         String wordlistFullPath,
                                         Path itemLocalPath,
                                         String itemDirFullPath) {

        return this.mapSaaifToIATModel(itemProps, existingItem, release, metadata, wordListRelease, wordlistFullPath,
                itemLocalPath, itemDirFullPath, new ItemMappingResult());
    }

    /**
     * Uses the ItemRelease to fully hydrate the Item object Main item Saaif mapping function used during import
     *
     * @param itemProps        Contains all ids that will be used during import
     * @param existingItem     Object that will be hydrated during mapping
     * @param release          Source data used during mapping
     * @param metadata         Items metadata object
     * @param wordListRelease  Items Wordlist
     * @param wordlistFullPath File system location of the source Wordlist files
     * @param itemLocalPath    Path to items temporary directory
     * @param itemDirFullPath  File system location of the source Item files
     * @param mappingResult    Collects item mapping status and additional properties (remove)
     * @return
     */
    public final Item mapSaaifToIATModel(ItemProps itemProps,
                                         Item existingItem,
                                         ItemRelease release,
                                         SmarterAppMetadata metadata,
                                         WordlistreleaseType wordListRelease,
                                         String wordlistFullPath,
                                         Path itemLocalPath,
                                         String itemDirFullPath,
                                         ItemMappingResult mappingResult) {
        Item mappedItem = new ItemFactory().newItem(existingItem.getId(), existingItem.getType());

        mappedItem.getWorkflow().setWorkflowStatusCode(existingItem.getWorkflow().getWorkflowStatusCode());
        mappedItem.setItsId(existingItem.getItsId());
        mappedItem.setVersion(existingItem.getVersion());

        if (null != wordListRelease) {
            mappedItem = mapWordlistToGlossaryTerms(mappedItem, itemLocalPath, wordListRelease, wordlistFullPath,
                    mappingResult);
        }

        mappedItem = mapContent(mappedItem, release, itemLocalPath, itemDirFullPath, mappingResult);
        mappedItem = mapMetadata(mappedItem, metadata);
        mappedItem = mapAssociatedPassage(mappedItem, itemProps);
        mappedItem = mapTutorial(mappedItem, itemProps);

        return mappedItem;
    }

    /**
     * Uses the WordlistreleaseType to hydrate the items glossary section Main glossary Saaif mapping function used
     * during import
     *
     * @param item             Object that will be hydrated during mapping
     * @param wordListRelease  Items Wordlist
     * @param wordlistFullPath File system location of the source Wordlist files
     * @param itemLocalPath    Path to items temporary directory
     * @param mappingResult    Collects item mapping status and additiona properties
     * @return
     */
    public final Item mapWordlistToItem(Item item,
                                        WordlistreleaseType wordListRelease,
                                        String wordlistFullPath,
                                        Path itemLocalPath,
                                        ItemMappingResult mappingResult) {
        if (null != wordListRelease) {
            item = mapWordlistToGlossaryTerms(item, itemLocalPath, wordListRelease, wordlistFullPath, mappingResult);
        }
        return item;
    }

    /**
     * Main rich text mapping function used in non-stimulus items during migration.
     *
     * @param content
     * @param apipAccessibility
     * @param mappingProperties
     * @return
     */
    public final <T extends SaaifAccessibilityInfo> ItemMappingProperties mapSingleRichTextContent(final String languageCode,
                                                                final String content,
                                                                SaaifApipAccessibility<T> apipAccessibility,
                                                                final ItemMappingProperties mappingProperties) {

        return mapRichTextContent(languageCode, content, apipAccessibility, mappingProperties);
    }

    /**
     * Main rich text mapping function used in non-stimulus items during import. TTS is processed first since it uses
     * the {@link ItemRelease.Item.Content.ApipAccessibility} static object
     *
     * @param languageCode the {@link ItemConstants.ItemLanguage} value for the content
     * @param content the actual content
     * @param apipAccessibility the {@link org.opentestsystem.ap.common.saaif.item.ItemRelease.Item.Content.ApipAccessibility}
     * @param mappingProperties the {@link ItemMappingProperties} containing mapping information for the item
     * @return
     */
    <T extends SaaifAccessibilityInfo> ItemMappingProperties mapRichTextContent(final String languageCode,
                                             final String content,
                                             SaaifApipAccessibility<T> apipAccessibility,
                                             final ItemMappingProperties mappingProperties) {
        final boolean isSpanish = ItemConstants.ItemLanguage.LANG_ESN.equals(languageCode);
        final String mappedContent = isSpanish ? getEsnContent(content) : content;
        String iatContent = processTTSTags(mappedContent, apipAccessibility);
        mappingProperties.setContent(processCommonTags(iatContent, mappingProperties));
        return mappingProperties;
    }

    /**
     * Process common tags to both ItemRelease.Item and ItemRelease.Passage resources
     *
     * @param content
     * @param mappingProperties
     * @return
     */
    String processCommonTags(String content, ItemMappingProperties mappingProperties) {
        String iatContent = processGlossaryTags(content);
        iatContent = processImageSlidesTags(iatContent);
        iatContent = processImageTags(iatContent, mappingProperties);
        iatContent = processAnchorTags(iatContent, mappingProperties);
        iatContent = processTableTags(iatContent);
        iatContent = processListTags(iatContent);
        return iatContent;
    }

    /**
     * @param content
     * @param mappingProperties
     * @return
     */
    ItemMappingProperties mapQtiContentForChoiceInteraction(ItemRelease.Item.Content content,
                                                            ItemMappingProperties mappingProperties) {
        final Document doc = Jsoup.parse(content.getQti().getValue(), "", Parser.xmlParser());

        doc.getElementsByTag("itemBody").forEach(itemBody -> {
            String qtiFirstParagraph = itemBody.getElementsByTag("p").first().toString();
            String qtiMappedPrompt = "";
            if (StringUtils.isNotBlank(qtiFirstParagraph)) {
                qtiMappedPrompt = mapRichTextContent(content.getLanguage(), qtiFirstParagraph, content.getApipAccessibility(),
                        mappingProperties).getContent();
            }

            for (Element choiceInteraction : itemBody.getElementsByTag("choiceInteraction")) {
                String responseId = choiceInteraction.attr("responseIdentifier");
                String prompt = choiceInteraction.getElementsByTag("prompt").first().html();

                if (responseId.equals("EBSR1")) {
                    mappingProperties.setPartAPrompt(
                            mapRichTextContent(content.getLanguage(), prompt, content.getApipAccessibility(), mappingProperties).getContent());
                    for (Element simpleChoice : choiceInteraction.getElementsByTag("simpleChoice")) {
                        String sChoiceText = simpleChoice.getElementsByTag("p").first().toString();
                        mappingProperties.getPartAOptions().add(
                                mapRichTextContent(content.getLanguage(), sChoiceText, content.getApipAccessibility(), mappingProperties)
                                        .getContent());
                    }
                } else if (responseId.equals("EBSR2")) {
                    mappingProperties.setPartBPrompt(
                            mapRichTextContent(content.getLanguage(), prompt, content.getApipAccessibility(), mappingProperties).getContent());
                    for (Element simpleChoice : choiceInteraction.getElementsByTag("simpleChoice")) {
                        String sChoiceText = simpleChoice.getElementsByTag("p").first().toString();
                        mappingProperties.getPartBOptions().add(
                                mapRichTextContent(content.getLanguage(), sChoiceText, content.getApipAccessibility(), mappingProperties)
                                        .getContent());
                    }
                }
            }

            mappingProperties.setContent(qtiMappedPrompt);
        });

        return mappingProperties;
    }


    /**
     * @param content
     * @param mappingProperties
     * @return
     */
    ItemMetadata mapItemMetadata(SmarterAppMetadata smarterAppMetadata) {
        ItemMetadata itemMetadata = new ItemMetadata();

        itemMetadata.setAccessibilityLanguageComplexity(
                defaultString(smarterAppMetadata.getAccessibilityLanguageComplexity()));
        itemMetadata.setAlgebraDescriptor1(defaultString(smarterAppMetadata.getAlgebraDescriptor1()));
        itemMetadata.setAlgebraDescriptor2(defaultString(smarterAppMetadata.getAlgebraDescriptor2()));
        itemMetadata.setAllowCalculator(mapYandNtoYesandNo(smarterAppMetadata.getAllowCalculator()));
        itemMetadata.setClaim2Category(mapClaim2Category(smarterAppMetadata.getClaim2Category()));
        itemMetadata.setClaim2SubCategory(defaultString(smarterAppMetadata.getClaim2SubCategory()));
        itemMetadata.setContentTaskModel(defaultString(smarterAppMetadata.getContentTaskModel()));
        itemMetadata.setCopyrightHolder(defaultString(smarterAppMetadata.getCopyrightHolder()));
        itemMetadata.setCopyrightHolderOther(defaultString(smarterAppMetadata.getCopyrightHolderOther()));
        itemMetadata.setDepthOfKnowledge(defaultString(smarterAppMetadata.getDepthOfKnowledge()));
        itemMetadata.setIntendedGrade(defaultString(smarterAppMetadata.getIntendedGrade()));
        itemMetadata.setLanguageFeatures(defaultString(smarterAppMetadata.getLanguageFeatures()));
        itemMetadata.setMaxGrade(defaultString(smarterAppMetadata.getMaximumGrade()));
        itemMetadata.setMaximumPoints(defaultString(smarterAppMetadata.getMaximumNumberOfPoints()));
        itemMetadata.setMeaningPurpose(defaultString(smarterAppMetadata.getMeaningPurpose()));
        itemMetadata.setMinGrade(defaultString(smarterAppMetadata.getMinimumGrade()));

        itemMetadata.setPerformanceTask(
                mapYandNtoYesandNo(smarterAppMetadata.getPerformanceTaskComponentItem()));

        itemMetadata.setPerformanceTaskPosition(defaultString(smarterAppMetadata.getPtSequence()));
        itemMetadata.setReadabilityFleschKincaid(defaultString(smarterAppMetadata.getReadabilityFleschKincaid()));
        itemMetadata.setReadabilityLexile(defaultString(smarterAppMetadata.getReadabilityLexile()));

        itemMetadata.setScorePoints(
                defaultString(smarterAppMetadata.getScorePoints())
                        .replace("\"", "")
                        .replace(" ", "")
                        .replace(",", ", ")
        );

        itemMetadata.setScoringEngine(
                MapUtils.getString(
                        scoreEngineMap, smarterAppMetadata.getScoringEngine(),
                        defaultString(smarterAppMetadata.getScoringEngine())
                )
        );

        itemMetadata.setSpecificationsVersion(defaultString(smarterAppMetadata.getSpecificationsVersion()));
        itemMetadata.setStimulusFormat(defaultString(smarterAppMetadata.getStimulusGenre()));
        itemMetadata.setStimulusLength(defaultString(smarterAppMetadata.getStimulusLength()));
        itemMetadata.setStimulusLiteraryKnowledgeDemands(
                defaultString(smarterAppMetadata.getStimulusLiteraryKnowledgeDemands()));
        itemMetadata.setStimulusLiteraryCategory(defaultString(smarterAppMetadata.getStimulusLiteraryNonFiction()));
        itemMetadata.setStimulusName(defaultString(smarterAppMetadata.getStimulusName()));
        itemMetadata.setStructure(defaultString(smarterAppMetadata.getStructure()));

        itemMetadata.setSubject(mapIatSubject(smarterAppMetadata.getSubject()));

        itemMetadata.setTestCategory(defaultString(smarterAppMetadata.getTestCategory()));

        String iatVersion = defaultString(smarterAppMetadata.getVersion());
        if (StringUtils.isNotBlank(iatVersion)) {
            if (!iatVersion.contains(".")) {
                iatVersion = iatVersion + ".0";
            }
        } else {
            iatVersion = "0.0";
        }

        itemMetadata.setVersion(iatVersion);
        itemMetadata.setWordCount(defaultString(smarterAppMetadata.getWordCount()));

        itemMetadata.setWritingPurpose(
                mapIatWritingPurpose(smarterAppMetadata.getPtWritingType()));

        itemMetadata.setItemAuthor(smarterAppMetadata.getItemAuthorIdentifier()
                .stream().collect(Collectors.joining(",")));


        // ---
        // Mathematical Practice
        // ---
        List<String> mathematicalPractice = smarterAppMetadata.getMathematicalPractice();
        if (mathematicalPractice.size() >= 1) {
            itemMetadata.setPrimaryMathematicalPractice(mathematicalPractice.get(0));
        }
        if (mathematicalPractice.size() >= 2) {
            itemMetadata.setSecondaryMathematicalPractice(mathematicalPractice.get(1));
        }
        if (mathematicalPractice.size() >= 3) {
            itemMetadata.setTertiaryMathematicalPractice(mathematicalPractice.get(2));
        }
        if (mathematicalPractice.size() >= 4) {
            itemMetadata.setQuaternaryMathematicalPractice(mathematicalPractice.get(3));
        }

        // StandardPublication mapping
        if (itemMetadata.getSubject().equalsIgnoreCase("Math")) {
            smarterAppMetadata.getStandardPublication().forEach(stdPublication -> {
                if (stdPublication.getPublication().equalsIgnoreCase(IatImportConstants.STANDARD_PUB_FORMAT_MATH_V4)) {
                    // Map at least one PrimaryStandard element
                    StandardIdProps primaryProps = new StandardIdProps();
                    primaryProps.loadFromValue(
                            IatImportConstants.STANDARD_PUB_FORMAT_MATH_V4, stdPublication.getPrimaryStandard());
                    itemMetadata.setPrimaryClaim(primaryProps.getClaim());
                    itemMetadata.setPrimaryContentDomain(primaryProps.getDomain());
                    itemMetadata.setPrimaryTarget(primaryProps.getTarget());
                    itemMetadata.setPrimaryEmphasis(primaryProps.getEmphasis());
                    itemMetadata.setPrimaryCommonCoreStandard(primaryProps.getCommonCoreStandard());
                    //Map zero or many SecondaryStandard elements
                    int i = 1;
                    for (String secondStandard : stdPublication.getSecondaryStandard()) {
                        StandardIdProps secondaryProps = new StandardIdProps();
                        secondaryProps.loadFromValue(
                                IatImportConstants.STANDARD_PUB_FORMAT_MATH_V5, secondStandard);
                        switch (i) {
                            case 1:
                                itemMetadata.setSecondaryClaim(secondaryProps.getClaim());
                                itemMetadata.setSecondaryContentDomain(secondaryProps.getDomain());
                                itemMetadata.setSecondaryTarget(secondaryProps.getTarget());
                                itemMetadata.setSecondaryCommonCoreStandard(secondaryProps.getCommonCoreStandard());
                                break;
                            case 2:
                                itemMetadata.setTertiaryClaim(secondaryProps.getClaim());
                                itemMetadata.setTertiaryContentDomain(secondaryProps.getDomain());
                                itemMetadata.setTertiaryTarget(secondaryProps.getTarget());
                                itemMetadata.setTertiaryCommonCoreStandard(secondaryProps.getCommonCoreStandard());
                                break;
                            case 3:
                                itemMetadata.setQuaternaryClaim(secondaryProps.getClaim());
                                itemMetadata.setQuaternaryContentDomain(secondaryProps.getDomain());
                                itemMetadata.setQuaternaryTarget(secondaryProps.getTarget());
                                itemMetadata.setQuaternaryCommonCoreStandard(secondaryProps.getCommonCoreStandard());
                                break;
                        }
                        i++;
                    }
                } else if (stdPublication.getPublication()
                        .equalsIgnoreCase(IatImportConstants.STANDARD_PUB_FORMAT_MATH_V6)) {
                    // Map at least one PrimaryStandard element
                    StandardIdProps primaryProps = new StandardIdProps();
                    primaryProps.loadFromValue(
                            IatImportConstants.STANDARD_PUB_FORMAT_MATH_V6, stdPublication.getPrimaryStandard());
                    itemMetadata.setPrimaryClaim(primaryProps.getClaim());
                    itemMetadata.setTestCategory(primaryProps.getTestCategory());
                    itemMetadata.setPrimaryTargetSet(primaryProps.getTargetSet());
                    itemMetadata.setPrimaryTarget(primaryProps.getTarget());
                }
            });
        } else if (itemMetadata.getSubject().equalsIgnoreCase("ELA")) {
            int i = 0;
            for (SmarterAppMetadata.StandardPublication stdPublication : smarterAppMetadata.getStandardPublication()) {
                // Only process first ELA StandardPublication element
                if (stdPublication.getPublication().equalsIgnoreCase(
                        IatImportConstants.STANDARD_PUB_FORMAT_ELA_V1) && i == 0) {
                    StandardIdProps primaryProps = new StandardIdProps();
                    primaryProps.loadFromValue(
                            IatImportConstants.STANDARD_PUB_FORMAT_ELA_V1, stdPublication.getPrimaryStandard());
                    itemMetadata.setPrimaryClaim(primaryProps.getClaim());
                    itemMetadata.setPrimaryContentDomain(primaryProps.getDomain());
                    itemMetadata.setPrimaryTarget(primaryProps.getTarget());
                    itemMetadata.setPrimaryCommonCoreStandard(primaryProps.getCommonCoreStandard());
                }
                i++;
            }
        }

        return itemMetadata;
    }

    /**
     * @param item
     * @param metadata
     * @return
     */
    Item mapMetadata(Item item, SmarterAppMetadata metadata) {
        AssessmentItem assessmentItem = (AssessmentItem) item;
        assessmentItem.getCore().setMetadata(mapItemMetadata(metadata));
        return assessmentItem;
    }

    /**
     * @param item
     * @param itemProps
     * @return
     */
    Item mapAssociatedPassage(Item item, ItemProps itemProps) {
        AssessmentItem assessmentItem = (AssessmentItem) item;
        if (StringUtils.isNotBlank(itemProps.getImportAssociatedPassage())) {
            assessmentItem.getCore().setStimulusId(itemProps.getImportAssociatedPassage());
        }
        return assessmentItem;
    }

    /**
     * @param item
     * @param itemProps
     * @return
     */
    Item mapTutorial(Item item, ItemProps itemProps) {
        AssessmentItem assessmentItem = (AssessmentItem) item;
        if (StringUtils.isNotBlank(itemProps.getImportTutorialId())) {
            assessmentItem.getCore().setTutorialId(itemProps.getImportTutorialId());
        }
        return assessmentItem;
    }

    /**
     * Process attachments for non-Stimulus resources
     *
     * @param content
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    <T extends SaaifAttachmentlist<? extends SaaifAttachment>, S extends SaaifApipAccessibility> void processAttachments(
            SaaifContent<T, S> content,
            AbstractItem item,
            String itemSourceFullPath,
            String itemDestinationFullPath,
            ItemMappingResult itemMappingResult) {
        if (content.getAttachmentlist() != null && content.getLanguage().equals("ENU")) {
            for (SaaifAttachment<?> attachment : content.getAttachmentlist().getAttachment()) {
                if (attachment.getType().equalsIgnoreCase("ASL")) {
                    processAslAttachments(
                            attachment, item, itemSourceFullPath, itemDestinationFullPath, itemMappingResult);
                } else if (attachment.getType().equalsIgnoreCase("BRF")
                        || attachment.getType().equalsIgnoreCase("PRN")) {
                    processBrailleAttachment(
                            attachment.getFile(), item, itemSourceFullPath, itemDestinationFullPath, itemMappingResult);
                }
            }
        }
    }

    /**
     * @param item
     * @param saaifItem
     * @param sourceDir
     * @param destinationDir
     * @param itemMappingResult
     */
    void processMachineRubric(AbstractAssessmentItem item,
                              ItemRelease.Item saaifItem,
                              String sourceDir,
                              String destinationDir,
                              ItemMappingResult itemMappingResult) {

        Path sourceFolder = Paths.get(sourceDir);

        Path destinationFolder = Paths.get(destinationDir);

        File qrxFile = MigrationMapperUtil.getQrxFileFromSaaifItem(saaifItem, sourceDir);
        if (Objects.nonNull(qrxFile)) {
            MigrationFileUtil.copyFile(
                    sourceFolder.resolve(qrxFile.getName()),
                    destinationFolder.resolve(getQrxFileName(item.getId(), ITEM_VERSION)),
                    itemMappingResult);
            item.getCore().getScoring().setManagedByIat(false);
        }
    }

    /**
     * @param item
     * @param release
     * @param sourceDir
     * @param destinationDir
     * @param itemMappingResult
     */
    void processRendererSpec(EqItem item,
                             ItemRelease release,
                             String sourceDir,
                             String destinationDir,
                             ItemMappingResult itemMappingResult) {
        File eaxFile = MigrationMapperUtil.getRendererSpecFileFromItemRelease(release, sourceDir);
        if (null != eaxFile) {
            String from = sourceDir + "/" + eaxFile.getName();
            String to = destinationDir + "/" +
                    RepositoryUtil.getEaxFileName(item.getId(), ITEM_VERSION);
            MigrationFileUtil.copyFile(from, to, itemMappingResult);
            item.getCore().getEquationEditorConfiguration().setManagedByIat(false);
        }
    }

    /**
     * Process Asl Attachments for non-stimulus items. ItemRelease.Item.Content.Attachmentlist.Attachment
     *
     * @param attachment
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    <T extends SaaifAttachmentSource> void processAslAttachments(SaaifAttachment<T> attachment,
                                                                 AbstractItem item,
                                                                 String itemSourceFullPath,
                                                                 String itemDestinationFullPath,
                                                                 ItemMappingResult itemMappingResult) {
        Path sourceFolder = Paths.get(itemSourceFullPath);
        Path destinationFolder = Paths.get(itemDestinationFullPath);

        if (attachment.getSource() != null) {
            attachment.getSource().forEach(source -> {
                String sourceFilename = source.getSrc();
                String destinationFilename = source.getSrc();

                // don't rename if the file is using the item id already
                if (!StringUtils.contains(destinationFilename, item.getId())) {
                    // renamed the destination file
                    destinationFilename = sourceFilename
                            .toLowerCase()
                            .replace(item.getItsId(), item.getId())
                            .replace("_asl_stem.", "_ASL_STEM.");
                }

                item.getAsl().getAttachments().add(
                        newItemAttachment(
                                destinationFilename,
                                sourceFolder.resolve(sourceFilename),
                                destinationFolder.resolve(destinationFilename),
                                itemMappingResult));

                item.getAsl().setAslProvided(true);
                item.getAsl().setAslRequired("true");
            });
        } else if (isNotBlank(attachment.getFile())) {
            String sourceFilename = attachment.getFile();
            String destinationFilename = attachment.getFile();

            // don't rename if the file is using the item id already
            if (!StringUtils.contains(destinationFilename, item.getId())) {
                // renamed the destination file
                destinationFilename = sourceFilename
                        .toLowerCase()
                        .replace(item.getItsId(), item.getId())
                        .replace("_asl_stem.", "_ASL_STEM.");
            }

            item.getAsl().getAttachments().add(
                    newItemAttachment(
                            destinationFilename,
                            sourceFolder.resolve(sourceFilename),
                            destinationFolder.resolve(destinationFilename),
                            itemMappingResult));

            item.getAsl().setAslProvided(true);
            item.getAsl().setAslRequired("true");
        }
    }

    /**
     * Process Braille attachments for all item types
     *
     * @param fileName
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    void processBrailleAttachment(String fileName,
                                  AbstractItem item,
                                  String itemSourceFullPath,
                                  String itemDestinationFullPath,
                                  ItemMappingResult itemMappingResult) {

        Path sourceFolder = Paths.get(itemSourceFullPath);
        Path destinationFolder = Paths.get(itemDestinationFullPath);

        String destinationFilename = BrailleUtil.makeValid(fileName)
                .toLowerCase()
                .replace(item.getItsId(), item.getId());

        item.getBraille().getAttachments().add(
                newItemAttachment(
                        destinationFilename,
                        sourceFolder.resolve(fileName),
                        destinationFolder.resolve(destinationFilename),
                        itemMappingResult));

        item.getBraille().setBrailleProvided(true);
        item.getBraille().setBrailleRequired("true");
    }

    /**
     * Create a new IAT Attachment and attempt to copy file to Item local directory.
     *
     * @param fileName
     * @param sourceFile
     * @param destinationFile
     * @return
     */
    Attachment newItemAttachment(String fileName,
                                 Path sourceFile,
                                 Path destinationFile,
                                 ItemMappingResult itemMappingResult) {
        MigrationFileUtil.copyFile(sourceFile, destinationFile, itemMappingResult);
        return createAttachment(fileName);
    }


    /**
     * Used during Migration for all item types. Creates item image resources and copies related files to destination
     * directory.
     *
     * @param mappingProperties
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    public void processImageResources(ItemMappingProperties mappingProperties,
                                      AbstractItem item,
                                      String itemSourceFullPath,
                                      String itemDestinationFullPath) {
        ItemMappingResult mappingResult = new ItemMappingResult();
        processImageResources(mappingProperties,
                item,
                itemSourceFullPath,
                itemDestinationFullPath,
                mappingResult);
    }

    /**
     * Used during Import for all item types. Creates item image resources and copies related files to destination
     * directory.
     *
     * @param mappingProperties
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    void processImageResources(ItemMappingProperties mappingProperties,
                               AbstractItem item,
                               String itemSourceFullPath,
                               String itemDestinationFullPath,
                               ItemMappingResult mappingResult) {

        Path sourceFolder = Paths.get(itemSourceFullPath);
        Path destinationFolder = Paths.get(itemDestinationFullPath);

        mappingProperties.getImageSources().forEach(image -> {
            String destinationFilename = image.getSource();

            if (!destinationFilename.contains(item.getId())) {
                destinationFilename = destinationFilename.toLowerCase().replace(item.getItsId(), item.getId());
            }

            item.getImages().getImageResources().add(
                    createItemImageResource(destinationFilename, image.getImageId()));

            MigrationFileUtil.copyFile(
                    sourceFolder.resolve(image.getSource()),
                    destinationFolder.resolve(destinationFilename),
                    mappingResult);
        });
    }

    /**
     * Maps a WordlistReleaseType to GlossaryTerm
     *
     * @param item
     * @param itemLocalPath
     * @param wordlistreleaseType
     * @param wordListFullPath
     * @return
     */
    Item mapWordlistToGlossaryTerms(Item item,
                                    Path itemLocalPath,
                                    WordlistreleaseType wordlistreleaseType,
                                    String wordListFullPath,
                                    ItemMappingResult itemMappingResult) {
        item.getGlossary().getTerms().clear();

        wordlistreleaseType.getItem().getKeywordList().getKeyword().forEach(keyword -> {
            GlossaryTerm glossaryTerm =
                    newGlossaryTerm(Integer.toString(keyword.getIndex()), keyword.getText());

            GlossaryFileProps glossaryFileProps = new GlossaryFileProps();
            glossaryFileProps.setItemId(item.getId());

            glossaryTerm.setLanguages(
                    getIatGlossaryLanguages(glossaryFileProps, keyword, itemLocalPath, wordListFullPath,
                            itemMappingResult));

            item.getGlossary().getTerms().add(glossaryTerm);
        });

        setGlossaryInfo(item);

        return item;
    }

    private void setGlossaryInfo(Item item) {
        item.getGlossary()
                .setIllustratedGlossaryRequired(calculateIllustratedGlossaryRequired(item.getGlossary().getTerms()));
        item.getGlossary()
                .setTranslatedGlossaryRequired(calculatedTranslatedGlossaryRequired(item.getGlossary().getTerms()));
        item.getGlossary().setIllustratedGlossaryProvided(
                Boolean.TRUE.toString().equals(item.getGlossary().getIllustratedGlossaryRequired()));
        item.getGlossary().setTranslatedGlossaryProvided(
                Boolean.TRUE.toString().equals(item.getGlossary().getTranslatedGlossaryRequired()));

        if (!WorkflowStatusEnum.ParkingLot.isEqual(item.getWorkflow().getWorkflowStatusCode())) {
            item.getGlossary().setEnglishGlossaryProvided(calculateEnglishProvided(item.getGlossary().getTerms()));
        }
    }

    private String calculateIllustratedGlossaryRequired(List<GlossaryTerm> terms) {
        Optional<GlossaryTerm> illustratedTerm = terms.stream()
                .filter(glossaryTerm -> isNotBlank(glossaryTerm.getIllustrationImageResourceId()))
                .findAny();

        return illustratedTerm.isPresent() ? Boolean.TRUE.toString() : undetermined;
    }

    private String calculatedTranslatedGlossaryRequired(List<GlossaryTerm> terms) {
        Optional<GlossaryTerm> illustratedTerm = terms.stream()
                .filter(glossaryTerm -> isTranslatedTerms(glossaryTerm.getLanguages()))
                .findAny();

        return illustratedTerm.isPresent() ? Boolean.TRUE.toString() : undetermined;
    }

    private boolean calculateEnglishProvided(List<GlossaryTerm> terms) {
        if (terms.isEmpty()) {
            return false;
        }

        for (GlossaryTerm term : terms) {
            if (term.getLanguages().getEnglish().getDialects().isEmpty()) {
                return false;
            }

            Optional<GlossaryDialect> dialectWithEnglish = term.getLanguages().getEnglish().getDialects()
                    .stream()
                    .filter(glossaryDialect -> isNotBlank(glossaryDialect.getDefinition()))
                    .findAny();

            if (!dialectWithEnglish.isPresent()) {
                return false;
            }
        }

        return true;
    }

    private boolean isTranslatedTerms(GlossaryLanguages glossaryLanguages) {
        return isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getArabic())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getBurmese())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getCantonese())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getFilipino())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getHmong())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getKorean())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getMandarin())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getPunjabi())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getRussian())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getSomali())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getSpanish())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getUkrainian())
                || isTranslatedGlossaryLanguageContainNonBlankValues(glossaryLanguages.getVietnamese());

    }

    private boolean isTranslatedGlossaryLanguageContainNonBlankValues(GlossaryLanguage language) {
        for (GlossaryDialect dialect : language.getDialects()) {
            if (StringUtils.isNotBlank(dialect.getDefinition())) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns content before language divider tag
     * <p class="languagedivider">&#xA0;</p>
     *
     * @param content
     * @return
     */
    String getEsnContent(String content) {
        int dividerStart = content.indexOf(LANGUAGE_DIVIDER_TAG);

        if (dividerStart != -1) {
            return content.substring(0, dividerStart);
        }

        return content;
    }

    /**
     * Helper to create a new GlossaryTerm
     *
     * @param termId
     * @param term
     * @return
     */
    private GlossaryTerm newGlossaryTerm(String termId,
                                         String term) {
        GlossaryTerm glossaryTerm = new GlossaryTerm();
        glossaryTerm.setId(termId);
        glossaryTerm.setTerm(term);
        return glossaryTerm;
    }

    /**
     * Maps a List<HtmlType> to a GlossaryLanguages object
     *
     * @param glossaryFileProps
     * @param keyword
     * @param itemLocalPath
     * @param wordlistFullPath
     * @return
     */
    private GlossaryLanguages getIatGlossaryLanguages(GlossaryFileProps glossaryFileProps,
                                                      KeywordType keyword,
                                                      Path itemLocalPath,
                                                      String wordlistFullPath,
                                                      ItemMappingResult itemMappingResult) {
        GlossaryLanguages glossaryLanguages = new GlossaryLanguages();
        keyword.getHtml().forEach(htmlType -> {
            if (htmlType.getListType().toLowerCase().contains("glossary")) {
                glossaryFileProps.setTermId(Integer.toString(keyword.getIndex()));
                setDialectsOnLanguage(glossaryFileProps, glossaryLanguages, itemLocalPath, htmlType, wordlistFullPath,
                        itemMappingResult);
            }
        });
        checkForDefaultDialects(glossaryLanguages);

        return glossaryLanguages;
    }

    /**
     * Sets List<Dialect> for all languages found on import source file
     *
     * @param glossaryFileProps
     * @param glossaryLanguages
     * @param itemLocalPath
     * @param html
     * @param wordlistFullPath
     */
    private void setDialectsOnLanguage(GlossaryFileProps glossaryFileProps,
                                       GlossaryLanguages glossaryLanguages,
                                       Path itemLocalPath,
                                       HtmlType html,
                                       String wordlistFullPath,
                                       ItemMappingResult itemMappingResult) {
        String listCode = html.getListCode();

        glossaryFileProps.setLanguageName(getLanguageName(listCode));

        List<GlossaryDialect> dialects = createGlossaryDialectList(
                glossaryFileProps,
                itemLocalPath,
                html.getValue(),
                wordlistFullPath,
                itemMappingResult);

        switch (listCode) {
            case GlossaryConstants.ListCode.ARABIC: {
                glossaryLanguages.getArabic().getDialects().clear();
                glossaryLanguages.getArabic().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.BURMESE: {
                glossaryLanguages.getBurmese().getDialects().clear();
                glossaryLanguages.getBurmese().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.CANTONESE: {
                glossaryLanguages.getCantonese().getDialects().clear();
                glossaryLanguages.getCantonese().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.ENGLISH: {
                glossaryLanguages.getEnglish().getDialects().clear();
                glossaryLanguages.getEnglish().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.FILIPINO: {
                glossaryLanguages.getFilipino().getDialects().clear();
                glossaryLanguages.getFilipino().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.HMONG: {
                glossaryLanguages.getHmong().getDialects().clear();
                glossaryLanguages.getHmong().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.KOREAN: {
                glossaryLanguages.getKorean().getDialects().clear();
                glossaryLanguages.getKorean().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.MANDARIN: {
                glossaryLanguages.getMandarin().getDialects().clear();
                glossaryLanguages.getMandarin().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.PUNJABI: {
                glossaryLanguages.getPunjabi().getDialects().clear();
                glossaryLanguages.getPunjabi().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.RUSSIAN: {
                glossaryLanguages.getRussian().getDialects().clear();
                glossaryLanguages.getRussian().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.SOMALI: {
                glossaryLanguages.getSomali().getDialects().clear();
                glossaryLanguages.getSomali().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.SPANISH: {
                glossaryLanguages.getSpanish().getDialects().clear();
                glossaryLanguages.getSpanish().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.UKRAINIAN: {
                glossaryLanguages.getUkrainian().getDialects().clear();
                glossaryLanguages.getUkrainian().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.VIETNAMESE: {
                glossaryLanguages.getVietnamese().getDialects().clear();
                glossaryLanguages.getVietnamese().getDialects().addAll(dialects);
                break;
            }
        }
    }


    /**
     * Creates a List<GlossaryDialect> based on the html content provided on import source file
     *
     * @param itemLocalPath
     * @param htmlContent
     * @param wordlistFullPath
     * @return
     */
    private List<GlossaryDialect> createGlossaryDialectList(GlossaryFileProps glossaryFileProps,
                                                            Path itemLocalPath,
                                                            String htmlContent,
                                                            String wordlistFullPath,
                                                            ItemMappingResult itemMappingResult) {
        List<GlossaryDialect> glossaryDialects = new ArrayList<>();

        final Document doc = Jsoup.parseBodyFragment(htmlContent);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        Elements spans = doc.getElementsByTag("span");
        spans.forEach(span -> {
            span.attr("style", "");
        });

        Elements parTags = doc.getElementsByTag("p");

        // Expect only one wrapping <p> tag
        if (parTags.size() == 1) {
            String html = parTags.get(0).html();

            String[] dialectHtml = html.split(",");

            int dialectId = 0;

            for (String dialectString : dialectHtml) {
                final Document dialectDoc = Jsoup.parseBodyFragment(dialectString);
                dialectDoc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

                dialectId++;
                String dialectValue = dialectDoc.text();

                GlossaryDialect glossaryDialect = new GlossaryDialect();
                glossaryDialect.setId(Integer.toString(dialectId));
                glossaryDialect.setDefinition(dialectValue.trim());

                Elements aTags = dialectDoc.getElementsByTag("a");
                aTags.forEach(a -> {
                    if (a.attr("type").equals("audio/ogg") && StringUtils.isNotBlank(a.attr("href"))) {
                        glossaryFileProps.setDialectId(glossaryDialect.getId());
                        glossaryFileProps.setFileName(a.attr("href"));
                        addDialectAttachment(
                                glossaryFileProps,
                                glossaryDialect,
                                itemLocalPath,
                                wordlistFullPath,
                                itemMappingResult);
                    }
                });

                glossaryDialects.add(glossaryDialect);
            }
        }

        return glossaryDialects;
    }

    /**
     * Adds Attachment object to Dialect. Copies audio files to item's glossary folder
     *
     * @param glossaryDialect
     * @param itemLocalPath
     * @param wordListFullPath
     */
    private void addDialectAttachment(GlossaryFileProps glossaryFileProps,
                                      GlossaryDialect glossaryDialect,
                                      Path itemLocalPath,
                                      String wordListFullPath,
                                      ItemMappingResult itemMappingResult) {

        glossaryDialect.getAudioFiles().add(createAttachment(glossaryFileProps.getFileName()));

        File oggFile = new File(wordListFullPath + "/" + glossaryFileProps.getFileName());
        if (oggFile.exists()) {
            String oggIatFileName = glossaryFileProps.getFileName();

            MigrationFileUtil.copyFile(oggFile,
                    Paths.get(itemLocalPath.toString(), "glossary", oggIatFileName).toFile(),
                    itemMappingResult);

            String m4aFileName = glossaryFileProps.getFileName().replace(".ogg", ".m4a");
            File m4aFile = new File(wordListFullPath + "/" + m4aFileName);
            if (m4aFile.exists()) {
                String m4aIatFileName = m4aFileName;

                MigrationFileUtil.copyFile(m4aFile,
                        Paths.get(itemLocalPath.toString(), "glossary", m4aIatFileName).toFile(),
                        itemMappingResult);
            }
        }
    }


    /**
     * Ensures GlossaryLanguage contains the minimum amount of Dialects
     *
     * @param glossaryLanguages
     */
    private void checkForDefaultDialects(GlossaryLanguages glossaryLanguages) {
        setMinimumDialectsForLanguage(glossaryLanguages.getArabic(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getBurmese(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getCantonese(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getEnglish(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getFilipino(), 2);
        setMinimumDialectsForLanguage(glossaryLanguages.getHmong(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getKorean(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getMandarin(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getPunjabi(), 2);
        setMinimumDialectsForLanguage(glossaryLanguages.getRussian(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getSomali(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getSpanish(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getUkrainian(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getVietnamese(), 1);
    }

    /**
     * Adds GlossaryDialect objects when minimum amount is not found
     *
     * @param glossaryLanguage
     * @param minimumDialects
     */
    private void setMinimumDialectsForLanguage(GlossaryLanguage glossaryLanguage, int minimumDialects) {
        if (glossaryLanguage.getDialects().size() < minimumDialects) {
            for (int i = glossaryLanguage.getDialects().size(); i < minimumDialects; i++) {
                glossaryLanguage.getDialects().add(new GlossaryDialect());
            }
        }

    }

    /**
     * @param image
     * @param imageId
     * @return
     */
    private ItemImageResource createItemImageResource(String image, int imageId) {
        ItemImageResource resource = new ItemImageResource();
        resource.setProductionFileProvided(true);
        resource.setId(Integer.toString(imageId));
        resource.getProductionFile().setFileName(image);
        resource.getProductionFile().setUploadedDate(new Date());
        return resource;
    }

    /**
     * @param fileName
     * @return
     */
    Attachment createAttachment(String fileName) {
        Attachment attach = new Attachment();
        attach.setFileName(fileName);
        attach.setUploadedDate(new Date());
        return attach;
    }

    /**
     * @param itemId
     * @param sourceItemFullPath
     * @return
     */
    List<String> getCorrectResponsesFromQrx(String itemId,
                                            String sourceItemFullPath,
                                            String identifier) {
        List<String> values = new ArrayList<>();
        File qrxFile = MigrationFileUtil.findFileInPath(
                sourceItemFullPath, format("item_%s_*.qrx", itemId));
        if (qrxFile != null && qrxFile.exists()) {
            String qrxContent = MigrationFileUtil.fileToString(qrxFile);
            final Document doc = Jsoup.parse(qrxContent, "", Parser.xmlParser());

            doc.getElementsByTag("responseDeclaration").forEach(respDeclaration -> {
                if (respDeclaration.attr("identifier").equals(identifier)) {
                    respDeclaration.getElementsByTag("value").forEach(value -> {
                        values.add(value.text());
                    });
                }
            });
        }
        return values;
    }

    /**
     * Used on all items except Stimulus
     *
     * @param content       String content to be mapped
     * @param accessibility ItemRelease.Item.Content that contains the TTS content
     * @return
     */
    <T extends SaaifAccessibilityInfo> String processTTSTags(String content, SaaifApipAccessibility<T> accessibility) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        if (accessibility != null) {
            accessibility.getAccessibilityInfo().getAccessElement().forEach(accessElement -> {
                final Element ttsTag = doc.getElementById(
                        accessElement.getContentLinkInfo().getItsLinkIdentifierRef());

                if (ttsTag != null) {
                    String tts = "";
                    String ttsAlt = "";
                    if (accessElement.getContentLinkInfo().getType().equals("Text")) {
                        tts = defaultString(
                                accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciation());
                        ttsAlt = defaultString(accessElement.getRelatedElementInfo().getReadAloud()
                                .getTextToSpeechPronunciationAlternate());
                    } else if (accessElement.getContentLinkInfo().getType().equals("Graphic")) {
                        tts = defaultString(accessElement.getRelatedElementInfo().getReadAloud().getAudioText());
                    }
                    mapSaaifTTSTagToIATTag(ttsTag, tts, ttsAlt);
                }
            });
        }

        return doc.body().html();
    }

    void mapSaaifTTSTagToIATTag(Element ttsTag, String tts, String ttsAlt) {
        ttsTag.addClass("iat-text2speech");
        // tts has a value
        if (StringUtils.isNotEmpty(tts)) {
            ttsTag.attr("data-iat-tts", tts);
            if (StringUtils.isEmpty(ttsAlt)) {
                ttsTag.attr("data-iat-tts-vi", tts);
            }
        }
        // ttsAlt has a value
        if (StringUtils.isNotEmpty(ttsAlt)) {
            ttsTag.attr("data-iat-tts-vi", ttsAlt);
            if (StringUtils.isEmpty(tts)) {
                ttsTag.attr("data-iat-tts", ttsAlt);
            }
        }
        // None have values
        if (StringUtils.isEmpty(tts) && StringUtils.isEmpty(ttsAlt)) {
            ttsTag.attr("data-iat-tts", tts);
            ttsTag.attr("data-iat-tts-vi", ttsAlt);
        }
        ttsTag.removeAttr("id");
    }

    /**
     * @param content
     * @param mappingProperties
     * @return
     */
    private String processImageTags(String content, ItemMappingProperties mappingProperties) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("img").forEach(image -> {
            IatImage imageLookup = mappingProperties.getImageSources().stream()
                    .filter(img -> img.getSource().equals(image.attr("src")))
                    .findAny()
                    .orElse(null);

            int imageId;

            if (Objects.isNull(imageLookup)) {
                IatImage iatImage = new IatImage(mappingProperties.incrementAndGetImageSourceCount());
                iatImage.setSource(image.attr("src"));
                mappingProperties.getImageSources().add(iatImage);
                imageId = iatImage.getImageId();
            } else {
                imageId = imageLookup.getImageId();
            }

            Element img = new Element("img");
            img.attr("title", "Image Resource " + imageId);
            img.attr("data-iat-image-resource-id", Integer.toString(imageId));
            img.attr("src", getImagePlaceholderSrc(imageId));
            img.addClass("place-holder");

            if (isNotBlank(image.attr("data-iat-tts"))) {
                img.attr("data-iat-tts", image.attr("data-iat-tts"));
            }

            if (isNotBlank(image.attr("data-iat-tts-vi"))) {
                img.attr("data-iat-tts-vi", image.attr("data-iat-tts-vi"));
            }

            image.replaceWith(img);
        });

        return doc.body().html();
    }

    /**
     * @param content
     * @param mappingProperties
     * @return
     */
    private String processAnchorTags(String content, ItemMappingProperties mappingProperties) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("a").forEach(anchor -> {
            mappingProperties.getFileSources().add(anchor.attr("href"));
        });

        return doc.body().html();
    }

    /**
     * @param content
     * @return
     */
    private String processTableTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("table").forEach(table -> {
            Attributes tableAtribs = table.attributes().clone();
            table.clearAttributes();
            table.attr("cellpadding", "1");
            table.attr("cellspacing", "1");
            table.attr("border", "1");

            if (StringUtils.isNotBlank(tableAtribs.get("style"))) {
                table.attr("style",
                        convertEmStyleToPixel(tableAtribs.get("style"), "width"));
            }

            table.getElementsByTag("colgroup").forEach(Node::remove);

            table.getElementsByTag("tr").forEach(tr -> {
                tr.getElementsByTag("td").forEach(Node::clearAttributes);
            });
        });

        return doc.body().html();
    }

    /**
     * @param content
     * @return
     */
    private String processListTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("ul").forEach(Node::clearAttributes);
        doc.getElementsByTag("ol").forEach(Node::clearAttributes);

        return doc.body().html();
    }

    /**
     * @param content
     * @return
     */
    private String processImageSlidesTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByClass("slides_config hidden")
                .forEach(Node::clearAttributes);

        doc.getElementsByClass("slides_container")
                .forEach(container -> {
                    Element span = new Element("span");
                    span.attr("iat-image-slide-placeholder", "");
                    span.text("(Image slideshows are not supported)");

                    container.replaceWith(span);
                });

        return doc.body().html();
    }

    /**
     * @param content
     * @return
     */
    private String processGlossaryTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        Elements startBoundaySpans = doc.getElementsByAttributeValue("data-tag-boundary", "start");
        Elements endBoudarySpans = doc.getElementsByAttributeValue("data-tag-boundary", "end");

        startBoundaySpans.forEach(startSpan -> {
            String iatGlossSpan = format("<span class=\"iat-glossary-term\" data-iat-glossary-term-id=\"%s\">",
                    startSpan.attr("data-word-index"));
            startSpan.replaceWith(new TextNode(iatGlossSpan, null));
        });

        endBoudarySpans.forEach(endSpan -> {
            endSpan.replaceWith(new TextNode("</span>", null));
        });

        return doc.body().html()
                .replace("&lt;", "<")
                .replace("&gt;", ">");
    }

    /**
     * @param styleDef
     * @param styleName
     * @return
     */
    private String convertEmStyleToPixel(String styleDef, String styleName) {
        String saaifStyle = "";
        String value = getStyleValue(styleDef, styleName);
        if (StringUtils.isNotBlank(value)) {
            // TODO: Currently only supports en unit conversion
            if (value.contains("em")) {
                int val = (int) Float.parseFloat(value.replace("em", ""));
                saaifStyle = styleName + ":" + convertEmtoPixel(val) + ";";
            }
        }
        return saaifStyle;
    }

    /**
     * @param em
     * @return
     */
    private String convertEmtoPixel(int em) {
        try {
            final int pxUnit = em * PIXEL_TO_EM_CONVERSION_RATE;
            return format("%1d", pxUnit).concat("px");
        } catch (Exception ex) {
            return "";
        }
    }

    /**
     * Attempts to retrieve the the value of an inline style from a style definition string
     *
     * @param styleDef  e.g. "text-align:center; font-weight:bold; width: 500px; height: 200px"
     * @param styleName e.g. "width"
     * @return value of style or empty string if not found
     */
    private String getStyleValue(String styleDef, String styleName) {
        String styleVal = "";
        List<String> stylesList = Arrays.asList(styleDef.split(";"));
        for (String style : stylesList) {
            List<String> currStyle = Arrays.asList(style.split(":"));
            if (isNotEmpty(currStyle)) {
                if (currStyle.get(0).trim().equals(styleName)) {
                    styleVal = currStyle.get(1).trim();
                    break;
                }
            }
        }
        return styleVal;
    }

    /**
     * @param imageId
     * @return
     */
    private String getImagePlaceholderSrc(int imageId) {
        return "/assets/ckeditor/plugins/iatimage/icons/image-place-" +
                (imageId < 10 ? "0" : "") +
                imageId + ".png";
    }

    /**
     * Returns an empty string if the argument is null.  If the argument is not null it is trimmed.
     *
     * @param str The value to trim.
     * @return Empty string if null passed in otherwise the argument is returned trimmed.
     */
    protected String defaultString(String str) {
        return StringUtils.defaultString(str).trim();
    }

    /**
     * @param saaifValue
     * @return
     */
    private String mapYandNtoYesandNo(String saaifValue) {
        return "Y".equalsIgnoreCase(saaifValue) ? "Yes" : "N".equalsIgnoreCase(saaifValue) ? "No" : "";
    }

    /**
     * @param saaifValue
     * @return
     */
    private String mapClaim2Category(String saaifValue) {
        return "C".equalsIgnoreCase(saaifValue) ? "Conventions" :
                "E".equalsIgnoreCase(saaifValue) ? "EvidenceElaboration" :
                        "O".equalsIgnoreCase(saaifValue) ? "Organization" : "";

    }

    /**
     * @param saaifValue
     * @return
     */
    private String mapIatWritingPurpose(String saaifValue) {
        String value = "";
        if (saaifValue != null) {
            List<String> purposeValues = Arrays.asList("Narrative", "InformationalExplanatory", "OpinionArgumentative");
            value = purposeValues.stream()
                    .filter(purpose -> purpose.toLowerCase().contains(saaifValue.toLowerCase()))
                    .findAny()
                    .orElse("");
        }
        return value;
    }

    /**
     * @param saaifValue
     * @return
     */
    private String mapIatSubject(String saaifValue) {
        String value = "";
        if (saaifValue.equalsIgnoreCase("math")) {
            value = "Math";
        } else if (saaifValue.equalsIgnoreCase("ela")) {
            value = "ELA";
        }
        return value;
    }

    /**
     * @param html
     * @return
     */
    String convertInteractiveTagsToIat(String html) {
        final Document doc = Jsoup.parseBodyFragment(html);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByClass("interaction selectable").forEach(span -> {
            span.clearAttributes();
            span.addClass("iat-htq-correct");
        });

        return doc.body().html();
    }

    /**
     * @param listCode
     * @return
     */
    private String getLanguageName(String listCode) {
        String language = "";

        switch (listCode) {
            case GlossaryConstants.ListCode.ARABIC: {
                language = "arabic";
                break;
            }
            case GlossaryConstants.ListCode.BURMESE: {
                language = "burmese";
                break;
            }
            case GlossaryConstants.ListCode.CANTONESE: {
                language = "cantonese";
                break;
            }
            case GlossaryConstants.ListCode.ENGLISH: {
                language = "english";
                break;
            }
            case GlossaryConstants.ListCode.FILIPINO: {
                language = "filipino";
                break;
            }
            case GlossaryConstants.ListCode.HMONG: {
                language = "hmong";
                break;
            }
            case GlossaryConstants.ListCode.KOREAN: {
                language = "korean";
                break;
            }
            case GlossaryConstants.ListCode.MANDARIN: {
                language = "mandarin";
                break;
            }
            case GlossaryConstants.ListCode.PUNJABI: {
                language = "punjabi";
                break;
            }
            case GlossaryConstants.ListCode.RUSSIAN: {
                language = "russian";
                break;
            }
            case GlossaryConstants.ListCode.SOMALI: {
                language = "somali";
                break;
            }
            case GlossaryConstants.ListCode.SPANISH: {
                language = "spanish";
                break;
            }
            case GlossaryConstants.ListCode.UKRAINIAN: {
                language = "ukrainian";
                break;
            }
            case GlossaryConstants.ListCode.VIETNAMESE: {
                language = "vietnamese";
                break;
            }
        }

        return language;
    }

}
