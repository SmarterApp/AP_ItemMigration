package org.opentestsystem.ap.migration.mapper;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.MapUtils;
import org.apache.commons.lang3.StringUtils;
import org.jsoup.Jsoup;
import org.jsoup.nodes.*;
import org.jsoup.parser.Parser;
import org.jsoup.select.Elements;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.exception.ValidationException;
import org.opentestsystem.ap.common.itembank.AttachmentValidator;
import org.opentestsystem.ap.common.model.*;
import org.opentestsystem.ap.common.model.glossary.*;
import org.opentestsystem.ap.common.repository.RepositoryUtil;
import org.opentestsystem.ap.common.saaif.item.ItemRelease;
import org.opentestsystem.ap.common.saaif.item.SaaifApipAccessibility;
import org.opentestsystem.ap.common.saaif.metadata.SmarterAppMetadata;
import org.opentestsystem.ap.common.saaif.wordlist.HtmlType;
import org.opentestsystem.ap.common.saaif.wordlist.KeywordType;
import org.opentestsystem.ap.common.saaif.wordlist.WordlistreleaseType;
import org.opentestsystem.ap.migration.model.*;
import org.opentestsystem.ap.migration.util.MigrationFileUtil;
import org.opentestsystem.ap.migration.util.MigrationMapperUtil;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static java.lang.String.format;
import static org.apache.commons.collections4.CollectionUtils.isNotEmpty;
import static org.opentestsystem.ap.common.model.ItemConstants.Section.SECTION_AUDIO;


@Slf4j
public abstract class IatModelMapper {

    public static final String EMPTY_PARAGRAPH_TAG = "<p style=\"\">&#xA0;</p>";

    private static final Map<String, String> scoreEngineMap = new HashMap<>();

    private final int PIXEL_TO_EM_CONVERSION_RATE = 16;

    private final String LANGUAGE_DIVIDER_TAG = "<p class=\"languagedivider\">";

    static {
        scoreEngineMap.put("Automatic with Machine Rubric", "AutomaticWithRubric");
    }

    abstract Item mapContent(Item item,
                             ItemRelease release,
                             Path itemLocalPath,
                             String itemSourceFullPath,
                             ItemMappingResult itemMappingResult);

    /**
     * Uses the ItemRelease to fully hydrate the Item object
     * Main item Saaif mapping function used during import
     *
     * @param itemProps          Contains all ids that will be used during import
     * @param item               Object that will be hydrated during mapping
     * @param release            Source data used during mapping
     * @param metadata           Items metadata object
     * @param wordListRelease    Items Wordlist
     * @param wordlistFullPath   File system location of the source Wordlist files
     * @param itemLocalPath      Path to items temporary directory
     * @param itemDirFullPath    File system location of the source Item files
     * @param mappingResult      Collects item mapping status and additiona properties
     * @return
     */
    public final Item mapSaaifToIATModel(ItemProps itemProps,
                                         Item item,
                                         ItemRelease release,
                                         SmarterAppMetadata metadata,
                                         WordlistreleaseType wordListRelease,
                                         String wordlistFullPath,
                                         Path itemLocalPath,
                                         String itemDirFullPath,
                                         ItemMappingResult mappingResult) {
        if (null != wordListRelease) {
            item = mapWordlistToGlossaryTerms(item, itemLocalPath, wordListRelease, wordlistFullPath, mappingResult);
        }
        item = mapContent(item, release, itemLocalPath, itemDirFullPath, mappingResult);
        item = mapMetadata(item, metadata);
        item = mapAssociatedPassage(item, itemProps);
        item = mapTutorial(item, itemProps);
        return item;
    }

    /**
     * Uses the WordlistreleaseType to hydrate the items glossary section
     * Main glossary Saaif mapping function used during import
     *
     * @param item              Object that will be hydrated during mapping
     * @param wordListRelease   Items Wordlist
     * @param wordlistFullPath  File system location of the source Wordlist files
     * @param itemLocalPath     Path to items temporary directory
     * @param mappingResult     Collects item mapping status and additiona properties
     * @return
     */
    public final Item mapWordlistToItem(Item item,
                                        WordlistreleaseType wordListRelease,
                                        String wordlistFullPath,
                                        Path itemLocalPath,
                                        ItemMappingResult mappingResult) {
        if (null != wordListRelease) {
            item = mapWordlistToGlossaryTerms(item, itemLocalPath, wordListRelease, wordlistFullPath, mappingResult);
        }
        return item;
    }

    /**
     * Main rich text mapping function used in non-stimulus items during migration.
     *
     * @param content
     * @param apipAccessibility
     * @param mappingProperties
     * @return
     */
    public final ItemMappingProperties mapSingleRichTextContent(String content,
                                                                ItemRelease.Item.Content.ApipAccessibility apipAccessibility,
                                                                ItemMappingProperties mappingProperties) {

        mappingProperties = mapRichTextContent(content, apipAccessibility, mappingProperties);

        return mappingProperties;
    }

    /**
     * Main rich text mapping function used in non-stimulus items during migration.
     *
     * @param content
     * @param apipAccessibility
     * @param mappingProperties
     * @return
     */
    public final ItemMappingProperties mapSingleRichTextContent(String content,
                                                                ItemRelease.Passage.Content.ApipAccessibility apipAccessibility,
                                                                ItemMappingProperties mappingProperties) {

        mappingProperties = mapRichTextContent(content, apipAccessibility, mappingProperties);

        return mappingProperties;
    }

    /**
     * Main rich text mapping function used in non-stimulus items during import.
     * TTS is processed first since it uses the ItemRelease.Item.Content.ApipAccessibility static object
     *
     * @param content
     * @param mappingProperties
     * @return
     */
    ItemMappingProperties mapRichTextContent(String content,
                                             ItemRelease.Item.Content.ApipAccessibility apipAccessibility,
                                             ItemMappingProperties mappingProperties) {
        String iatContent = processTTSTags(content, apipAccessibility);
        mappingProperties.setContent(processCommonTags(iatContent, mappingProperties));
        return mappingProperties;
    }

    /**
     * Main rich text mapping function used ONLY in stimulus items
     * TTS is processed first since it uses the ItemRelease.Passage.Content.ApipAccessibility static object
     *
     * @param content
     * @param mappingProperties
     * @return
     */
    ItemMappingProperties mapRichTextContent(String content,
                                             ItemRelease.Passage.Content.ApipAccessibility apipAccessibility,
                                             ItemMappingProperties mappingProperties) {
        String iatContent = processTTSTags(content, apipAccessibility);
        mappingProperties.setContent(processCommonTags(iatContent, mappingProperties));
        return mappingProperties;
    }

    /**
     * Process common tags to both ItemRelease.Item and ItemRelease.Passage resources
     * @param content
     * @param mappingProperties
     * @return
     */
    private String processCommonTags(String content, ItemMappingProperties mappingProperties) {
        String iatContent = processGlossaryTags(content);
        iatContent = processImageSlidesTags(iatContent);
        iatContent = processImageTags(iatContent, mappingProperties);
        iatContent = processAudioTags(iatContent, mappingProperties);
        iatContent = processAnchorTags(iatContent, mappingProperties);
        iatContent = processTableTags(iatContent);
        iatContent = processListTags(iatContent);

        return iatContent;
    }

    /**
     * @param content
     * @param mappingProperties
     * @return
     */
    ItemMappingProperties mapQtiContentForChoiceInteraction(ItemRelease.Item.Content content,
                                                            ItemMappingProperties mappingProperties) {
        final Document doc = Jsoup.parse(content.getQti().getValue(), "", Parser.xmlParser());

        doc.getElementsByTag("itemBody").forEach(itemBody -> {
            String qtiFirstParagraph = itemBody.getElementsByTag("p").first().toString();
            String qtiMappedPrompt = "";
            if (StringUtils.isNotBlank(qtiFirstParagraph)) {
                qtiMappedPrompt = mapRichTextContent(qtiFirstParagraph, content.getApipAccessibility(), mappingProperties).getContent();
            }

            for (Element choiceInteraction : itemBody.getElementsByTag("choiceInteraction")) {
                String responseId = choiceInteraction.attr("responseIdentifier");
                String prompt = choiceInteraction.getElementsByTag("prompt").first().html();

                if (responseId.equals("EBSR1")) {
                    mappingProperties.setPartAPrompt(mapRichTextContent(prompt, content.getApipAccessibility(), mappingProperties).getContent());
                    for (Element simpleChoice : choiceInteraction.getElementsByTag("simpleChoice")) {
                        String sChoiceText = simpleChoice.getElementsByTag("p").first().toString();
                        mappingProperties.getPartAOptions().add(
                                mapRichTextContent(sChoiceText, content.getApipAccessibility(), mappingProperties).getContent());
                    }
                } else if (responseId.equals("EBSR2")) {
                    mappingProperties.setPartBPrompt(mapRichTextContent(prompt, content.getApipAccessibility(), mappingProperties).getContent());
                    for (Element simpleChoice : choiceInteraction.getElementsByTag("simpleChoice")) {
                        String sChoiceText = simpleChoice.getElementsByTag("p").first().toString();
                        mappingProperties.getPartBOptions().add(
                                mapRichTextContent(sChoiceText, content.getApipAccessibility(), mappingProperties).getContent());
                    }
                }
            }

            mappingProperties.setContent(qtiMappedPrompt);
        });

        return mappingProperties;
    }

    /**
     * @param content
     * @param mappingProperties
     * @return
     */
    ItemMappingProperties mapQtiContentForMatchInteraction(ItemRelease.Item.Content content,
                                                           String itemId,
                                                           String itemSourceFullPath,
                                                           ItemMappingProperties mappingProperties) {
        final Document doc = Jsoup.parse(content.getQti().getValue(), "", Parser.xmlParser());

        mappingProperties.getCells().clear();
        mappingProperties.getHeaders().clear();
        doc.getElementsByTag("simpleMatchSet").forEach(sms -> {
            sms.getElementsByTag("simpleAssociableChoice").forEach(sac -> {
                if (StringUtils.isNumeric(sac.attr("identifier"))) {
                    mappingProperties.getCells().add(
                            mapRichTextContent(sac.html(), content.getApipAccessibility(), mappingProperties).getContent());
                } else {
                    mappingProperties.getHeaders().add(
                            mapRichTextContent(sac.html(), content.getApipAccessibility(), mappingProperties).getContent());
                }
            });
        });

        mappingProperties.setCorrectResponses(getCorrectResponsesFromQrx(itemId, itemSourceFullPath, "RESPONSE"));

        mapRichTextContent(content.getStem(), content.getApipAccessibility(), mappingProperties);

        return mappingProperties;
    }

    /**
     * @param content
     * @param mappingProperties
     * @return
     */
    ItemMappingProperties mapTableInteractionContent(ItemRelease.Item.Content content,
                                                     ItemMappingProperties mappingProperties) {
        final Document doc = Jsoup.parse(content.getStem(), "", Parser.xmlParser());

        StringBuilder prompt = new StringBuilder();
        doc.childNodes().forEach(element -> {
            if (!element.nodeName().equals("div")) {
                prompt.append(element.outerHtml());
            }
        });

        Elements tableItem = doc.getElementsByClass("tableItem");
        if (tableItem.size() == 1) {
            Element tiTable = tableItem.get(0);

            mappingProperties.getHeaders().clear();
            tiTable.getElementsByTag("thead").forEach(thead -> {
                thead.getElementsByTag("th").forEach(th -> {
                    String mappedHeader = mapRichTextContent(th.html(), content.getApipAccessibility(), mappingProperties).getContent();
                    mappingProperties.getHeaders().add(mappedHeader);
                });
            });

            mappingProperties.getRows().clear();
            tiTable.getElementsByTag("tbody").forEach(tbody -> {
                tbody.getElementsByTag("tr").forEach(tr -> {
                    List<String> values = new ArrayList<>();
                    tr.getElementsByTag("td").forEach(td -> {
                        String mappedCell = mapRichTextContent(td.html(), content.getApipAccessibility(), mappingProperties).getContent();
                        values.add(mappedCell);
                    });
                    mappingProperties.getRows().add(values);
                });
            });
        }

        String mappedContent = mapRichTextContent(prompt.toString(), content.getApipAccessibility(), mappingProperties).getContent();
        mappingProperties.setContent(mappedContent);

        return mappingProperties;
    }

    /**
     * @param content
     * @param mappingProperties
     * @return
     */
    ItemMappingProperties mapHtqsContent(ItemRelease.Item.Content content,
                                         ItemMappingProperties mappingProperties) {
        final Document doc = Jsoup.parse(content.getStem(), "", Parser.xmlParser());

        StringBuilder prompt = new StringBuilder();
        StringBuilder interText = new StringBuilder();

        boolean interTextStarted = false;
        for (Element p : doc.getElementsByTag("p")) {
            if (!p.html().equals("&nbsp;")) {
                if (p.getElementsByClass("interaction selectable").size() == 0 && !interTextStarted) {
                    prompt.append(p.outerHtml());
                } else {
                    interTextStarted = true;
                    interText.append(convertInteractiveTagsToIat(p.outerHtml()));
                }
            }
        }

        String mappedPrompt  = mapRichTextContent(prompt.toString(), content.getApipAccessibility(), mappingProperties).getContent();
        String mappedInteractiveText = mapRichTextContent(interText.toString(), content.getApipAccessibility(), mappingProperties).getContent();

        mappingProperties.setContent(mappedPrompt);
        mappingProperties.setInteractiveText(mappedInteractiveText);

        return mappingProperties;
    }

    /**
     * @param content
     * @param mappingProperties
     * @return
     */
    ItemMappingProperties mapHtqoContent(ItemRelease.Item.Content content,
                                         ItemMappingProperties mappingProperties) {
        final Document doc = Jsoup.parse(content.getStem(), "", Parser.xmlParser());

        StringBuilder prompt = new StringBuilder();
        for (Element p : doc.getElementsByTag("p")) {
            prompt.append(p.outerHtml());
        }
        mappingProperties.setContent(mapRichTextContent(prompt.toString(), content.getApipAccessibility(), mappingProperties).getContent());

        AtomicInteger index = new AtomicInteger(0);
        doc.getElementsByTag("li").forEach(li -> {
            mappingProperties.getOrderableStrings().add(
                    mapRichTextContent(li.html(), content.getApipAccessibility(), mappingProperties).getContent());
            mappingProperties.getOrderableStringsCorrectOrder().add(index.getAndIncrement());
        });

        return mappingProperties;
    }

    /**
     * @param smarterAppMetadata
     * @return
     */
    ItemMetadata mapItemMetadata(SmarterAppMetadata smarterAppMetadata) {
        // TODO: Validate each metadata value is compatible with IAT
        ItemMetadata itemMetadata = new ItemMetadata();

        itemMetadata.setAccessibilityLanguageComplexity(defaultString(smarterAppMetadata.getAccessibilityLanguageComplexity()));
        itemMetadata.setAlgebraDescriptor1(defaultString(smarterAppMetadata.getAlgebraDescriptor1()));
        itemMetadata.setAlgebraDescriptor2(defaultString(smarterAppMetadata.getAlgebraDescriptor2()));
        itemMetadata.setAllowCalculator(mapYandNtoYesandNo(smarterAppMetadata.getAllowCalculator()));
        itemMetadata.setClaim2Category(mapClaim2Category(smarterAppMetadata.getClaim2Category()));
        itemMetadata.setClaim2SubCategory(defaultString(smarterAppMetadata.getClaim2SubCategory()));
        itemMetadata.setContentTaskModel(defaultString(smarterAppMetadata.getContentTaskModel()));
        itemMetadata.setCopyrightHolder(defaultString(smarterAppMetadata.getCopyrightHolder()));
        itemMetadata.setCopyrightHolderOther(defaultString(smarterAppMetadata.getCopyrightHolderOther()));
        itemMetadata.setDepthOfKnowledge(defaultString(smarterAppMetadata.getDepthOfKnowledge()));
        itemMetadata.setIntendedGrade(defaultString(smarterAppMetadata.getIntendedGrade()));
        itemMetadata.setLanguageFeatures(defaultString(smarterAppMetadata.getLanguageFeatures()));
        itemMetadata.setMaxGrade(defaultString(smarterAppMetadata.getMaximumGrade()));
        itemMetadata.setMaximumPoints(defaultString(smarterAppMetadata.getMaximumNumberOfPoints()));
        itemMetadata.setMeaningPurpose(defaultString(smarterAppMetadata.getMeaningPurpose()));
        itemMetadata.setMinGrade(defaultString(smarterAppMetadata.getMinimumGrade()));

        itemMetadata.setPerformanceTask(
            mapYandNtoYesandNo(smarterAppMetadata.getPerformanceTaskComponentItem()));

        itemMetadata.setPerformanceTaskPosition(defaultString(smarterAppMetadata.getPtSequence()));
        itemMetadata.setReadabilityFleschKincaid(defaultString(smarterAppMetadata.getReadabilityFleschKincaid()));
        itemMetadata.setReadabilityLexile(defaultString(smarterAppMetadata.getReadabilityLexile()));

        itemMetadata.setScorePoints(
            defaultString(smarterAppMetadata.getScorePoints())
                .replace("\"", "")
                .replace(" ", "")
                .replace(",", ", ")
        );

        itemMetadata.setScoringEngine(
            MapUtils.getString(
                scoreEngineMap, smarterAppMetadata.getScoringEngine(), defaultString(smarterAppMetadata.getScoringEngine())
            )
        );

        itemMetadata.setSpecificationsVersion(defaultString(smarterAppMetadata.getSpecificationsVersion()));
        itemMetadata.setStimulusFormat(defaultString(smarterAppMetadata.getStimulusGenre()));
        itemMetadata.setStimulusLength(defaultString(smarterAppMetadata.getStimulusLength()));
        itemMetadata.setStimulusLiteraryKnowledgeDemands(defaultString(smarterAppMetadata.getStimulusLiteraryKnowledgeDemands()));
        itemMetadata.setStimulusLiteraryCategory(defaultString(smarterAppMetadata.getStimulusLiteraryNonFiction()));
        itemMetadata.setStimulusName(defaultString(smarterAppMetadata.getStimulusName()));
        itemMetadata.setStructure(defaultString(smarterAppMetadata.getStructure()));

        itemMetadata.setSubject(mapIatSubject(smarterAppMetadata.getSubject()));

        itemMetadata.setTestCategory(defaultString(smarterAppMetadata.getTestCategory()));
        itemMetadata.setVersion(defaultString(smarterAppMetadata.getVersion()));
        itemMetadata.setWordCount(defaultString(smarterAppMetadata.getWordCount()));

        itemMetadata.setWritingPurpose(
            mapIatWritingPurpose(smarterAppMetadata.getPtWritingType()));

        itemMetadata.setItemAuthor(smarterAppMetadata.getItemAuthorIdentifier()
            .stream().collect(Collectors.joining(",")));


        // ---
        // Mathematical Practice
        // ---
        List<String> mathematicalPractice = smarterAppMetadata.getMathematicalPractice();
        if (mathematicalPractice.size() >= 1) {
            itemMetadata.setPrimaryMathematicalPractice(mathematicalPractice.get(0));
        }
        if (mathematicalPractice.size() >= 2) {
            itemMetadata.setSecondaryMathematicalPractice(mathematicalPractice.get(1));
        }
        if (mathematicalPractice.size() >= 3) {
            itemMetadata.setTertiaryMathematicalPractice(mathematicalPractice.get(2));
        }
        if (mathematicalPractice.size() >= 4) {
            itemMetadata.setQuaternaryMathematicalPractice(mathematicalPractice.get(3));
        }

        // StandardPublication mapping
        if (itemMetadata.getSubject().equalsIgnoreCase("Math")) {
            smarterAppMetadata.getStandardPublication().forEach(stdPublication -> {
                if (stdPublication.getPublication().equalsIgnoreCase(IatImportConstants.STANDARD_PUB_FORMAT_MATH_V4)) {
                    // Map at least one PrimaryStandard element
                    StandardIdProps primaryProps = new StandardIdProps();
                    primaryProps.loadFromValue(
                            IatImportConstants.STANDARD_PUB_FORMAT_MATH_V4, stdPublication.getPrimaryStandard());
                    itemMetadata.setPrimaryClaim(primaryProps.getClaim());
                    itemMetadata.setPrimaryContentDomain(primaryProps.getDomain());
                    itemMetadata.setPrimaryTarget(primaryProps.getTarget());
                    itemMetadata.setPrimaryEmphasis(primaryProps.getEmphasis());
                    itemMetadata.setPrimaryCommonCoreStandard(primaryProps.getCommonCoreStandard());
                    //Map zero or many SecondaryStandard elements
                    int i = 1;
                    for (String secondStandard : stdPublication.getSecondaryStandard()) {
                        StandardIdProps secondaryProps = new StandardIdProps();
                        secondaryProps.loadFromValue(
                                IatImportConstants.STANDARD_PUB_FORMAT_MATH_V5, secondStandard);
                        switch (i) {
                            case 1:
                                itemMetadata.setSecondaryClaim(secondaryProps.getClaim());
                                itemMetadata.setSecondaryContentDomain(secondaryProps.getDomain());
                                itemMetadata.setSecondaryTarget(secondaryProps.getTarget());
                                itemMetadata.setSecondaryCommonCoreStandard(secondaryProps.getCommonCoreStandard());
                                break;
                            case 2:
                                itemMetadata.setTertiaryClaim(secondaryProps.getClaim());
                                itemMetadata.setTertiaryContentDomain(secondaryProps.getDomain());
                                itemMetadata.setTertiaryTarget(secondaryProps.getTarget());
                                itemMetadata.setTertiaryCommonCoreStandard(secondaryProps.getCommonCoreStandard());
                                break;
                            case 3:
                                itemMetadata.setQuaternaryClaim(secondaryProps.getClaim());
                                itemMetadata.setQuaternaryContentDomain(secondaryProps.getDomain());
                                itemMetadata.setQuaternaryTarget(secondaryProps.getTarget());
                                itemMetadata.setQuaternaryCommonCoreStandard(secondaryProps.getCommonCoreStandard());
                                break;
                        }
                        i++;
                    }
                } else if (stdPublication.getPublication().equalsIgnoreCase(IatImportConstants.STANDARD_PUB_FORMAT_MATH_V6)) {
                    // Map at least one PrimaryStandard element
                    StandardIdProps primaryProps = new StandardIdProps();
                    primaryProps.loadFromValue(
                            IatImportConstants.STANDARD_PUB_FORMAT_MATH_V6, stdPublication.getPrimaryStandard());
                    itemMetadata.setPrimaryClaim(primaryProps.getClaim());
                    itemMetadata.setTestCategory(primaryProps.getTestCategory());
                    itemMetadata.setPrimaryTargetSet(primaryProps.getTargetSet());
                    itemMetadata.setPrimaryTarget(primaryProps.getTarget());
                }
            });
        } else if (itemMetadata.getSubject().equalsIgnoreCase("ELA")) {
            int i=0;
            for (SmarterAppMetadata.StandardPublication stdPublication : smarterAppMetadata.getStandardPublication()) {
                // Only process first ELA StandardPublication element
                if (stdPublication.getPublication().equalsIgnoreCase(
                        IatImportConstants.STANDARD_PUB_FORMAT_ELA_V1) && i==0) {
                    StandardIdProps primaryProps = new StandardIdProps();
                    primaryProps.loadFromValue(
                            IatImportConstants.STANDARD_PUB_FORMAT_ELA_V1, stdPublication.getPrimaryStandard());
                    itemMetadata.setPrimaryClaim(primaryProps.getClaim());
                    itemMetadata.setPrimaryContentDomain(primaryProps.getDomain());
                    itemMetadata.setPrimaryTarget(primaryProps.getTarget());
                    itemMetadata.setPrimaryCommonCoreStandard(primaryProps.getCommonCoreStandard());
                }
                i++;
            }
        }

        return itemMetadata;
    }

    /**
     * @param item
     * @param metadata
     * @return
     */
    Item mapMetadata(Item item, SmarterAppMetadata metadata) {
        AssessmentItem assessmentItem = (AssessmentItem) item;
        assessmentItem.getCore().setMetadata(mapItemMetadata(metadata));
        return assessmentItem;
    }

    /**
     * @param item
     * @param itemProps
     * @return
     */
    Item mapAssociatedPassage(Item item, ItemProps itemProps) {
        AssessmentItem assessmentItem = (AssessmentItem) item;
        if (StringUtils.isNotBlank(itemProps.getImportAssociatedPassage())) {
            assessmentItem.getCore().setStimulusId(itemProps.getImportAssociatedPassage());
        }
        return assessmentItem;
    }

    /**
     * @param item
     * @param itemProps
     * @return
     */
    Item mapTutorial(Item item, ItemProps itemProps) {
        AssessmentItem assessmentItem = (AssessmentItem) item;
        if (StringUtils.isNotBlank(itemProps.getImportTutorialId())) {
            assessmentItem.getCore().setTutorialId(itemProps.getImportTutorialId());
        }
        return assessmentItem;
    }

    /**
     * Process attachments for non-Stimulus resources
     * @param content
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    void processAttachments(ItemRelease.Item.Content content,
                            AbstractItem item,
                            String itemSourceFullPath,
                            String itemDestinationFullPath,
                            ItemMappingResult itemMappingResult) {
        if (content.getAttachmentlist() != null && content.getLanguage().equals("ENU")) {
            for (ItemRelease.Item.Content.Attachmentlist.Attachment attachment :
                content.getAttachmentlist().getAttachment()) {
                if (attachment.getType().equals("ASL")) {
                    processItemAslAttachments(attachment, item, itemSourceFullPath, itemDestinationFullPath, itemMappingResult);
                } else if (attachment.getType().equals("BRF") || attachment.getType().equals("PRN")) {
                    processBrailleAttachment(attachment.getFile(), item, itemSourceFullPath, itemDestinationFullPath, itemMappingResult);
                }
            }
        }
    }

    /**
     * Process attachments for Stimulus resources
     * @param content
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    void processAttachments(ItemRelease.Passage.Content content,
                            AbstractItem item,
                            String itemSourceFullPath,
                            String itemDestinationFullPath,
                            ItemMappingResult itemMappingResult) {
        if (content.getAttachmentlist() != null && content.getLanguage().equals("ENU")) {
            for (ItemRelease.Passage.Content.Attachmentlist.Attachment attachment :
                    content.getAttachmentlist().getAttachment()) {
                if (attachment.getType().equals("ASL")) {
                    processStimuliAslAttachments(attachment, item, itemSourceFullPath, itemDestinationFullPath, itemMappingResult);
                } else if (attachment.getType().equals("BRF") || attachment.getType().equals("PRN")) {
                    processBrailleAttachment(attachment.getFile(), item, itemSourceFullPath, itemDestinationFullPath, itemMappingResult);
                }
            }
        }
    }

    /**
     *
     * @param item
     * @param release
     * @param sourceDir
     * @param destinationDir
     * @param itemMappingResult
     */
    void processMachineRubric(AbstractAssessmentItem item,
                              ItemRelease release,
                              String sourceDir,
                              String destinationDir,
                              ItemMappingResult itemMappingResult) {
        File qrxFile = MigrationMapperUtil.getMachineRubricFileFromItemRelease(release, sourceDir);
        if (null != qrxFile) {
            String from = sourceDir + "/" + qrxFile.getName();
            String to = destinationDir + "/" +
                    RepositoryUtil.getQrxFileName(item.getId(), ItemConstants.ItemVersion.ITEM_VERSION);
            MigrationFileUtil.copyFile(from, to, itemMappingResult);
            item.getCore().getScoring().setManagedByIat(false);
        }
    }

    /**
     *
     * @param item
     * @param release
     * @param sourceDir
     * @param destinationDir
     * @param itemMappingResult
     */
    void processRendererSpec(EqItem item,
                             ItemRelease release,
                             String sourceDir,
                             String destinationDir,
                             ItemMappingResult itemMappingResult) {
        File eaxFile = MigrationMapperUtil.getRendererSpecFileFromItemRelease(release, sourceDir);
        if (null != eaxFile) {
            String from = sourceDir + "/" + eaxFile.getName();
            String to = destinationDir + "/" +
                    RepositoryUtil.getEaxFileName(item.getId(), ItemConstants.ItemVersion.ITEM_VERSION);
            MigrationFileUtil.copyFile(from, to, itemMappingResult);
            item.getCore().getEquationEditorConfiguration().setManagedByIat(false);
        }
    }


    /**
     * Process Asl Attachments for non-stimulus items.
     * ItemRelease.Item.Content.Attachmentlist.Attachment
     * @param attachment
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    void processItemAslAttachments(ItemRelease.Item.Content.Attachmentlist.Attachment attachment,
                                   AbstractItem item,
                                   String itemSourceFullPath,
                                   String itemDestinationFullPath,
                                   ItemMappingResult itemMappingResult) {
        if (attachment.getSource() != null) {
            attachment.getSource().forEach(source -> {
                item.getAsl().setAslProvided(true);
                item.getAsl().setAslRequired("true");
                item.getAsl().getAttachments().add(
                        newItemAttachment(source.getSrc(),
                                itemSourceFullPath,
                                itemDestinationFullPath,
                                itemMappingResult));
            });
        } else {
            item.getAsl().getAttachments().add(
                    newItemAttachment(attachment.getFile(),
                            itemSourceFullPath,
                            itemDestinationFullPath,
                            itemMappingResult));
        }
    }

    /**
     * Process Asl Attachments for stimulus items.
     * ItemRelease.Passage.Content.Attachmentlist.Attachment
     * @param attachment
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    void processStimuliAslAttachments(ItemRelease.Passage.Content.Attachmentlist.Attachment attachment,
                                      AbstractItem item,
                                      String itemSourceFullPath,
                                      String itemDestinationFullPath,
                                      ItemMappingResult itemMappingResult) {
        if (attachment.getSource() != null) {
           attachment.getSource().forEach(attach -> {
               item.getAsl().setAslProvided(true);
               item.getAsl().setAslRequired("true");
               item.getAsl().getAttachments().add(
                       newItemAttachment(attach.getSrc(),
                               itemSourceFullPath,
                               itemDestinationFullPath,
                               itemMappingResult));
           });
        } else {
            item.getAsl().getAttachments().add(
                    newItemAttachment(attachment.getFile(),
                            itemSourceFullPath,
                            itemDestinationFullPath,
                            itemMappingResult));
        }
    }

    /**
     * Process Braille attachments for all item types
     * @param fileName
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    void processBrailleAttachment(String fileName,
                                  AbstractItem item,
                                  String itemSourceFullPath,
                                  String itemDestinationFullPath,
                                  ItemMappingResult itemMappingResult) {
        item.getBraille().setBrailleProvided(true);
        item.getBraille().setBrailleRequired("true");
        item.getBraille().getAttachments().add(newItemAttachment(fileName,
                itemSourceFullPath, itemDestinationFullPath, itemMappingResult));
    }

    /**
     * Create a new IAT Attachment and attempt to copy file to Item local directory.
     * @param fileName
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     * @return
     */
    private Attachment newItemAttachment(String fileName,
                                         String itemSourceFullPath,
                                         String itemDestinationFullPath,
                                         ItemMappingResult itemMappingResult) {
        MigrationFileUtil.copyFile(itemSourceFullPath + "/" + fileName,
                itemDestinationFullPath + "/" + fileName,
                itemMappingResult);
        return createAttachment(fileName);
    }

    /**
     * Used during Migration for all item types.
     * Creates item audio resources and copies related files to destination directory.
     *
     * @param mappingResult
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    public void processAudioResources(ItemMappingProperties mappingResult,
                                      AbstractItem item,
                                      String itemSourceFullPath,
                                      String itemDestinationFullPath) {
        ItemMappingResult importResult = new ItemMappingResult();
        processAudioResources(mappingResult,
                item,
                itemSourceFullPath,
                itemDestinationFullPath,
                importResult);
    }

    /**
     * Used during Import for all item types.
     * Creates item audio resources and copies related files to destination directory.
     *
     * @param mappingResult
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    public void processAudioResources(ItemMappingProperties mappingResult,
                               AbstractItem item,
                               String itemSourceFullPath,
                               String itemDestinationFullPath,
                               ItemMappingResult importResult) {
        //Process Audio Resources
        mappingResult.getAudioSources().forEach(audio -> {

            item.getAudio().getAudioResources().add(createItemAudioResource(audio, audio.getAudioId()));

            audio.getSources().forEach(source ->
                    MigrationFileUtil.copyFile(itemSourceFullPath + "/" + source,
                        itemDestinationFullPath + "/" + source,
                        importResult));

            if (StringUtils.isNotBlank(audio.getTrack())) {
                item.getCc().setCcProvided(true);
                item.getCc().setCcRequired("true");
                item.getCc().getAttachments().add(createAttachment(audio.getTrack()));
                item.getCc().getItemCcAudioAssociations().add(createItemCCAudioAssociation(audio.getTrack(), audio.getAudioId()));
                MigrationFileUtil.copyFile(itemSourceFullPath + "/" + audio.getTrack(),
                        itemDestinationFullPath + "/" + audio.getTrack(),
                        importResult);
            }
        });
    }


    /**
     * Used during Migration for all item types.
     * Creates item image resources and copies related files to destination directory.
     *
     * @param mappingProperties
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    public void processImageResources(ItemMappingProperties mappingProperties,
                                      AbstractItem item,
                                      String itemSourceFullPath,
                                      String itemDestinationFullPath) {
        ItemMappingResult mappingResult = new ItemMappingResult();
        processImageResources(mappingProperties,
                item,
                itemSourceFullPath,
                itemDestinationFullPath,
                mappingResult);
    }

    /**
     * Used during Import for all item types.
     * Creates item image resources and copies related files to destination directory.
     *
     * @param mappingProperties
     * @param item
     * @param itemSourceFullPath
     * @param itemDestinationFullPath
     */
    public void processImageResources(ItemMappingProperties mappingProperties,
                               AbstractItem item,
                               String itemSourceFullPath,
                               String itemDestinationFullPath,
                               ItemMappingResult mappingResult) {
        mappingProperties.getImageSources().forEach(image -> {
            //int imageId = resourceId.getAndIncrement();
            item.getImages().getImageResources().add(createItemImageResource(image.getSource(), image.getImageId()));
            MigrationFileUtil.copyFile(itemSourceFullPath + "/" + image.getSource(),
                    itemDestinationFullPath + "/" + image.getSource(),
                    mappingResult);
        });
    }

    /**
     * Maps a WordlistReleaseType to GlossaryTerm
     * @param item
     * @param itemLocalPath
     * @param wordlistreleaseType
     * @param wordListFullPath
     * @return
     */
    Item mapWordlistToGlossaryTerms(Item item,
                                   Path itemLocalPath,
                                   WordlistreleaseType wordlistreleaseType,
                                   String wordListFullPath,
                                   ItemMappingResult itemMappingResult) {
        item.getGlossary().getTerms().clear();

        wordlistreleaseType.getItem().getKeywordList().getKeyword().forEach(keyword -> {
            GlossaryTerm glossaryTerm =
                    newGlossaryTerm(Integer.toString(keyword.getIndex()), keyword.getText());

            GlossaryFileProps glossaryFileProps = new GlossaryFileProps();
            glossaryFileProps.setItemId(item.getId());

            glossaryTerm.setLanguages(getIatGlossaryLanguages(glossaryFileProps, keyword, itemLocalPath, wordListFullPath, itemMappingResult));

            item.getGlossary().getTerms().add(glossaryTerm);
        });

        return item;
    }

    /**
     * Returns content before language divider tag
     * <p class="languagedivider">&#xA0;</p>
     *
     * @param content
     * @return
     */
    String getEsnContent(String content) {
        int dividerStart = content.indexOf(LANGUAGE_DIVIDER_TAG);

        if (dividerStart != -1) {
            return content.substring(0, dividerStart);
        }

        return content;
    }


    /**
     * Helper to create a new GlossaryTerm
     * @param termId
     * @param term
     * @return
     */
    private GlossaryTerm newGlossaryTerm(String termId,
                                         String term) {
        GlossaryTerm glossaryTerm = new GlossaryTerm();
        glossaryTerm.setId(termId);
        glossaryTerm.setTerm(term);
        return glossaryTerm;
    }

    /**
     * Maps a List<HtmlType> to a GlossaryLanguages object
     * @param glossaryFileProps
     * @param keyword
     * @param itemLocalPath
     * @param wordlistFullPath
     * @return
     */
    private GlossaryLanguages getIatGlossaryLanguages(GlossaryFileProps glossaryFileProps,
                                                      KeywordType keyword,
                                                      Path itemLocalPath,
                                                      String wordlistFullPath,
                                                      ItemMappingResult itemMappingResult) {
        GlossaryLanguages glossaryLanguages = new GlossaryLanguages();
        keyword.getHtml().forEach(htmlType -> {
            if (htmlType.getListType().toLowerCase().contains("glossary")) {
                glossaryFileProps.setTermId(Integer.toString(keyword.getIndex()));
                setDialectsOnLanguage(glossaryFileProps, glossaryLanguages, itemLocalPath, htmlType, wordlistFullPath, itemMappingResult);
            }
        });
        checkForDefaultDialects(glossaryLanguages);

        return glossaryLanguages;
    }

    /**
     * Sets List<Dialect> for all languages found on import source file
     * @param glossaryFileProps
     * @param glossaryLanguages
     * @param itemLocalPath
     * @param html
     * @param wordlistFullPath
     */
    private void setDialectsOnLanguage(GlossaryFileProps glossaryFileProps,
                                       GlossaryLanguages glossaryLanguages,
                                       Path itemLocalPath,
                                       HtmlType html,
                                       String wordlistFullPath,
                                       ItemMappingResult itemMappingResult) {
        String listCode = html.getListCode();

        glossaryFileProps.setLanguageName(getLanguageName(listCode));

        List<GlossaryDialect> dialects = createGlossaryDialectList(
                glossaryFileProps,
                itemLocalPath,
                html.getValue(),
                wordlistFullPath,
                itemMappingResult);

        switch (listCode) {
            case GlossaryConstants.ListCode.ARABIC : {
                glossaryLanguages.getArabic().getDialects().clear();
                glossaryLanguages.getArabic().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.BURMESE : {
                glossaryLanguages.getBurmese().getDialects().clear();
                glossaryLanguages.getBurmese().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.CANTONESE : {
                glossaryLanguages.getCantonese().getDialects().clear();
                glossaryLanguages.getCantonese().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.ENGLISH : {
                glossaryLanguages.getEnglish().getDialects().clear();
                glossaryLanguages.getEnglish().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.FILIPINO : {
                glossaryLanguages.getFilipino().getDialects().clear();
                glossaryLanguages.getFilipino().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.HMONG : {
                glossaryLanguages.getHmong().getDialects().clear();
                glossaryLanguages.getHmong().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.KOREAN : {
                glossaryLanguages.getKorean().getDialects().clear();
                glossaryLanguages.getKorean().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.MANDARIN : {
                glossaryLanguages.getMandarin().getDialects().clear();
                glossaryLanguages.getMandarin().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.PUNJABI : {
                glossaryLanguages.getPunjabi().getDialects().clear();
                glossaryLanguages.getPunjabi().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.RUSSIAN : {
                glossaryLanguages.getRussian().getDialects().clear();
                glossaryLanguages.getRussian().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.SOMALI : {
                glossaryLanguages.getSomali().getDialects().clear();
                glossaryLanguages.getSomali().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.SPANISH: {
                glossaryLanguages.getSpanish().getDialects().clear();
                glossaryLanguages.getSpanish().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.UKRAINIAN : {
                glossaryLanguages.getUkrainian().getDialects().clear();
                glossaryLanguages.getUkrainian().getDialects().addAll(dialects);
                break;
            }
            case GlossaryConstants.ListCode.VIETNAMESE : {
                glossaryLanguages.getVietnamese().getDialects().clear();
                glossaryLanguages.getVietnamese().getDialects().addAll(dialects);
                break;
            }
        }
    }


    /**
     * Creates a List<GlossaryDialect> based on the html content provided on import source file
     * @param itemLocalPath
     * @param htmlContent
     * @param wordlistFullPath
     * @return
     */
    private List<GlossaryDialect> createGlossaryDialectList(GlossaryFileProps glossaryFileProps,
                                                            Path itemLocalPath,
                                                            String htmlContent,
                                                            String wordlistFullPath,
                                                            ItemMappingResult itemMappingResult) {
        List<GlossaryDialect> glossaryDialects = new ArrayList<>();

        final Document doc = Jsoup.parseBodyFragment(htmlContent);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        Elements spans = doc.getElementsByTag("span");
        spans.forEach(span -> {
            span.attr("style", "");
        });

        Elements parTags = doc.getElementsByTag("p");

        // Expect only one wrapping <p> tag
        if (parTags.size() == 1) {
            String html = parTags.get(0).html();

            String[] dialectHtml = html.split(",");

            int dialectId = 0;

            for (String dialectString : dialectHtml) {
                final Document dialectDoc = Jsoup.parseBodyFragment(dialectString);
                dialectDoc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

                dialectId++;
                String dialectValue = dialectDoc.text();

                GlossaryDialect glossaryDialect = new GlossaryDialect();
                glossaryDialect.setId(Integer.toString(dialectId));
                glossaryDialect.setDefinition(dialectValue.trim());

                Elements aTags = dialectDoc.getElementsByTag("a");
                aTags.forEach(a -> {
                    if (a.attr("type").equals("audio/ogg") && StringUtils.isNotBlank(a.attr("href"))) {
                        glossaryFileProps.setDialectId(glossaryDialect.getId());
                        glossaryFileProps.setFileName(a.attr("href"));
                        addDialectAttachment(
                                glossaryFileProps,
                                glossaryDialect,
                                itemLocalPath,
                                wordlistFullPath,
                                itemMappingResult);
                    }
                });

                glossaryDialects.add(glossaryDialect);
            }
        }

        return glossaryDialects;
    }

    /**
     * Adds Attachment object to Dialect.
     * Copies audio files to item's glossary folder
     * @param glossaryDialect
     * @param itemLocalPath
     * @param wordListFullPath
     */
    private void addDialectAttachment(GlossaryFileProps glossaryFileProps,
                                      GlossaryDialect glossaryDialect,
                                      Path itemLocalPath,
                                      String wordListFullPath,
                                      ItemMappingResult itemMappingResult) {

        glossaryDialect.getAudioFiles().add(createAttachment(glossaryFileProps.getFileName()));

        File oggFile = new File(wordListFullPath + "/" + glossaryFileProps.getFileName());
        if (oggFile.exists()) {
            String oggIatFileName = glossaryFileProps.getFileName();

            MigrationFileUtil.copyFile(oggFile,
                    Paths.get(itemLocalPath.toString(), "glossary", oggIatFileName).toFile(),
                    itemMappingResult);

            String m4aFileName = glossaryFileProps.getFileName().replace(".ogg", ".m4a");
            File m4aFile =  new File(wordListFullPath + "/" + m4aFileName);
            if (m4aFile.exists()) {
                String m4aIatFileName = m4aFileName;

                MigrationFileUtil.copyFile(m4aFile,
                        Paths.get(itemLocalPath.toString(), "glossary", m4aIatFileName).toFile(),
                        itemMappingResult);
            }
        }
    }


    /**
     * Ensures GlossaryLanguage contains the minimum amount of Dialects
     * @param glossaryLanguages
     */
    private void checkForDefaultDialects(GlossaryLanguages glossaryLanguages) {
        setMinimumDialectsForLanguage(glossaryLanguages.getArabic(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getBurmese(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getCantonese(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getEnglish(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getFilipino(), 2);
        setMinimumDialectsForLanguage(glossaryLanguages.getHmong(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getKorean(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getMandarin(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getPunjabi(), 2);
        setMinimumDialectsForLanguage(glossaryLanguages.getRussian(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getSomali(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getSpanish(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getUkrainian(), 1);
        setMinimumDialectsForLanguage(glossaryLanguages.getVietnamese(), 1);
    }

    /**
     * Adds GlossaryDialect objects when minimum amount is not found
     * @param glossaryLanguage
     * @param minimumDialects
     */
    private void setMinimumDialectsForLanguage(GlossaryLanguage glossaryLanguage, int minimumDialects) {
        if (glossaryLanguage.getDialects().size() < minimumDialects) {
            for (int i=glossaryLanguage.getDialects().size(); i < minimumDialects; i++) {
                glossaryLanguage.getDialects().add(new GlossaryDialect());
            }
        }

    }

    /**
     * @param audio
     * @param audioId
     * @return
     */
    private ItemAudioResource createItemAudioResource(IatAudio audio, int audioId) {
        ItemAudioResource resource = new ItemAudioResource();
        resource.setProductionFilesProvided(true);
        resource.setId(Integer.toString(audioId));
        audio.getSources().forEach(source -> resource.getProductionFiles().add(createAttachment(source)));
        return resource;
    }

    /**
     * @param image
     * @param imageId
     * @return
     */
    private ItemImageResource createItemImageResource(String image, int imageId) {
        ItemImageResource resource = new ItemImageResource();
        resource.setProductionFileProvided(true);
        resource.setId(Integer.toString(imageId));
        resource.getProductionFile().setFileName(image);
        resource.getProductionFile().setUploadedDate(new Date());
        return resource;
    }

    /**
     * @param fileName
     * @return
     */
    private Attachment createAttachment(String fileName) {
        Attachment attach = new Attachment();
        attach.setFileName(fileName);
        attach.setUploadedDate(new Date());
        return attach;
    }

    /**
     * @param fileName
     * @param audioId
     * @return
     */
    private ItemCcAudioAssociation createItemCCAudioAssociation(String fileName, int audioId) {
        ItemCcAudioAssociation audioAssociation = new ItemCcAudioAssociation();
        audioAssociation.setCcFileName(fileName);
        audioAssociation.setAudioResourceId(Integer.toString(audioId));
        return audioAssociation;
    }

    /**
     * @param itemId
     * @param sourceItemFullPath
     * @return
     */
    private List<String> getCorrectResponsesFromQrx(String itemId,
                                                    String sourceItemFullPath,
                                                    String identifier) {
        List<String> values = new ArrayList<>();
        File qrxFile = MigrationFileUtil.findFileInPath(
                sourceItemFullPath, format("item_%s_*.qrx", itemId));
        if (qrxFile != null && qrxFile.exists()) {
            String qrxContent = MigrationFileUtil.fileToString(qrxFile);
            final Document doc = Jsoup.parse(qrxContent, "", Parser.xmlParser());

            doc.getElementsByTag("responseDeclaration").forEach(respDeclaration -> {
                if (respDeclaration.attr("identifier").equals(identifier)) {
                    respDeclaration.getElementsByTag("value").forEach(value -> {
                        values.add(value.text());
                    });
                }
            });
        }
        return values;
    }

    /**
     * Used on all items except Stimulus
     *
     * @param content         String content to be mapped
     * @param accessibility   ItemRelease.Item.Content that contains the TTS content
     * @return
     */
    private String processTTSTags(String content, ItemRelease.Item.Content.ApipAccessibility accessibility) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        if (accessibility != null) {
            accessibility.getAccessibilityInfo().getAccessElement().forEach(accessElement -> {
                final Element ttsTag = doc.getElementById(accessElement.getContentLinkInfo().getItsLinkIdentifierRef());

                if (ttsTag != null) {
                    String tts = "";
                    String ttsAlt = "";
                    if (accessElement.getContentLinkInfo().getType().equals("Text")) {
                        tts = defaultString(accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciation());
                        ttsAlt = defaultString(accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciationAlternate());
                    } else if (accessElement.getContentLinkInfo().getType().equals("Graphic")) {
                        tts = defaultString(accessElement.getRelatedElementInfo().getReadAloud().getAudioText());
                    }
                    mapSaaifTTSTagToIATTag(ttsTag, tts, ttsAlt);
                }
            });
        }

        return doc.body().html();
    }

    /**
     * Used on all items except Stimulus
     *
     * @param content         String content to be mapped
     * @param accessibility   ItemRelease.Item.Content that contains the TTS content
     * @return
     */
    private String processTTSTags(String content, ItemRelease.Passage.Content.ApipAccessibility accessibility) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        if (accessibility != null) {
            accessibility.getAccessibilityInfo().getAccessElement().forEach(accessElement -> {
                final Element ttsTag = doc.getElementById(accessElement.getContentLinkInfo().getItsLinkIdentifierRef());

                if (ttsTag != null) {
                    String tts = "";
                    String ttsAlt = "";
                    if (accessElement.getContentLinkInfo().getType().equals("Text")) {
                        tts = defaultString(accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciation());
                        ttsAlt = defaultString(accessElement.getRelatedElementInfo().getReadAloud().getTextToSpeechPronunciationAlternate());
                    } else if (accessElement.getContentLinkInfo().getType().equals("Graphic")) {
                        tts = defaultString(accessElement.getRelatedElementInfo().getReadAloud().getAudioText());
                    }
                    mapSaaifTTSTagToIATTag(ttsTag, tts, ttsAlt);
                }
            });
        }

        return doc.body().html();
    }

    /**
     *  Maps Saaif <img> or <span> that contains TTS to the IAT equivalent
     *
     * @param ttsTag
     * @param tts
     * @param ttsAlt
     *
     */
    private void mapSaaifTTSTagToIATTag(Element ttsTag, String tts, String ttsAlt) {
        ttsTag.addClass("iat-text2speech");
        // tts has a value
        if (StringUtils.isNotEmpty(tts)) {
            ttsTag.attr("data-iat-tts", tts);
            if (StringUtils.isEmpty(ttsAlt)) {
                ttsTag.attr("data-iat-tts-vi", tts);
            }
        }
        // ttsAlt has a value
        if (StringUtils.isNotEmpty(ttsAlt)) {
            ttsTag.attr("data-iat-tts-vi", ttsAlt);
            if (StringUtils.isEmpty(tts)) {
                ttsTag.attr("data-iat-tts", ttsAlt);
            }
        }
        // None have values
        if (StringUtils.isEmpty(tts) && StringUtils.isEmpty(ttsAlt)) {
            ttsTag.attr("data-iat-tts", tts);
            ttsTag.attr("data-iat-tts-vi", ttsAlt);
        }
        ttsTag.removeAttr("id");
    }

    /**
     * Maps Saaif Audio tags to IAT equivalent
     *
     * @param content             String content to be mapped
     * @param mappingProperties   MappingProperties object that collects audio resources during mapping
     * @return
     */
    public String processAudioTags(String content, ItemMappingProperties mappingProperties) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("audio").forEach(audio -> {
            IatAudio iatAudio = new IatAudio();
            audio.getElementsByTag("source").forEach(source -> {
                iatAudio.getSources().add(source.attr("src"));
            });
            audio.getElementsByTag("track").forEach(track -> {
                iatAudio.setTrack(track.attr("src"));
            });
            int audioId = mappingProperties.getAudioSourceCount() + 1;
            mappingProperties.setAudioSourceCount(audioId);
            iatAudio.setAudioId(audioId);
            mappingProperties.getAudioSources().add(iatAudio);

            Element img = new Element("img");
            img.attr("title", "Audio Resource " + audioId);
            img.attr("data-iat-audio-resource-id", Integer.toString(audioId));
            img.attr("src", getAudioPlaceholderSrc(audioId));
            img.addClass("place-holder");

            audio.replaceWith(img);
        });

        AttachmentValidator validator = new AttachmentValidator(new ItemBankProperties());

        doc.getElementsByTag("a").forEach(anchor -> {

            String audioFileName = anchor.attr("href");

            try {
                validator.validateFileName(audioFileName, SECTION_AUDIO);

            IatAudio iatAudio = new IatAudio();
            iatAudio.getSources().add(audioFileName);

            int audioId = mappingProperties.getAudioSources().size() + 1;
            iatAudio.setAudioId(audioId);
            mappingProperties.getAudioSources().add(iatAudio);

            Element img = new Element("img");
            img.attr("title", "Audio Resource " + audioId);
            img.attr("data-iat-audio-resource-id", Integer.toString(audioId));
            img.attr("src", getAudioPlaceholderSrc(audioId));
            img.addClass("place-holder");

            anchor.replaceWith(img);
            } catch (ValidationException e) {
                log.info(
                        format("Skip anchor tag as it does not reference a valid audio file name -> %s",
                                audioFileName));
            }
        });

        return doc.body().html();
    }

    /**
     * @param content
     * @param mappingProperties
     * @return
     */
    private String processImageTags(String content, ItemMappingProperties mappingProperties) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("img").forEach(image -> {
            IatImage imageLookup = mappingProperties.getImageSources().stream()
                    .filter(img -> img.getSource().equals(image.attr("src")))
                    .findAny()
                    .orElse(null);

            int imageId;

            if (null == imageLookup) {
                IatImage iatImage = new IatImage();
                imageId = mappingProperties.getImageSourceCount() + 1;
                mappingProperties.setImageSourceCount(imageId);
                iatImage.setImageId(imageId);
                iatImage.setSource(image.attr("src"));
                mappingProperties.getImageSources().add(iatImage);
            } else {
                imageId = imageLookup.getImageId();
            }

            Element img = new Element("img");
            img.attr("title", "Image Resource " + imageId);
            img.attr("data-iat-image-resource-id", Integer.toString(imageId));
            img.attr("src", getImagePlaceholderSrc(imageId));
            img.addClass("place-holder");

            image.replaceWith(img);
        });

        return doc.body().html();
    }

    /**
     * @param content
     * @param mappingProperties
     * @return
     */
    private String processAnchorTags(String content, ItemMappingProperties mappingProperties) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("a").forEach(anchor -> {
            mappingProperties.getFileSources().add(anchor.attr("href"));
        });

        return doc.body().html();
    }

    /**
     * @param content
     * @return
     */
    private String processTableTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("table").forEach(table -> {
            Attributes tableAtribs = table.attributes().clone();
            table.clearAttributes();
            table.attr("cellpadding", "1");
            table.attr("cellspacing", "1");
            table.attr("border", "1");

            if (StringUtils.isNotBlank(tableAtribs.get("style"))) {
                table.attr("style",
                    convertEmStyleToPixel(tableAtribs.get("style"), "width"));
            }

            table.getElementsByTag("colgroup").forEach(Node::remove);

            table.getElementsByTag("tr").forEach(tr -> {
                tr.getElementsByTag("td").forEach(Node::clearAttributes);
            });
        });

        return doc.body().html();
    }

    /**
     * @param content
     * @return
     */
    private String processListTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByTag("ul").forEach(Node::clearAttributes);
        doc.getElementsByTag("ol").forEach(Node::clearAttributes);

        return doc.body().html();
    }

    /**
     * @param content
     * @return
     */
    private String processImageSlidesTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByClass("slides_config hidden")
                .forEach(Node::clearAttributes);

        doc.getElementsByClass("slides_container")
                .forEach(container -> {
                    Element span = new Element("span");
                    span.attr("iat-image-slide-placeholder","");
                    span.text("(Image slideshows are not supported)");

                    container.replaceWith(span);
                });

        return doc.body().html();
    }

    /**
     *
     * @param content
     * @return
     */
    String processGlossaryTags(String content) {
        final Document doc = Jsoup.parseBodyFragment(content);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        Elements startBoundaySpans = doc.getElementsByAttributeValue("data-tag-boundary", "start");
        Elements endBoudarySpans =  doc.getElementsByAttributeValue("data-tag-boundary", "end");

        startBoundaySpans.forEach(startSpan -> {
            String iatGlossSpan = format("<span class=\"iat-glossary-term\" data-iat-glossary-term-id=\"%s\">",
                    startSpan.attr("data-word-index"));
            startSpan.replaceWith(new TextNode(iatGlossSpan, null));
        });

        endBoudarySpans.forEach(endSpan -> {
            endSpan.replaceWith(new TextNode("</span>", null));
        });

        return doc.body().html()
                .replace("&lt;", "<")
                .replace("&gt;", ">");
    }

    /**
     * @param styleDef
     * @param styleName
     * @return
     */
    private String convertEmStyleToPixel(String styleDef, String styleName) {
        String saaifStyle = "";
        String value = getStyleValue(styleDef, styleName);
        if (StringUtils.isNotBlank(value)) {
            // TODO: Currently only supports en unit conversion
            if (value.contains("em")) {
                int val = (int) Float.parseFloat(value.replace("em", ""));
                saaifStyle = styleName + ":" + convertEmtoPixel(val) + ";";
            }
        }
        return saaifStyle;
    }

    /**
     * @param em
     * @return
     */
    private String convertEmtoPixel(int em) {
        try {
            final int pxUnit = em * PIXEL_TO_EM_CONVERSION_RATE;
            return format("%1d", pxUnit).concat("px");
        } catch (Exception ex) {
            return "";
        }
    }

    /**
     * Attempts to retrieve the the value of an inline style from a style definition string
     *
     * @param styleDef  e.g. "text-align:center; font-weight:bold; width: 500px; height: 200px"
     * @param styleName e.g. "width"
     * @return value of style or empty string if not found
     */
    private String getStyleValue(String styleDef, String styleName) {
        String styleVal = "";
        List<String> stylesList = Arrays.asList(styleDef.split(";"));
        for (String style : stylesList) {
            List<String> currStyle = Arrays.asList(style.split(":"));
            if (isNotEmpty(currStyle)) {
                if (currStyle.get(0).trim().equals(styleName)) {
                    styleVal = currStyle.get(1).trim();
                    break;
                }
            }
        }
        return styleVal;
    }

    /**
     * @param audioId
     * @return
     */
    private String getAudioPlaceholderSrc(int audioId) {
        return "/assets/ckeditor/plugins/iataudio/icons/audio-place-" +
            (audioId < 10 ? "0" : "") +
            audioId + ".png";
    }

    /**
     * @param imageId
     * @return
     */
    private String getImagePlaceholderSrc(int imageId) {
        return "/assets/ckeditor/plugins/iatimage/icons/image-place-" +
            (imageId < 10 ? "0" : "") +
            imageId + ".png";
    }

    /**
     * Returns an empty string if the argument is null.  If the argument is not null it is trimmed.
     *
     * @param str The value to trim.
     * @return Empty string if null passed in otherwise the argument is returned trimmed.
     */
    protected String defaultString(String str) {
        return StringUtils.defaultString(str).trim();
    }

    /**
     *
     * @param saaifValue
     * @return
     */
    private String mapYandNtoYesandNo(String saaifValue) {
        return "Y".equalsIgnoreCase(saaifValue) ? "Yes" : "N".equalsIgnoreCase(saaifValue) ? "No" : "";
    }

    /**
     *
     * @param saaifValue
     * @return
     */
    private String mapClaim2Category(String saaifValue) {
        return "C".equalsIgnoreCase(saaifValue) ? "Conventions" :
               "E".equalsIgnoreCase(saaifValue) ? "EvidenceElaboration" :
               "O".equalsIgnoreCase(saaifValue) ? "Organization" : "";

    }

    /**
     *
     * @param saaifValue
     * @return
     */
    private String mapIatWritingPurpose(String saaifValue) {
        String value = "";
        if (saaifValue != null) {
            List<String> purposeValues = Arrays.asList("Narrative", "InformationalExplanatory", "OpinionArgumentative");
            value = purposeValues.stream()
                .filter(purpose -> purpose.toLowerCase().contains(saaifValue.toLowerCase()))
                .findAny()
                .orElse("");
        }
        return value;
    }

    /**
     *
     * @param saaifValue
     * @return
     */
    private String mapIatSubject(String saaifValue) {
        String value = "";
        if (saaifValue.equalsIgnoreCase("math")) {
            value = "Math";
        } else if (saaifValue.equalsIgnoreCase("ela")) {
            value = "ELA";
        }
        return value;
    }

    /**
     *
     * @param html
     * @return
     */
    private String convertInteractiveTagsToIat(String html) {
        final Document doc = Jsoup.parseBodyFragment(html);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);

        doc.getElementsByClass("interaction selectable").forEach(span -> {
            span.clearAttributes();
            span.addClass("iat-htq-correct");
        });

        return doc.body().html();
    }

    /**
     *
     * @param listCode
     * @return
     */
    private String getLanguageName(String listCode) {
        String language = "";

        switch (listCode) {
            case GlossaryConstants.ListCode.ARABIC : {
                language = "arabic";
                break;
            }
            case GlossaryConstants.ListCode.BURMESE : {
                language = "burmese";
                break;
            }
            case GlossaryConstants.ListCode.CANTONESE : {
                language = "cantonese";
                break;
            }
            case GlossaryConstants.ListCode.ENGLISH : {
                language = "english";
                break;
            }
            case GlossaryConstants.ListCode.FILIPINO : {
                language = "filipino";
                break;
            }
            case GlossaryConstants.ListCode.HMONG : {
                language = "hmong";
                break;
            }
            case GlossaryConstants.ListCode.KOREAN : {
                language = "korean";
                break;
            }
            case GlossaryConstants.ListCode.MANDARIN : {
                language = "mandarin";
                break;
            }
            case GlossaryConstants.ListCode.PUNJABI : {
                language = "punjabi";
                break;
            }
            case GlossaryConstants.ListCode.RUSSIAN : {
                language = "russian";
                break;
            }
            case GlossaryConstants.ListCode.SOMALI : {
                language = "somali";
                break;
            }
            case GlossaryConstants.ListCode.SPANISH: {
                language = "spanish";
                break;
            }
            case GlossaryConstants.ListCode.UKRAINIAN : {
                language = "ukrainian";
                break;
            }
            case GlossaryConstants.ListCode.VIETNAMESE : {
                language = "vietnamese";
                break;
            }
        }

        return language;
    }

}
