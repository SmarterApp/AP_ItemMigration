package org.opentestsystem.ap.migration.gitlab;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.gitlab4j.api.models.Project;
import org.opentestsystem.ap.common.client.GitlabClient;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.ResourceNotFoundException;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.repository.RepositoryUtil;
import org.opentestsystem.ap.migration.datastore.DataStoreItemResult;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

import java.util.Objects;

import static java.lang.String.format;

@Slf4j
public class GitLabProjectRenameService {

    private static final boolean THROW_RESOURCE_NOT_FOUND_WHEN_PROJECT_NOT_FOUND = false;

    private static final boolean RETURN_NULL_WHEN_PROJECT_NOT_FOUND = true;

    private final DataStoreDataManager dataManager;

    private final ItemBankProperties itemBankProperties;

    private final GitlabClient gitlabClient;

    private final HttpHeaders headers;

    private final RestTemplate restTemplate;

    public GitLabProjectRenameService(RestTemplateBuilder restTemplateBuilder,
                                      DataStoreDataManager dataManager,
                                      ItemBankProperties itemBankProperties,
                                      GitlabClient gitlabClient) {

        this.dataManager = dataManager;
        this.itemBankProperties = itemBankProperties;
        this.gitlabClient = gitlabClient;

        this.headers = new HttpHeaders();
        this.headers.add("PRIVATE-TOKEN", this.itemBankProperties.getAccessToken());
        this.headers.setContentType(MediaType.APPLICATION_JSON_UTF8);

        this.restTemplate = restTemplateBuilder
            .rootUri(format("%s%s", itemBankProperties.getHost(), itemBankProperties.getApiVersion()))
            .build();
    }

    /**
     * Takes the item ID in its normal form which is an integer (i.e. 200000).  Looks up the entity in the data store
     * using its item json to get the legacy ID.  Calls a GitLab API to rename the project
     *
     * @param itemId The item identifier.
     * @return The result of renaming the item in GitLab.
     */
    public DataStoreItemResult renameItem(String itemId) {
        DataStoreItemResult result = new DataStoreItemResult(itemId);
        // do not throw up, instead collect results
        try {
            Item item = this.getItem(itemId);
            String legacyId = item.getLegacyId(this.itemBankProperties.getBankKey());
            this.renameProject(itemId, legacyId, item.getType(), result);
        } catch (ResourceNotFoundException e) {
            result.setFailed(true);
            result.addFailedeMessage(format("Project not found in GitLab for item %s", itemId));
        } catch (Exception e) {
            result.setFailed(true);
            result.addFailedeMessage(format("Unexpected error renaming item %s - %s", itemId, e.getMessage()));
        }
        return result;
    }

    private void renameProject(String itemId, String legacyId, String type, DataStoreItemResult result) {
        // throws when project not found
        Project project = this.getProject(itemId, legacyId);

        log.info("renaming {} to {}", itemId, legacyId);

        this.executeRename(project.getId(), legacyId);
        result.addSuccessMessage(format("%s %s was renamed to %s", StringUtils.upperCase(type), itemId, legacyId));

        this.renameGlossary(itemId, result);
    }

    /**
     * Given an item ID its glossary ID is inferred.  The glossary is renamed in GitLab.
     *
     * @param itemId The item ID to determine the glossary ID from.
     * @param result The result instance to track progress.
     */
    private void renameGlossary(String itemId, DataStoreItemResult result) {
        String glossaryId = RepositoryUtil.getGlossaryId(itemId);
        log.info("renaming glossary for item {}", itemId);
        Project project = this.gitlabClient.lookupProjectByName(glossaryId, RETURN_NULL_WHEN_PROJECT_NOT_FOUND);
        if (Objects.nonNull(project)) {
            String glossaryLegacyId = RepositoryUtil.getLegacyItemId(glossaryId, this.itemBankProperties.getBankKey());
            this.executeRename(project.getId(), glossaryLegacyId);
            result.addSuccessMessage(format("Glossary %s was renamed to %s", glossaryId, glossaryLegacyId));
        } else {
            result.addSuccessMessage(format("Glossary %s does not exist in GitLab, nothing to rename", glossaryId));
        }
    }

    /**
     * Renames the project and its associated repository in GitLab with the legacy ID.
     *
     * @param projectId The GitLab project identifier.
     * @param legacyId  The value the project and repo are renamed to.
     * @return
     */
    private GitLabRepositoryRenameResponse executeRename(Integer projectId, String legacyId) {
        String resourceUrl = format("/projects/%d", projectId);

        GitLabRepositoryRenameRequest request = new GitLabRepositoryRenameRequest(legacyId, legacyId);

        HttpEntity<GitLabRepositoryRenameRequest> requestUpdate = new HttpEntity<>(request, this.headers);

        ResponseEntity<GitLabRepositoryRenameResponse> response = restTemplate
            .exchange(resourceUrl, HttpMethod.PUT, requestUpdate, GitLabRepositoryRenameResponse.class);

        return response.getBody();
    }

    /**
     * Looks up the last master record for the item and returns the item json associated with it.
     *
     * @param itemId The item identifier.
     * @return The item instance.
     */
    private Item getItem(String itemId) {
        ItemEntity itemEntity = this.dataManager.findLastMaster(itemId);
        return itemEntity.getItemJson();
    }

    /**
     * We are accounting for the case when an item gets migrated but its glossary does not. We need the migration to be
     * re-runnable.  We handle re-runs by first looking up the project using the item ID then looking it up by legacy
     * ID. If neither are found we throw {@link ResourceNotFoundException}.  If the item has already been renamed then
     * executing the rename on the already renamed item should be fine as it is renaming it to what it is already
     * renamed to (i.e. its legacy ID).
     *
     * @param itemId   The item ID that will be renamed.
     * @param legacyId The ID the item will be renamed to.
     * @return The GitLab project representing the item.
     */
    private Project getProject(String itemId, String legacyId) {
        try {
            return this.gitlabClient.lookupProjectByName(itemId, THROW_RESOURCE_NOT_FOUND_WHEN_PROJECT_NOT_FOUND);
        } catch (ResourceNotFoundException e) {
            return this.gitlabClient.lookupProjectByName(legacyId, THROW_RESOURCE_NOT_FOUND_WHEN_PROJECT_NOT_FOUND);
        }
    }
}
