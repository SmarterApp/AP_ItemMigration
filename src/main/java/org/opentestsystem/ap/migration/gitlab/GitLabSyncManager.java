package org.opentestsystem.ap.migration.gitlab;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.opentestsystem.ap.common.client.GitClient;
import org.opentestsystem.ap.common.config.ItemBankProperties;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.exception.SystemException;
import org.opentestsystem.ap.common.gitlab.GitLabItemManager;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemTransaction;
import org.opentestsystem.ap.common.model.sync.SyncItemResult;
import org.opentestsystem.ap.common.security.model.ItemBankUser;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import static java.lang.String.format;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.ap.common.model.ModelConstants.BranchNames.BRANCH_MASTER;
import static org.opentestsystem.ap.common.model.ModelConstants.Section.SECTION_CREATE;
import static org.opentestsystem.ap.common.repository.RepositoryUtil.getSectionBranchName;

/**
 * Migrates items from GitLab to the data store.
 */
@Slf4j
@Component
public class GitLabSyncManager {

    private static final boolean NOT_EDITING = false;

    private static final boolean YES_EDITING = true;

    private final ItemBankProperties itemBankProperties;

    private final GitLabItemManager gitLabItemManager;

    private final DataStoreDataManager dataStoreDataManager;

    private final DataStoreAttachmentManager dataStoreAttachmentManager;

    public GitLabSyncManager(ItemBankProperties itemBankProperties,
                             GitLabItemManager gitLabItemManager,
                             DataStoreDataManager dataStoreDataManager,
                             DataStoreAttachmentManager dataStoreAttachmentManager) {
        this.itemBankProperties = itemBankProperties;
        this.gitLabItemManager = gitLabItemManager;
        this.dataStoreDataManager = dataStoreDataManager;
        this.dataStoreAttachmentManager = dataStoreAttachmentManager;
    }

    // ------------------------------------------------------------------------

    /**
     * Using the given transactions a new list of transactions is returned representing the order to sync the item.  The
     * master branch should always come first for example.
     *
     * @param user         The user.
     * @return A list of transactions ordered for syncing.
     */
    public List<ItemTransaction> generateAndOrderSyncTransactions(ItemBankUser user) {
        List allTransactions = new ArrayList<>(0);
        allTransactions.add(new ItemTransaction(user.getUserName(), BRANCH_MASTER));
        return allTransactions;
    }

    /**
     * The item exists in the item bank but not in the datastore.  All transactions (i.e. branches) are imported into
     * the data store from the item bank.
     *
     * @param user         The user making the request into IMS.
     * @param itemId       The item to sync.
     * @return The results of syncing the item to the data store.
     */
    public SyncItemResult syncToDataStore(ItemBankUser user, String itemId) {
        GitClient gitClient = gitLabItemManager.cloneRemoteRepository(user, itemId);
        try {
            return syncToDataStore(gitClient, user, itemId);
        } finally {
            if (Objects.nonNull(gitClient)) {
                gitClient.close();
            }
        }
    }

    /**
     * The item exists in the item bank but not in the datastore.  All transactions (i.e. branches) are imported into
     * the data store from the item bank.
     *
     * @param gitClient    The git client associated with the item repository.
     * @param user         The user requesting to sync.
     * @param itemId       The item to sync.
     * @return The results of syncing the item to the data store.
     */
    public SyncItemResult syncToDataStore(GitClient gitClient, ItemBankUser user, String itemId) {
        log.info("Syncing item {} to the data store for user {}", itemId, user.getUserName());
        SyncItemResult result = new SyncItemResult(itemId);
        try {
            List<ItemTransaction> transactionsToSync = generateAndOrderSyncTransactions(user);

            List<SyncItemResult.Branch> branchResults = transactionsToSync
                .stream()
                .map(transaction -> syncToDataStore(gitClient, itemId, transaction))
                .collect(toList());

            result.setSuccess(true);
            result.setBranches(branchResults);
        } catch (Exception e) {
            result.setMessage(ExceptionUtils.getRootCauseMessage(e));
        }
        return result;
    }

    /**
     * Reads the {@link Item} from GitLab.  The item is read from a specific branch.  The transaction gives the branch.
     * The results of this method is a row is inserted into the data store.  A row is only inserted if the data does not
     * already exists in the data store.  In addition, the attachments associated with the item branch are added to the
     * resource repository.
     *
     * @param gitClient   The git client associated with the item repository.
     * @param itemId      The item to sync.
     * @param transaction The owner of the item branch.
     * @return The results of syncing the item's branch to the data store.
     */
    public SyncItemResult.Branch syncToDataStore(GitClient gitClient, String itemId, ItemTransaction transaction) {
        SyncItemResult.Branch result = new SyncItemResult.Branch(transaction.getSection(), transaction.getUserName());
        try {
            String branch = getSectionBranchName(transaction.getUserName(), transaction.getSection());

            log.info("Syncing item {} branch {}", itemId, branch);

            gitClient.checkoutBranch(branch);
            gitClient.pullLatest();

            Item item = gitClient.readModelFile();

            if (Objects.isNull(item)) {
                String msg = format("Sync skipped - item %s branch %s returned a null item model", itemId, branch);
                log.warn(msg);
                result.setMessage(msg);
            } else if (!dataStoreDataManager.doesBranchExist(itemId, transaction.getSection())) {
                ItemEntity entity = saveToDataStore(item, transaction);
                result.setSuccess(true);
                result.setEntityId(entity.getId());
                result.setAttachments(syncAttachmentsToDataStore(gitClient, item, transaction));
            } else {
                String msg = format("Sync skipped - item %s branch %s already exists in the data store", itemId,
                    branch);
                log.warn(msg);
                result.setMessage(msg);
            }
        } catch (Exception e) {
            result.setMessage(ExceptionUtils.getRootCauseMessage(e));
        }
        return result;
    }

    /**
     * Stores files in the given path to the data store.  The branch is the folder name to store the files in.  The
     * attachments path is expected to be a directory.
     *
     * @param itemId          The item
     * @param branch          The branch
     * @param attachmentsPath The directory holding the item attachments to store.
     * @return
     */
    public List<SyncItemResult.Attachments> syncAttachmentsToDataStore(String itemId,
                                                                       String branch,
                                                                       Path attachmentsPath) {
        List<String> filesToCopy = listFilesInFolder(attachmentsPath);
        return syncAttachmentsToDataStore(itemId, branch, attachmentsPath, filesToCopy);
    }

    private List<SyncItemResult.Attachments> syncAttachmentsToDataStore(GitClient gitClient,
                                                                        Item item,
                                                                        ItemTransaction transaction) {
        Path folder = gitClient.getItemContext().getLocalRepositoryPath();
        Set<String> files = new HashSet<>();
        files.addAll(this.findFilesWithExtension(folder, "eax"));
        files.addAll(this.findFilesWithExtension(folder, "gax"));
        files.addAll(this.findFilesWithExtension(folder, "qrx"));
        files.addAll(this.findFilesWithExtension(folder, "png"));
        files.addAll(this.findFilesWithExtension(folder, "svg"));
        files.addAll(this.findFilesWithExtension(folder, "html"));
        files.addAll(this.findFilesWithExtension(folder, "zip"));
        files.addAll(this.listFilesInFolder(folder, "glossary"));
        files.addAll(item.listSectionFiles(transaction.getSection()));
        return syncAttachmentsToDataStore(
            item.getId(), transaction.getSection(), gitClient.getLocalRepositoryPath(), files);
    }

    public List<SyncItemResult.Attachments> syncAttachmentsToDataStore(String itemId,
                                                                        String branch,
                                                                        Path attachmentsPath,
                                                                        Collection<String> attachmentFiles) {
        log.info("Syncing attachments for item {} branch {}", itemId, branch);

        String branchName = SECTION_CREATE.equalsIgnoreCase(branch) ? BRANCH_MASTER : branch;

        List<SyncItemResult.Attachments> results = attachmentFiles.stream()
            .map(fileName -> {
                SyncItemResult.Attachments result = new SyncItemResult.Attachments(fileName);
                try {
                    boolean success = this.syncAttachment(
                        itemId, branchName, fileName, attachmentsPath.resolve(fileName));

                    result.setSuccess(success);

                    if (!success) {
                        result.setMessage("Attachment already exists in data store");
                    }
                } catch (Exception e) {
                    result.setMessage(ExceptionUtils.getRootCauseMessage(e));
                }
                return result;
            })
            .collect(toList());

        return results;
    }

    // ------------------------------------------------------------------------

    private boolean syncAttachment(String itemId, String branch, String relativeFileName, Path filePath) {
        log.info("Syncing attachment for item {} branch {} ", itemId, branch);
        this.dataStoreAttachmentManager.saveAttachment(itemId, branch, relativeFileName, filePath);
        return true;
    }

    /**
     * The item is added to the data store if it does not already exist.  If it exists then no changes are made to the
     * data store.
     *
     * @param item        The item to add.
     * @param transaction The user and branch associated with the item.
     */
    private ItemEntity saveToDataStore(Item item, ItemTransaction transaction) {
        String section = transaction.getSection();
        String branch = SECTION_CREATE.equalsIgnoreCase(section) ? BRANCH_MASTER : section;

        ItemEntity entity = new ItemEntity(item.getId(), branch);
        entity.setItemJson(item);
        entity.setBeingEdited(YES_EDITING);
        entity.setCreatedBy(transaction.getUserName());
        entity.setUpdatedBy(transaction.getUserName());

        // section is usually never 'master' except when syncing, we use 'master' to indicate not editing
        // the item is public but no one is editing it
        if (BRANCH_MASTER.equalsIgnoreCase(section)) {
            entity.setBeingEdited(NOT_EDITING);
        }

        return this.dataStoreDataManager.save(entity);

    }

    /**
     * Lists the files in the folder.  Files nested in folders are returned.  Folders are not returned.  For example
     * <ul>
     * <li>file1</li>
     * <li>file2</li>
     * <li>general-attachments/file3</li>
     * <li>general-attachments/file4</li>
     * <li>glossary/file5</li>
     * <li>file6</li>
     * </ul>
     * <p>
     * Notice the file names are a path relative to the folder.
     *
     * @param folder The folder to find the files for.
     * @return A list of relative file names existing in the given folder.
     */
    private List<String> listFilesInFolder(Path folder) {
        try {
            return Files.walk(folder)
                .filter(Files::isRegularFile)
                .map(path -> folder.relativize(path).toString())
                .sorted()
                .collect(toList());
        } catch (IOException e) {
            throw new SystemException("Error listing files in path " + folder.toString(), e);
        }
    }

    /**
     * Given a root path, a list of files from the given subfolder (and any nested folders) is returned.  The file names
     * returned in the list are relative to the root path.  For example if the root path is '/data/bank/123' and the
     * subFolder is 'glossary' the return strings will be 'glossary/term_1_russian.ogg'.
     *
     * @param root
     * @param subFolder
     * @return
     */
    private List<String> listFilesInFolder(Path root, String subFolder) {
        Path folderPath = StringUtils.isNotBlank(subFolder) ? root.resolve(subFolder) : root;
        try {
            return Files.walk(folderPath)
                .filter(Files::isRegularFile)
                .map(path -> root.relativize(path).toString())
                .sorted()
                .collect(toList());
        } catch (IOException e) {
            throw new SystemException("Error listing files in path " + folderPath.toString(), e);
        }
    }

    /**
     * Returns a list of file names with the given extension inside a folder.
     *
     * @param folder        The folder to look in
     * @param fileExtension The file extension to look for
     * @return A list of files
     */
    List<String> findFilesWithExtension(Path folder, String fileExtension) {
        List<Path> filePaths = new ArrayList<>();
        try {
            Files.newDirectoryStream(folder, path -> path.toString().endsWith("." + fileExtension))
                .forEach(filePaths::add);
        } catch (IOException e) {
            throw new SystemException("Error listing files in path " + folder.toString(), e);
        }
        return filePaths.stream().map(path -> folder.relativize(path).toString()).collect(Collectors.toList());
    }
}
