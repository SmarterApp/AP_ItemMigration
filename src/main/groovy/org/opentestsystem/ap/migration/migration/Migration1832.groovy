package org.opentestsystem.ap.migration.migration

import groovy.json.JsonSlurper
import lombok.extern.slf4j.Slf4j
import org.gitlab4j.api.models.Commit
import org.opentestsystem.ap.common.client.GitClient
import org.opentestsystem.ap.common.model.EqItem
import org.opentestsystem.ap.common.model.Item
import org.opentestsystem.ap.common.repository.RepositoryUtil
import org.opentestsystem.ap.migration.model.BranchInfo
import org.opentestsystem.ap.migration.model.ItemInfo
import org.opentestsystem.ap.migration.model.MigrationDefinition
import org.opentestsystem.ap.migration.util.Util
import org.springframework.stereotype.Component

import static org.opentestsystem.ap.common.model.ItemConstants.ItemType.TYPE_EQ

@Slf4j
@Component
class Migration1832 extends AbstractMigration {

    Migration1832(final Util util) {
        super(util)
    }

    @Override
    protected void runMigration(final ItemInfo itemInfo, final BranchInfo branchInfo,
                                final MigrationDefinition migration, final GitClient gitClient) {
        final Item item = gitClient.readModelFile();

        if (item?.type == TYPE_EQ) {

            EqItem eqItem = (EqItem) item

            String commitId = findCommit(itemInfo.itemId, branchInfo.branchName)

            if (commitId) {
                final byte[] file = gitlabClient.getFile(itemInfo.projectId, RepositoryUtil.getModelFileName(), commitId)

                if (file) {
                    def itemJson = new JsonSlurper().parse(file)

                    def parts = itemJson?.core?.en?.parts ?: []

                    StringBuilder builder = new StringBuilder(256)

                    parts.each { part ->
                        if (part.exemplarResponses) {
                            part.exemplarResponses.each { builder.append(it).append("\r\n") }
                        }
                    }
                    eqItem.core.scoring.rubric = builder.toString()
                    updateItemFiles(item, gitClient)
                }
            }
        }
    }

    /**
     * Find the commit from the migration where the problem was introduced.  Then get the commit that
     * came before that one.  We want to load the item json for the commit prior to the migration.
     *
     * @param itemId The item to load
     * @return The commit ID holding the data we need
     */
    protected String findCommit(String itemId, String branchName) {
        String commitId = null
        List<Commit> commits = itemRepository.findItemBranchCommits(itemId, branchName);
        if (commits) {
            for (int i = 0; i < commits.size(); ++i) {
                if (commits[i].message == 'Migration: update metadata field names') {
                    if (i + 1 < commits.size()) {
                        commitId = commits[i + 1].id
                    }
                }
            }
        }
        commitId
    }
}