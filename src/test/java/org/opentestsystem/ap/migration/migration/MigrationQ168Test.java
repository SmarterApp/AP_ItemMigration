package org.opentestsystem.ap.migration.migration;

import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;
import org.apache.commons.io.IOUtils;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.NoSuchElementException;
import org.opentestsystem.ap.common.datastore.DataStoreAttachmentManager;
import org.opentestsystem.ap.common.datastore.DataStoreDataManager;
import org.opentestsystem.ap.common.datastore.DataStoreItemManager;
import org.opentestsystem.ap.common.datastore.DataStoreUtility;
import org.opentestsystem.ap.common.datastore.entity.ItemEntity;
import org.opentestsystem.ap.common.model.Attachment;
import org.opentestsystem.ap.common.model.GiItemCore;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemFactory;
import org.opentestsystem.ap.common.model.ModelConstants;
import org.opentestsystem.ap.common.model.attachment.DataStoreAttachment;
import org.opentestsystem.ap.common.model.attachment.StreamBackedResource;
import org.opentestsystem.ap.common.model.content.GiItemContent;
import org.opentestsystem.ap.migration.ApplicationProperties;
import org.opentestsystem.ap.migration.model.MigrationContext;
import org.opentestsystem.ap.migration.util.ApplicationDependencyProvider;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyLong;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.ap.common.model.ModelConstants.BranchNames.BRANCH_MASTER;
import static org.opentestsystem.ap.common.model.ModelConstants.ItemType.TYPE_GI;
import static org.opentestsystem.ap.common.model.ModelConstants.Section.SECTION_CORE;
import static org.springframework.util.MimeTypeUtils.APPLICATION_OCTET_STREAM_VALUE;

@RunWith(MockitoJUnitRunner.class)
public class MigrationQ168Test {
    private static final String ItemId = "1234";
    private static final String ArchiveFilename = "gi-archive.zip";

    @Rule
    public TemporaryFolder temporaryFolder = new TemporaryFolder();

    @Mock
    private ApplicationProperties applicationProperties;

    @Mock
    private DataStoreDataManager dataManager;

    @Mock
    private DataStoreItemManager dataStoreItemManager;

    @Mock
    private DataStoreUtility dataStoreUtility;

    @Mock
    private DataStoreAttachmentManager dataStoreAttachmentManager;

    @Mock
    private ApplicationDependencyProvider applicationDependencyProvider;

    @Mock
    private MigrationContext migrationContext;

    @InjectMocks
    private MigrationQ168 migration;

    private ItemFactory itemFactory = new ItemFactory();

    @Before
    public void setup() {
        when(dataStoreAttachmentManager.saveAttachment(eq(ItemId), any(), any(), anyLong(), any()))
                .thenAnswer(invocation -> {
                    final DataStoreAttachment sourceAttachment = invocation.getArgumentAt(2, DataStoreAttachment.class);
                    return sourceAttachment.toBuilder()
                            .attachment(Attachment.newAttachment(sourceAttachment.getAttachment().getFileName(), "core", "new-version"))
                            .build();
                });
    }

    @Test
    public void itShouldTouchEveryItem() {
        for (final String itemType : ModelConstants.ItemType.TIMS_ITEM_TYPES) {
            if (TYPE_GI.equals(itemType)) continue;

            final ItemEntity entity = itemEntity(ItemId, itemType);
            assertThat(migration.migrateEntity(entity, migrationContext)).isEqualTo(entity);
            verifyZeroInteractions(dataStoreAttachmentManager);
        }
    }

    @Test
    public void itShouldExpandGIArchivesInMasterBranch() throws Exception {
        final ItemEntity entity = createGiItem();
        final Path archive = createArchive();

        when(dataStoreAttachmentManager.openAttachment(eq(ItemId), eq(BRANCH_MASTER), any()))
                .thenReturn(new StreamBackedResource(Files.newInputStream(archive), archive.toFile().length(), APPLICATION_OCTET_STREAM_VALUE));

        final ItemEntity updated = migration.migrateEntity(entity, migrationContext);
        final GiItemContent updatedContent = (GiItemContent) updated.getItemJson().getCore().getEn();

        assertThat(updatedContent.getGiResources().stream()
            .map(Attachment::getFileName))
            .containsOnly("resource_a.png", "resource_b.png");
        assertThat(updatedContent.getGiResources().stream()
                .map(Attachment::getVersionId))
                .containsOnly("new-version");

        assertThat(updatedContent.getGiDefinition()).isNotBlank();

        final ArgumentCaptor<DataStoreAttachment> attachmentCaptor = ArgumentCaptor.forClass(DataStoreAttachment.class);
        verify(dataStoreAttachmentManager, times(2))
                .saveAttachment(eq(ItemId), eq(BRANCH_MASTER), attachmentCaptor.capture(), anyLong(), any());
        assertThat(attachmentCaptor.getAllValues().stream()
            .map(DataStoreAttachment::getAttachment)
            .map(Attachment::getFileName))
                .containsOnly("resource_a.png", "resource_b.png");
    }

    @Test
    public void itShouldExpandGIArchivesInCoreBranch() throws Exception {
        final ItemEntity entity = createGiItem();
        entity.setBranchName(SECTION_CORE);
        final Path archive = createArchive();

        when(dataStoreAttachmentManager.openAttachment(eq(ItemId), eq(SECTION_CORE), any()))
                .thenReturn(new StreamBackedResource(Files.newInputStream(archive), archive.toFile().length(), APPLICATION_OCTET_STREAM_VALUE));

        migration.migrateEntity(entity, migrationContext);

        verify(dataStoreAttachmentManager, times(2))
                .saveAttachment(eq(ItemId), eq(SECTION_CORE), any(), anyLong(), any());
    }

    @Test
    public void itShouldFallBackToMasterArchiveInCoreBranch() throws Exception {
        final ItemEntity entity = createGiItem();
        entity.setBranchName(SECTION_CORE);
        final Path archive = createArchive();

        when(dataStoreAttachmentManager.openAttachment(eq(ItemId), eq(SECTION_CORE), any()))
                .thenThrow(new NoSuchElementException("Not found"));
        when(dataStoreAttachmentManager.openAttachment(eq(ItemId), eq(BRANCH_MASTER), any()))
                .thenReturn(new StreamBackedResource(Files.newInputStream(archive), archive.toFile().length(), APPLICATION_OCTET_STREAM_VALUE));

        migration.migrateEntity(entity, migrationContext);

        verify(dataStoreAttachmentManager).openAttachment(eq(ItemId), eq(BRANCH_MASTER), any());

        verify(dataStoreAttachmentManager, times(2))
                .saveAttachment(eq(ItemId), eq(SECTION_CORE), any(), anyLong(), any());

    }

    private ItemEntity createGiItem() {
        final GiItemContent content = new GiItemContent();
        content.setContentZipFile(Attachment.newAttachment(ArchiveFilename, "core"));

        final GiItemCore core = new GiItemCore();
        core.setEn(content);

        final ItemEntity itemEntity = itemEntity(ItemId, TYPE_GI);
        itemEntity.getItemJson().setCore(core);

        return itemEntity;
    }

    private ItemEntity itemEntity(final String itemId, final String itemType) {
        final Item item = itemFactory.newItem(itemId, itemType);
        final ItemEntity entity = new ItemEntity(itemId, BRANCH_MASTER);
        entity.setItemJson(item);
        return entity;
    }

    private Path createArchive() throws IOException {
        final Path giArchive = temporaryFolder.newFile(ArchiveFilename).toPath();

        try (final OutputStream fileStream = Files.newOutputStream(giArchive);
             final ZipArchiveOutputStream archiveStream = new ZipArchiveOutputStream(fileStream)) {
            final String gaxContent = "<Question id=\"3483\" ITSVer=\"0\" ScoreEngineVer=\"1\" version=\"2.0\" xmlns=\"\">\n" +
                    "  <Description/>\n" +
                    "  <QuestionPart id=\"1\">\n" +
                    "    <Options/>\n" +
                    "    <Text/>\n" +
                    "    <ObjectMenuIcons/>\n" +
                    "    <ImageSpec>\n" +
                    "      <FileSpec>resource_a.png</FileSpec>\n" +
                    "      <Position>0,0</Position>\n" +
                    "    </ImageSpec>\n" +
                    "    <ImageSpec>\n" +
                    "      <FileSpec>resource_b.png</FileSpec>\n" +
                    "      <Position>0,0</Position>\n" +
                    "    </ImageSpec>\n" +
                    "  </QuestionPart>\n" +
                    "  <PreSetAnswerPart>\n" +
                    "    <AnswerSet>\n" +
                    "      <Question id=\"3483\">\n" +
                    "        <QuestionPart id=\"1\">\n" +
                    "          <ObjectSet/>\n" +
                    "          <SnapPoint/>\n" +
                    "        </QuestionPart>\n" +
                    "      </Question>\n" +
                    "    </AnswerSet>\n" +
                    "  </PreSetAnswerPart>\n" +
                    "</Question>\n";
            addEntry(archiveStream, "test-gax.gax", gaxContent);
            addEntry(archiveStream, "resource_a.png", "resource-a");
            addEntry(archiveStream, "resource_b.png", "resource-b");
            addEntry(archiveStream, "unused.png", "unused");
        }
        return giArchive;
    }

    private void addEntry(final ZipArchiveOutputStream archiveStream, final String filename, final String content) throws IOException {
        final ZipArchiveEntry entry = new ZipArchiveEntry(filename);
        final byte[] byteContent = content.getBytes(UTF_8);
        entry.setSize(byteContent.length);
        archiveStream.putArchiveEntry(entry);
        try (final ByteArrayInputStream data = new ByteArrayInputStream(byteContent)) {
            IOUtils.copy(data, archiveStream);
        }
        archiveStream.closeArchiveEntry();
    }

}